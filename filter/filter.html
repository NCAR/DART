<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
          "http://www.w3.org/TR/html4/strict.dtd">
<HTML>
<HEAD>
<TITLE>program filter</TITLE>
<link rel="stylesheet" type="text/css" href="../doc/html/doc.css">
<link href="../doc/html/dart.ico" rel="shortcut icon" />
</HEAD>
<BODY>
<A NAME="TOP"></A>

<H1>PROGRAM <em class=program>filter</em></H1>

<table border=0 summary="" cellpadding=5>
<tr>
    <td valign=middle>
    <img src="../doc/html/Dartboard7.png" alt="DART project logo" height=70 />
    </td>
    <td>
       <P>Jump to <a href="../index.html">DART Documentation Main Index</a><br />
          <small><small>version information for this file: <br />
          <!-- version tag follows, do not edit -->
          $Id$</small></small>
       </P></td>
</tr>
</table>

<A HREF="#Namelist">NAMELIST</A> /
<A HREF="#Modules">MODULES</A> /
<A HREF="#FilesUsed">FILES</A> /
<A HREF="#References">REFERENCES</A> /
<A HREF="#Errors">ERRORS</A> /
<A HREF="#FuturePlans">PLANS</A> /
<A HREF="#Legalese">TERMS OF USE</A>

<H2>Overview</H2>

<P>
   Main program for driving ensemble filter assimilations. 
</P>
<P>
   <em class=program>filter</em> is a Fortran 90 program, and provides a large
   number of options for controlling execution behavior and parameter configuration
   that are driven from its namelist. 
   See the <a href=#Namelist>namelist</a> section below for more details.
   The number of assimilation steps to be done 
   is controlled by the input observation sequence and by the 
   time-stepping capabilities of the model being used in the assimilation.
</P><P>
   This overview includes these subsections:
</P>
<UL><LI> <A href="#ProgramFlow">Program Flow</A> </LI>
    <LI> <A href="#FilterTypes">Filter Types</A> </LI>
    <LI> <A href="#GettingStarted">Getting Started</A> </LI>
    <LI> <A href="#FreeRun">Free Model Run after Assimilation</A> </LI>
    <LI> <A href="#EvalOnly">Evaluate a Model State against Observations</A> </LI>
    <LI> <A href="#Verify">Compare Results with and without Assimilation</A> </LI>
    <LI> <A href="#QCVals">DART Quality Control Values on Output</A> </LI>
    <LI> <A href="#Inflation">Description of Inflation Options</A> </LI>
    <LI> <A href="#DetailedProgramFlow">Detailed Program Flow</A> </LI>
</UL>
<P>
   See the <A href="http://www.image.ucar.edu/DAReS/DART">DART web site</A> 
   for more documentation, including a discussion of the capabilities of the
   assimilation system, a diagram of the entire execution cycle, the options
   and features.
</P>


<A NAME="ProgramFlow"></A>
<H4>Overview of Program Flow</H4>
<P>
   The basic execution loop is:
</P>
<UL><LI>Read in model initial conditions, observations, set up and initialize</LI>
    <LI>Until out of observations:
    <UL><LI>Run multiple copies of the model to get forecasts of model state</LI>
        <LI>Assimilate all observations in the current time window</LI>
        <LI>Repeat</LI>
    </UL></LI>
    <LI>Write out diagnostic files, restart files, 
        final observation sequence file</LI>
</UL>
<P>
The time of the observations in the input observation sequence file
controls the length of execution of filter.
</P> <P>
   The same source code is used for all applications of filter.
   The code specific to the types of observations and the interface code
   for the computational model is configured at compile time.
   The DART directory structure is arranged slightly differently than usual
   in that the main code is spread across a dozen directories
   at the top level, e.g. the filter source code is in DART/filter/filter.f90.
   Each model has a separate directory under DART/models, and under each model
   is a work directory where the code is compiled and can be run for testing.
   Generally when a full-size experiment is done the executables are copied
   to a different location - e.g. scratch space on a large filesystem - since the
   data files for 10s to 100s of copies of a model can get very large.
</P>

<A NAME="FilterTypes"></A>
<H4>Types of Filters available</H4>
<P>
   The different types of assimilation algorithms 
   (EAKF, ENKF, Kernel filter, Particle filter, etc.) are determined
   by the <em class=code>&amp;assim_tools_nml:filter_kind</em> entry,
   described in <a href="../assim_tools/assim_tools_mod.html">assim_tools_mod.html</a>.
   Despite having 'filter' in the name, they are assimilation algorithms
   and so are implemented in <em class=file>assim_tools_mod.f90</em>.
</P>

<A NAME="GettingStarted"></A>
<H4>Getting Started</H4>
<P>
Running a successful assimilation takes careful diagnostic work 
and experiment iterations to find the best settings for your 
specific case.  The basic
Kalman filter can be coded in only a handful of lines; the hard work is 
making the right choices to compensate for sampling errors,
model bias, observation error, lack of model divergence, variations
in observation density in space and time, random correlations, etc.  
There are tools built into DART to deal with most of these problems
but it takes careful work to apply them correctly.
</P> <P>
If you are adding a new model or a new observation type, we suggest
you assimilate exactly one observation, with no model advance, 
with inflation turned off, with a large cutoff, and with the 
outlier threshold off (see below for how to set these namelist 
items).  Run an assimilation.  Look at the obs_seq.final file
to see what the forward operator computed.  Use ncdiff to difference
the Prior and Posterior Diag NetCDF files and look at the changes
(the "innovations") in the various model fields.  Is it in the right
location for that observation?  Does it have a reasonable value?
</P> <P>
Then assimilate a group of observations and check the results 
carefully. Run the observation diagnostics and look at the total
error and spread.  Look carefully at the number of observations
being assimilated compared to how many are available.  Assimilations
that are not working can give good looking statistics if they reject
all but the few observations that happen to match the current state.
The errors should grow as the model advances and then shrink when
new observations are assimilated, so a time-plot of the RMSE
should show a sawtooth pattern.  The initial error might be large
but it should decrease and then reach a roughly stable level.
The spread should remain constant, at a value around the expected 
observation error level.
If the spread is too small that is ok for the baseline case; 
several of the DART facilities described below are intended to 
compensate for ensemble members getting too close to each other.
Once you believe you have a working assimilation case, this
will be your baseline case.
Then one by one enable or tune each of the items below, checking 
each time to see what is the effect on the results.
</P> <P>
Suggestions for the most common namelist settings and features built
into DART for running a successful assimilation include:
</P>
<ul>
<li>Ensemble Size
<P>
In practice, ensemble sizes between 20 and 100 seem to work best.  
Fewer than 20-30 members leads to statistical errors which are too large.
More than
100 members takes longer to run with very little return, and eventually
the results get worse again.  Often the limit on the number of members
is based on the size of the model since you have to run N copies
of the model each time you move forward in time.  If you can,
start with 50-60 members and then experiment with fewer or more
once you have a set of baseline results to compare it with.
The namelist setting for ensemble size is
<em class="code">&amp;filter_nml :: ens_size </em>
</P></li>
<li>Localization
<P>
There are two main advantages to using localization.  One is it avoids
an observation impacting unrelated state variables because of spurious
corelations.  The other is that especially for large models it improves
run-time performance because only points within the localization
radius need to be considered.  Because of the way the parallelization
was implemented in DART, localization was easy to add and
using it usually results in a very large performance gain. 
See <a href="../assim_tools/assim_tools_mod.html#Localization">here</a>
for a discussion of localization-related namelist items.
</P></li>
<li>Inflation
<P>
Since the filter is being run with a fixed number of ensembles
which is usually small compared to the number of degrees of freedom
of the model (i.e. the size of the state vector), the tendency
is for all the ensemble members to collapse towards a single solution.
Inflation increases the spread of the members in a systematic way
to avoid problems of collapse.  There are several sophisticated
options on inflation, including spatial and temporal adaptive
and damping options, which help deal with observations which
vary in density over time and location.
See <a href="#Inflation">here</a>
for a discussion of inflation-related namelist items.
</P></li>
<li>Outlier Rejection
<P>
Outlier rejection can be used to avoid bad observations (ones
where the value was recorded in error or the processing has an
error and a non-physical value was generated).  It also avoids
observations which have accurate values but the mean of the
ensemble members is so far from the observation value that
assimilating it would result in unacceptably large increments
that might destablize the model run.  If the difference between
the observation and the prior ensemble mean is more than N standard
deviations from the square root of the sum of the 
prior ensemble and observation error variance, the observation will
be rejected.
The namelist setting for the number of standard deviations
to include is
<em class="code">&amp;filter_nml :: outlier_threshold </em>
and we typically suggest starting with a value of 3.0.
</P></li>
<li>Sampling Error
<P>
For small ensemble sizes a table of expected statistical error 
distributions can be generated before running DART.  Corrections
accounting for these errors are applied during the assimilation 
to increase the ensemble
spread which can improve the assimilation results.  
The namelist item to enable this option is 
<em class="code">&amp;assim_tools_nml :: sampling_error_correction</em>.
Additionally you will need to have a 
precomputed correction file <em class="file">final_full.X</em>,
where X matches your ensemble size, in the run directory.
See the description of the namelist item in the
<a href="../assim_tools/assim_tools_mod.html#Namelist">
&amp;assim_tools_nml</a> namelist, and 
<a href="../system_simulation/system_simulation.html">look here</a>
for instructions on where to find (or how to generate) 
the auxiliary file needed by this code.
See Anderson (2011).
</P></li>
</ul>


<A NAME="FreeRun"></A>
<H4>Free run/Forecast After Assimilation</H4>
<P>
   Separate scripting can be done to support forecasts starting from the
   analyzed model states.  After filter exits, the models can be
   run freely (with no assimilated data) further forward in time
   using one or more of the last updated model states from filter.
   Since all ensemble members are equally likely a member can be
   selected at random, or a member close to the mean can be chosen.
   See the <a href="../utilities/closest_member_tool.html">closest_member_tool</a>
   for one way to select a "close" member.  The ensemble mean is available to
   be used, but since it is a combination of all the member states it
   may not have self-consistent features, so using a single member is
   usually preferred.
</P>

<A NAME="EvalOnly"></A>
<H4>Evaluating Observations Without Assimilation</H4>
<P>
   Filter can be used
   to evaluate the accuracy of a single model state based on a set of
   available observations. 
   Convert the model data
   into a single DART state vector, and either copy or link it so there
   appear to be 2 separate ensemble members (which are identical).
   Set the filter namelist ensemble size to 2
   by setting 
   <em class="code">ens_size</em> to 2 in the
   &amp;filter_nml namelist.
   Turn off the outlier threshold and both Prior and Posterior inflation
   by setting 
   <em class="code">outlier_threshold</em> to -1, and
   both the <em class="code">inf_flavor</em> values to 0 in the
   same &amp;filter_nml namelist.
   Set all observation types to be 'evaluate-only' and have no types
   in the 'assimilate' list by listing all types in the
   <em class="code">evaluate_these_obs_types</em>
   list in the <em class="code">&amp;obs_kind_nml</em>
   section of the namelist, and none in the assimilation list.  
   Run filter as usual, including model advances if needed.
   Run observation diagnostics on the resulting obs_seq.final file to
   compute the difference between the observed values and the
   predicted values from this model state.
</P>

<A NAME="Verify"></A>
<H4>Verification/Comparison With and Without Assimilation</H4>
<P>
   To compare results of an experiment with and without assimilating data, 
   do one run assimilating the observations.  Then do a second run where
   all the observation types are moved to the 
   <em class="code">evaluate_these_obs_types</em>
   list in the <em class="code">&amp;obs_kind_nml</em>
   section of the namelist.  Also turn inflation off by setting both 
   <em class="code">inf_flavor</em> values to 0 in the &amp;filter_nml namelist.  
   The forward operators will still be called, but they will have no
   impact on the model state.  Then the two sets of diagnostic state space
   netcdf files can be compared to evaluate the impact of assimilating 
   the observations, and the observation diagnostic files can also be compared.
</P>

<A NAME="QCVals"></A>
<H4>DART Quality Control Flag added to Output Observation Sequence File</H4>
<P>
   The filter adds a quality control field with metadata 'DART quality control'
   to the obs_seq.final file. At present, this field can have the following
   values:
</P>

<TABLE border=0 cellpadding=3 width=100%>
   <TR><TD>0:</TD><TD> Observation is okay </TD></TR>
   <TR><TD>1:</TD><TD> Observation was evaluated only but not
      used in the assimilation </TD></TR>
   <TR><TD>2:</TD><TD> The observation was used but one or more of
      the posterior forward observation operators failed </TD></TR>
   <TR><TD>3:</TD><TD> The observation
      was evaluated only but not used AND one or more of the posterior 
      forward observation operators failed </TD></TR>
   <TR><TD>4:</TD><TD> One or more prior forward observation
      operators failed so the observation was not used </TD></TR>
   <TR><TD>5:</TD><TD> The observation was
      not used because it was not selected in the namelist to be assimilated
      or evaluated </TD></TR>
   <TR><TD>6:</TD><TD> The prior quality control value was too high so the
      observation was not used.  </TD></TR>
   <TR><TD>7:</TD><TD> Outlier test failed (see below)</TR>
</TABLE>

<P>
   The outlier test computes the difference between the observation value
   and the prior ensemble mean.  It then computes a standard deviation by
   taking the square root of the sum of the observation error variance and
   the prior ensemble variance for the observation.  If the difference
   between the ensemble mean and the observation value is more than the
   specified number of standard deviations, then the observation is not
   used and the DART quality control field is set to 7.
</P>

<A NAME="Inflation"></A>
<H4>Discussion of Inflation Options</H4>
<P>
There are two choices for the basic type of inflation:
observation space or state space.  Almost all users use state
space inflation and the rest of this discussion applies
to this type.  (If you are interested in observation
space inflation, talk to Jeff first.)
</P> <P>
State space inflation changes the spread of a set of ensemble members
without changing the mean value.  The algorithm computes the mean 
and standard deviation for each variable in the state vector 
in turn, and then moves the values away from the mean in such a 
way that the mean remains unchanged. The resulting standard deviation
is (generally) larger than before.  It can be applied to the
Prior state, before observations are assimilated (the most
frequently used case), or it can be applied to the Posterior
state, after assimilation.  See Anderson (2007), Anderson (2009).
</P> <P>
Inflation can be a single value applied to all
state space variables over all times.  It can 
be a single value per state space variable, constant
in time.  And finally, it can vary with time, adapting
to different densities of observations in time and space.
To enable state space inflation, see the 'flavor' 
namelist options below.
See the 'start_from_restart' options to set
a single value verses a value per state space variable.
To allow the values to adapt through time in each 
assimilation window see the 'sd_initial' description.
There are additional options to damp inflation through time. 
In regions
where the density of observations varies in time the damping
slowly lowers the inflation values in the absence of new
observations at those locations.
In practice with large geophysical models using damped
inflation has been a successful strategy.
See the section describing 'inf_damping'.
</P> <P>
The following namelist items related to inflation
are all found in the <em class=file>input.nml</em> file,
in the &amp;filter_nml namelist. 
The detailed descriptions are in the
<a href="#Namelist">namelist</a> section below.
Here we try to give some basic advice about
commonly used values and suggestions for
where to start.
In the namelist each entry has
two values.  The first is for Prior inflation
and the second is for Posterior inflation.
If 'flavor' is 0, all other settings for that
column are ignored.
</P>
<dl>
<dt>
<em>&amp;filter_nml :: flavor</em><br />
valid values: 0, 1, 2, 3
<dd>
Set the type of Prior and Posterior inflation applied
to the state vector.  Values mean:
<table border=0 cellpadding=3 width=100%>
   <tr><td>0:</td><td> No inflation </td></tr>
   <tr><td>1:</td><td> Observation space inflation </td></tr>
   <tr><td>2:</td><td> Spatially-varying state space inflation </td></tr>
   <tr><td>3:</td><td> Spatially-fixed state space inflation </td></tr>
</table>
In practice
we recommend starting with no inflation at all (both values
0), and then when first trying out inflation start with type 2 
prior inflation and no inflation (0) for posterior.
<br /> <br />
<dt>
<em>&amp;filter_nml :: inf_deterministic</em><br />
valid values: .true. or .false.
<dd>
Recommend always using .true..
<br /> <br />
<dt>
<em>&amp;filter_nml :: inf_initial</em><br />
valid values: real numbers, usually 1.0 or slightly larger
<dd>
If not reading in inflation values from a restart file,
the initial value to set for the inflation.  Generally
we recommend starting with just slightly above 1.0, 
maybe 1.02, for a slight amount of initial inflation.
<br /> <br />
<dt>
<em>&amp;filter_nml :: inf_sd_initial</em><br />
valid values: 0.0 to infinity, or -1 to disable
<dd>
This namelist setting controls whether the inflation
values evolve with time or not.  A negative value prevents
the inflation values from being updated, so they are
constant throughout the run.  If positive, the inflation
values evolve through time.  Even though we talk
about a single inflation value, the inflation has
a gaussian distribution with a mean and standard deviation.
We use the mean value when we inflate, and the
standard deviation indicates how sure 
of the value we are. Larger standard deviation values are 
less sure and the inflation value will vary more quickly 
with time.
Smaller values are more sure and the time evolution will
be slower since we are more confident that the mean is correct.
We have had good results setting this and inf_sd_lower_bound
to 0.6 for large geophysical models.
<br /> <br />
<dt>
<em>&amp;filter_nml :: inf_lower_bound</em><br />
valid values: real numbers, usually 1.0 or slightly larger
<dd>
If inflation is time-evolving (see inf_sd_initial namelist item above),
then this sets the lowest value the inflation can evolve to.
Setting a number less than one allows for deflation but generally
in a well-observed system the ensemble needs more spread and not less.
We recommend a setting of 1.0.
<br /> <br />
<dt>
<em>&amp;filter_nml :: inf_upper_bound</em><br />
valid values: real numbers, usually 1.0 or slightly larger
<dd>
If inflation is time-evolving (see inf_sd_initial namelist item above),
then this sets the largest value the inflation can evolve to.
We recommend a setting of 100.0, although if the inflation
values reach those levels there is probably a problem
with the assimilation.
<br /> <br />
<dt>
<em>&amp;filter_nml :: inf_sd_lower_bound</em><br />
valid values: 0.0 to infinity, or -1 to disable
<dd>
If the setting of <em class="code">inf_sd_initial</em> is
-1.0 (to disable time evolution of inflation) then set
this to the same value.  Otherwise, set a lower value
that the standard deviation of the inflation cannot fall
below.  As the width of the inflation distribution changes,
this sets a lower bound for the value.  Lower values will
let the inflation vary more slowly with time; larger values
will allow the inflation to adapt in time more quickly.
We have had good results setting this and inf_sd_initial
to 0.6 for large geophysical models.
<br /> <br />
<dt>
<em>&amp;filter_nml :: inf_damping</em><br />
valid values: 0.0 to 1.0
<dd>
Applies if inflation is time-evolving.
The difference between the current inflation value and 1.0 
is multiplied by this factor before the next assimilation cycle. 
0.0 turns all inflation off by clamping the inflation value to 1.0.
1.0 turns damping off by leaving the original inflation value unchanged.
We have had good results in large geophysical models setting
this to a value of 0.9, which damps slowly.  Damping appears to
particularly help in cases where there are dense clusters of observations
at irregular times.  Areas that are heavily observed evolve
large inflation values to prevent the ensemble members from becoming
too close to one another.  However once the area is unobserved 
there was no mechanism to cause the inflation values to drop 
back down to smaller levels.  The damping factor accomplishes this.
<br /> <br />
<dt>
<em>&amp;filter_nml :: inf_output_restart </em><br />
valid values: text string
<dd>
The name of the file to write the inflation and
standard deviation values into.  This can be used
to let spatially-varying inflation values evolve 
in a spinup phase, and then be read in and used as
fixed values in further runs.  Or if a long assimilation
run is executed in separate jobs steps and time-varying
inflation is used, then the restart file from the
previous job step must be supplied as an input file
for the next step.  This filename sets where the output
is going to be written.  Note that there is only a single
inflation value and a single standard deviation value
per state vector variable will be written, so the total 
file size will be two times the state vector length 
(times the number of bytes in a real value).
<br /> <br />
</dl>

<P>
The suggested procedure for testing inflation options 
is to start without
any (both 'flavor' values set to 0).  Then enable Prior
state space, spatially-varying inflation, with no Posterior
inflation (set 'flavor' to [2, 0]).  Then try damped
inflation (set 'inf_damping' to 0.9 and set 'inf_sd_initial'
and 'inf_sd_lower_bound' to 0.6).  The inflation values and
standard deviation are written out to the Prior_Diag.nc
and Posterior_Diag.nc files as the last 2 'copies', so 
the inflation fields can be plotted (we often use 
<a href="http://meteora.ucsd.edu/~pierce/ncview_home_page.html">ncview</a>
).  
Expected inflation values are generally in the 1 to 10 range; 
if values grow much larger than this it usually indicates
a problem with the assimilation.

</P> 

<A NAME="DetailedProgramFlow"></A>
<H4>Detailed Program Execution Flow</H4>
<P>
The detailed execution flow inside the filter program is:
</P>

<ul>
<li>Read in observations.  </li>
<li>Read in state vector restart files.  </li>
<li>Initialize inflation fields, possibly reading restart files. </li>
<li>Initialize output netcdf diagnostic files. </li>
<li>Trim off any observations if start/stop times specified. </li>
<li>Begin main assimilation loop:
<ul>
<li>Check model time vs observation times: 
<ul>
<li>If current assimilation window is earlier than model time, error. </li>
<li>If current assimilation window includes model time, begin assimilating. </li>
<li>If current assimilation window is later than model time, advance model:
<ul>
<li>Write out current state vectors for all ensemble members. </li>
<li>Advance the model by subroutine call or by shell script:
<ul>
<li>Convert the data into format suitable for model. </li>
<li>Tell the model to run up to the requested time. </li>
<li>Convert the new data back into DART format. </li>
</ul>
</li>
<li>Read in new state vectors for all ensemble members. </li>
</ul></li>
</ul></li>
<li>Apply prior inflation if requested. </li>
<li>Compute ensemble of prior observation values with forward operators. </li>
<li>Compute and write out prior state space diagnostics. (Note this is AFTER
    any prior inflation has been applied.)</li>
<li>Compute and write out prior observation space diagnostics. </li>
<li>Assimilate all observations in this window:
<ul>
<li>Get all obs locations and kinds. </li>
<li>Get all state vector locations and kinds. </li>
<li>For each observation:
<ul>
<li>Compute the observation increments. </li>
<li>Find all other obs and states within localization radius. </li>
<li>Compute the covariance between obs and state variables. </li>
<li>Apply increments weighted by correlation values. </li>
<li>Apply increments to any remaining unassimilated observations. </li>
<li>Loop until all observations in window processed. </li>
</ul></li>
</ul></li>
<li>Apply posterior inflation if requested. </li>
<li>Compute ensemble of posterior observation values with forward operators. </li>
<li>Compute and write out posterior state space diagnostics. </li>
<li>Compute and write out posterior observation space diagnostics. </li>
<li>Loop until all observations in input file processed. </li>
</ul></li>
<li>Close diagnostic files. </li>
<li>Write out final observation sequence file. </li>
<li>Write out inflation restart files if requested. </li>
<li>Write out state vector restart files if requested. </li>
<li>Release memory for state vector and observation ensemble members. </li>
</ul>
  
<P>
Namelist
<A HREF="#Namelist"> <em class=code>&amp;filter_nml</em> </A>
is always read from file <em class=file>input.nml</em>.
</P>

<!--==================================================================-->
<!--=================== DESCRIPTION OF A NAMELIST ====================-->
<!--==================================================================-->

<A NAME="Namelist"></A>
<HR>
<H2>NAMELIST</H2>
<P>We adhere to the F90 standard of starting a namelist with an ampersand
'&amp;' and terminating with a slash '/' for all our namelist input.
Character strings that contain a '/' must be
enclosed in quotes to prevent them from prematurely terminating the namelist.
The namelist declaration is:
</P>
<div class=namelist>
<pre>
<em class=call>namelist / filter_nml / </em>
  async,
  adv_ens_command,
  tasks_per_model_advance,
  ens_size,
  start_from_restart,
  output_restart,
  obs_sequence_in_name,
  obs_sequence_out_name,
  restart_in_file_name,
  restart_out_file_name,
  init_time_days,
  init_time_seconds,
  first_obs_days,
  first_obs_seconds,
  last_obs_days,
  last_obs_seconds,
  obs_window_days,
  obs_window_seconds,
  num_output_state_members,
  num_output_obs_members,
  output_interval,
  num_groups,
  input_qc_threshold,
  outlier_threshold,
  enable_special_outlier_code,
  output_forward_op_errors,
  output_restart_mean,
  output_timestamps,
  output_inflation,
  trace_execution,
  silence,
    
  inf_flavor,
  inf_initial_from_restart,
  inf_sd_initial_from_restart,
  inf_output_restart,
  inf_deterministic,
  inf_in_file_name,
  inf_out_file_name,
  inf_diag_file_name,
  inf_initial,
  inf_sd_initial,
  inf_damping,
  inf_lower_bound,
  inf_upper_bound,
  inf_sd_lower_bound
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
This namelist is always read from a file called <em class=file>input.nml</em>.
It controls various aspects of filter. 
</P>
<P>
Particular options to be aware of are:
async, ens_size, cutoff (localization radius), inflation flavor, outlier_threshold,
restart filenames (including inflation), obs_sequence_in_name, horiz_dist_only,
binary or ascii controls for state vector and observation sequence file formats.
Some of these important items are located in other namelists, but all are in the
same input.nml file.
</P>
<P>
The inflation control variables are all
dimensioned 2, the first value being for the prior inflation and the second
being for the posterior inflation.
</P>

<TABLE border=0 cellpadding=3 width=100%>
<TR><TH align=left>Contents    </TH>
    <TH align=left>Type        </TH>
    <TH align=left>Description </TH></TR>

<TR><!--contents--><TD valign=top>async</TD>
    <!--  type  --><TD valign=top>integer</TD>
    <!--descript--><TD>Controls method for advancing model: 
                       0 is subroutine call, 
                       2 is shell command, 
                       4 is mpi-job script. 
                       Default: 0</TD></TR>

<TR><!--contents--><TD valign=top>adv_ens_command</TD>
    <!--  type  --><TD valign=top>character(len=129)</TD>
    <!--descript--><TD>Command sent to shell if async is 2. 
                       Default: ./advance_model.csh</TD></TR>

<TR><!--contents--><TD valign=top>tasks_per_model_advance</TD>
    <!--  type  --><TD valign=top>integer</TD>
    <!--descript--><TD>Reserved for future use.
                       Default: 1</TD></TR>

<TR><!--contents--><TD valign=top>ens_size</TD>
    <!--  type  --><TD valign=top>integer</TD>
    <!--descript--><TD>Size of ensemble.
                       Default: 20</TD></TR>

<TR><!--contents--><TD valign=top>start_from_restart</TD>
    <!--  type  --><TD valign=top>logical</TD>
    <!--descript--><TD>True means start from a restart file, false means 
                       perturb a single state vector in restart file. 
                       Default: .false.</TD></TR>

<TR><!--contents--><TD valign=top>output_restart</TD>
    <!--  type  --><TD valign=top>logical</TD>
    <!--descript--><TD>True means output a restart file. 
                       Default: .false.</TD></TR>

<TR><!--contents--><TD valign=top>obs_sequence_in_name</TD>
    <!--  type  --><TD valign=top>character(len=129)</TD>
    <!--descript--><TD>File name from which to read an observation sequence. 
                       Default: obs_seq.out</TD></TR>

<TR><!--contents--><TD valign=top>obs_sequence_out_name</TD>
    <!--  type  --><TD valign=top>character(len=129)</TD>
    <!--descript--><TD>File name to which to write output observation sequence. 
                       Default: obs_seq.final</TD></TR>

<TR><!--contents--><TD valign=top>restart_in_file_name</TD>
    <!--  type  --><TD valign=top>character(len=129)</TD>
    <!--descript--><TD>File containing state restart vectors. 
                       Default: filter_ics</TD></TR>

<TR><!--contents--><TD valign=top>restart_out_file_name</TD>
    <!--  type  --><TD valign=top>character(len=129)</TD>
    <!--descript--><TD>File to which to write restart state vectors. 
                       Default: filter_restart</TD></TR>

<TR><!--contents--><TD valign=top>init_time_days</TD>
    <!--  type  --><TD valign=top>integer</TD>
    <!--descript--><TD>If negative, don't use. If non-negative, override the initial 
                       days read from state data restart file. 
                       Default: 0</TD></TR>

<TR><!--contents--><TD valign=top>init_time_seconds</TD>
    <!--  type  --><TD valign=top>integer</TD>
    <!--descript--><TD>If negative don't use. If non-negative, override the initial
                       seconds read from state data restart file. 
                       Default: 0</TD></TR>

<TR><!--contents--><TD valign=top>first_obs_days</TD>
    <!--  type  --><TD valign=top>integer</TD>
    <!--descript--><TD>If negative, don't use. If non-negative, ignore all observations
                       before this time.
                       Default: -1</TD></TR>

<TR><!--contents--><TD valign=top>first_obs_seconds</TD>
    <!--  type  --><TD valign=top>integer</TD>
    <!--descript--><TD>If negative, don't use. If non-negative, ignore all observations
                       before this time.
                       Default: -1</TD></TR>

<TR><!--contents--><TD valign=top>last_obs_days</TD>
    <!--  type  --><TD valign=top>integer</TD>
    <!--descript--><TD>If negative, don't use. If non-negative, ignore all observations
                       after this time.
                       Default: -1</TD></TR>

<TR><!--contents--><TD valign=top>last_obs_seconds</TD>
    <!--  type  --><TD valign=top>integer</TD>
    <!--descript--><TD>If negative, don't use. If non-negative, ignore all observations
                       after this time.
                       Default: -1</TD></TR>

<TR><!--contents--><TD valign=top>obs_window_days</TD>
    <!--  type  --><TD valign=top>integer</TD>
    <!--descript--><TD>If negative, don't use. If non-negative, reserved for future use.
                       Default: -1</TD></TR>

<TR><!--contents--><TD valign=top>obs_window_seconds</TD>
    <!--  type  --><TD valign=top>integer</TD>
    <!--descript--><TD>If negative, don't use. If non-negative, reserved for future use.
                       Default: -1</TD></TR>

<TR><!--contents--><TD valign=top>num_output_state_members</TD>
    <!--  type  --><TD valign=top>integer</TD>
    <!--descript--><TD>Number of ensemble members to be included in the state 
                       diagnostic output. Default: 0</TD></TR>

<TR><!--contents--><TD valign=top>num_output_obs_members</TD>
    <!--  type  --><TD valign=top>integer</TD>
    <!--descript--><TD>Number of ensemble members to be included in the 
                       output observation sequence file. Default: 0</TD></TR>

<TR><!--contents--><TD valign=top>output_interval</TD>
    <!--  type  --><TD valign=top>integer</TD>
    <!--descript--><TD>Output state and observation diagnostics every 'N'th 
                       assimilation time, N is output_interval. Default: 1</TD></TR>

<TR><!--contents--><TD valign=top>num_groups</TD>
    <!--  type  --><TD valign=top>integer</TD>
    <!--descript--><TD>Number of groups for hierarchical filter. Default: 1</TD></TR>

<TR><!--contents--><TD valign=top>outlier_threshold</TD>
    <!--  type  --><TD valign=top>real(r8)</TD>
    <!--descript--><TD>Reject observation if prior mean is more than this many 
                       sd's from observation. Negative means no check. 
                       Default: -1.0_r8</TD></TR>

<TR><!--contents--><TD valign=top>enable_special_outlier_code</TD>
    <!--  type  --><TD valign=top>logical</TD>
    <!--descript--><TD>If true call a subroutine which can be customized by the
                       user to do more elaborate outlier thresholding tests.
                       See <em class=code>failed_outlier()</em> near the bottom
                       of <em class=file>filter.f90</em> for where to add the
                       custom code, and for commented out examples of possible tests.
                       Turning this flag on and off allows comparisons to be 
                       made between the default outlier threshold code and any
                       custom settings without having to recompile the code. 
                       To change the outlier behavior code has to be changed
                       in filter.f90.  As distributed, turning this flag on
                       and off will make no difference in the results.
                       Default: .false.</TD></TR>

<TR><!--contents--><TD valign=top>input_qc_threshold</TD>
    <!--  type  --><TD valign=top>real(r8)</TD>
    <!--descript--><TD>Reject observation if incoming QC value exceeds
                       'input_qc_threshold' value. Incoming observations usually have a
                       QC value set by the data provider, e.g. NCEP. 
                       Default: 3.0_r8</TD></TR>

<TR><!--contents--><TD valign=top>output_forward_op_errors</TD>
    <!--  type  --><TD valign=top>logical</TD>
    <!--descript--><TD>True means output errors from forward observation operators.
                       This is the 'istatus' error return code from the model
                       interpolate routine.  An ascii text file 'prior_forward_op_errors'
                       and/or 'post_forward_op_errors' will be created in the
                       current directory.  For each ensemble member which returns a
                       non-zero return code, a line will be written to this file.
                       Each line will have three values listed: 
                       the observation number, the ensemble member number, and 
                       the istatus return code.  Be cautious when turning this option
                       on.  The number of lines in this file can be up to 
                       the number of observations times the number of ensemble members
                       times the number of assimilation cycles performed.
                       This option is generally most useful when run with a 
                       small observation sequence file and a small number of 
                       ensemble members to diagnose forward operator problems.
                       Default: .false.</TD></TR>

<TR><!--contents--><TD valign=top>output_restart_mean</TD>
    <!--  type  --><TD valign=top>logical</TD>
    <!--descript--><TD>True means output a restart file which contains
                       the ensemble mean.  The file name will use the value
                       of the namelist item
                       '&amp;filter_nml::restart_out_file_name' 
                       as the base, with the string '.mean' appended.
                       Even if '&amp;ensemble_manager_nml::single_restart_file_out' 
                       is .true., the mean data will be written to a separate file.
                       Default: .false.</TD></TR>

<TR><!--contents--><TD valign=top>output_timestamps</TD>
    <!--  type  --><TD valign=top>logical</TD>
    <!--descript--><TD>True means output timestamps before and after the model advance
                       and the observation assimilation phases.
                       Default: .false.</TD></TR>

<TR><!--contents--><TD valign=top>output_inflation</TD>
    <!--  type  --><TD valign=top>logical</TD>
    <!--descript--><TD>True means output inflation values in the prior and posterior
                       diagnostic files.  False omits them.
                       Default: .true.</TD></TR>

<TR><!--contents--><TD valign=top>trace_execution</TD>
    <!--  type  --><TD valign=top>logical</TD>
    <!--descript--><TD>True means output very detailed messages about what routines
                       are being called in the main filter loop.  Useful if a job
                       hangs or otherwise doesn't execute as expected.
                       Default: .false.</TD></TR>

<TR><!--contents--><TD valign=top>silence</TD>
    <!--  type  --><TD valign=top>logical</TD>
    <!--descript--><TD>True means output almost no runtime messages.  Not recommended
                       for general use, but can speed test programs if the execution
                       time becomes dominated by the volume of output. 
                       Default: .false.</TD></TR>

<TR><TD colspan=3>All subsequent variables are arrays of length 2.<br />
                  The first element is for the prior, the second element is 
                  for the posterior</TD></TR>

<TR><!--contents--><TD valign=top>inf_flavor</TD>
    <!--  type  --><TD valign=top>integer array (len=2)</TD>
    <!--descript--><TD>Inflation flavor for [prior, posterior]<br />
                       0&nbsp;=&nbsp;none,
                       1&nbsp;=&nbsp;obs_space, 
                       2&nbsp;=&nbsp;spatially-varying&nbsp;state&nbsp;space,
                       3&nbsp;=&nbsp;spatially-fixed&nbsp;state&nbsp;space. 
                       (See sd_initial below for how to set the time
                       evolution options.)
                       Default: (/0, 0/)</TD></TR>

<TR><!--contents--><TD valign=top>inf_initial_from_restart</TD>
    <!--  type  --><TD valign=top>logical array (len=2)</TD>
    <!--descript--><TD>If true, get initial mean values for inflation from restart file.
                       (Replaces inf_start_from_restart, which applied to
                       both mean and standard deviation.  
                       They are now individually controllable)
                       If false, use the corresponding namelist value inf_initial.
                       Default: (/.false., .false /)</TD></TR>

<TR><!--contents--><TD valign=top>inf_sd_initial_from_restart</TD>
    <!--  type  --><TD valign=top>logical array (len=2)</TD>
    <!--descript--><TD>If true, get initial standard deviation values for 
                       inflation from restart file.
                       (Replaces inf_start_from_restart, which applied to
                       both mean and standard deviation.  
                       They are now individually controllable.)
                       If false, use the corresponding namelist value inf_sd_initial.
                       Default: (/.false., .false /)</TD></TR>

<TR><!--contents--><TD valign=top>inf_output_restart</TD>
    <!--  type  --><TD valign=top>logical array (len=2)</TD>
    <!--descript--><TD>Output an inflation restart file if true. 
                       Default: (/.false., .false./)</TD></TR>

<TR><!--contents--><TD valign=top>inf_deterministic</TD>
    <!--  type  --><TD valign=top>logical array (len=2)</TD>
    <!--descript--><TD>True means deterministic inflation, false means stochastic. 
                       Default: (/.true., .true./)</TD></TR>

<TR><!--contents--><TD valign=top>inf_in_file_name</TD>
    <!--  type  --><TD valign=top>character(len=129) by two</TD>
    <!--descript--><TD>Name from which to read inflation restart. 
                       Default: (/'not_initialized', 'not_initialized'/)</TD></TR>

<TR><!--contents--><TD valign=top>inf_out_file_name</TD>
    <!--  type  --><TD valign=top>character(len=129) by two</TD>
    <!--descript--><TD>File to which to write inflation restart file. 
                       Default: (/'not_initialized', 'not_initialized'/)</TD></TR>

<TR><!--contents--><TD valign=top>inf_diag_file_name</TD>
    <!--  type  --><TD valign=top>character(len=129) by two</TD>
    <!--descript--><TD>File to which to write output diagnostics for observation 
                       space inflation. 
                       Default: (/'not_initialized', 'not_initialized'/)</TD></TR>

<TR><!--contents--><TD valign=top>inf_initial</TD>
    <!--  type  --><TD valign=top>real(r8) (len=2)</TD>
    <!--descript--><TD>Initial value of inflation if not read from restart file. 
                       Default: (/1.0_r8, 1.0_r8/)</TD></TR>

<TR><!--contents--><TD valign=top>inf_sd_initial</TD>
    <!--  type  --><TD valign=top>real(r8) (len=2)</TD>
    <!--descript--><TD>Initial value of inflation standard deviation if not read 
                       from restart file.  If negative, do not update the inflation
                       values, so they are time-constant.  If positive, the inflation
                       values will adapt through time, so they are time-varying.
                       Default: (/0.0_r8, 0.0_r8/)</TD></TR>

<TR><!--contents--><TD valign=top>inf_damping</TD>
    <!--  type  --><TD valign=top>real(r8) (len=2)</TD>
    <!--descript--><TD>Damping factor for inflation mean values.
                       The difference between the current inflation value and 1.0
                       is multiplied by this factor before the next assimilation cycle.
                       The value should be between 0.0 and 1.0.
                       0.0 turns all inflation off (by clamping the inflation value to 1.0).
                       1.0 turns inflation damping off (leaving the original inflation
                       value unchanged).
                       Default: (/1.0_r8, 1.0_r8/)</TD></TR>

<TR><!--contents--><TD valign=top>inf_lower_bound</TD>
    <!--  type  --><TD valign=top>real(r8) (len=2)</TD>
    <!--descript--><TD>Lower bound for inflation value.
                       Default: (/1.0_r8, 1.0_r8/)</TD></TR>

<TR><!--contents--><TD valign=top>inf_upper_bound</TD>
    <!--  type  --><TD valign=top>real(r8) (len=2)</TD>
    <!--descript--><TD>Upper bound on inflation value.
                       Default: (/1000000.0_r8, 1000000.0_r8/)</TD></TR>

<TR><!--contents--><TD valign=top>inf_sd_lower_bound</TD>
    <!--  type  --><TD valign=top>real(r8) (len=2)</TD>
    <!--descript--><TD>Lower bound for inflation standard deviation. 
                       If using a negative value for sd_initial, this should also
                       be negative to preserve the setting.
                       Default: (/0.0_r8, 0.0_r8/)</TD></TR>
</TABLE>

<H4 class=indent1>Deprecated or Defunct namelist variables</H4>
<P>The following table contains the deprecated or defunct namelist variables.
   It is a FATAL ERROR to have these in the filter namelist.
</P>
<TABLE border=0 cellpadding=3 width=100%>
<TR><TH align=left>Contents    </TH>
    <TH align=left>Type        </TH>
    <TH align=left>Description </TH></TR>

<TR><!--contents--><TD valign=top>output_state_ens_mean</TD>
    <!--  type  --><TD><b>defunct</b></TD>
    <!--descript--><TD>The ensemble mean is now always in the 
                       state diagnostic output.</TD></TR>

<TR><!--contents--><TD valign=top>output_state_ens_spread</TD>
    <!--  type  --><TD><b>defunct</b></TD>
    <!--descript--><TD>The ensemble spread is now always in the
                       state diagnostic output.</TD></TR>

<TR><!--contents--><TD valign=top>output_obs_ens_mean</TD>
    <!--  type  --><TD><b>defunct</b></TD>
    <!--descript--><TD>The ensemble mean is now always in the 
                       output observation sequence file.</TD></TR>

<TR><!--contents--><TD valign=top>output_obs_ens_spread</TD>
    <!--  type  --><TD><b>defunct</b></TD>
    <!--descript--><TD>The ensemble spread is now always in the 
                       output observation sequence file.</TD></TR>

<TR><!--contents--><TD valign=top>inf_start_from_restart</TD>
    <!--  type  --><TD><b>defunct</b></TD>
    <!--descript--><TD>The mean and standard deviation now have separate
                       namelist controls.</TD></TR>
</TABLE>

</div>
<br />

<!--==================================================================-->
<!-- Describe the modules used by this program.                       -->
<!--==================================================================-->

<A NAME="Modules"></A>
<HR>
<H2>MODULES USED</H2>
<PRE>
types_mod
obs_sequence_mod
obs_def_mod
time_manager_mod
utilities_mod
assim_model_mod
assim_tools_mod
obs_model_mod
ensemble_manager_mod
adaptive_inflate_mod
mpi_utilities_mod
smoother_mod
</PRE>

<!--==================================================================-->
<!-- Describe the Files Used by this module.                          -->
<!--==================================================================-->

<A NAME="FilesUsed"></A>
<HR>
<H2>FILES</H2>
<UL><LI>observation sequence input file; from obs_sequence_in_name</LI>
    <LI>output state space prior diagnostics file; Prior_Diag.nc</LI>
    <LI>output state space posterior diagnostics file; Posterior_Diag.nc</LI>
    <LI>output observation space diagnostic file; from obs_sequence_out_name</LI>
    <LI>filter.nml in input.nml</LI>
</UL>

<!--==================================================================-->
<!-- Cite references, if need be.                                     -->
<!--==================================================================-->

<A NAME="References"></A>
<HR>
<H2>REFERENCES</H2>
<ul>
<li>Anderson, J. L., 2001: 
An Ensemble Adjustment Kalman Filter for Data Assimilation.
<span style="font-style: italic;">Mon. Wea. Rev.</span>,
<span style="font-weight: bold;">129</span>, 2884-2903.<br />
<a href="http://dx.doi.org/10.1175/1520-0493%282001%29129%3C2884%3AAEAKFF%3E2.0.CO%3B2"
target="_blank" >
doi: 10.1175/1520-0493(2001)129&lt;2884:AEAKFF&gt;2.0.CO;2</a> 
<br />
</li>
<li>Anderson, J. L., 2003:
A Local Least Squares Framework for Ensemble Filtering.
<span style="font-style: italic;">Mon. Wea. Rev.</span>,
<span style="font-weight: bold;">131</span>, 634-642.<br />
<a href="http://dx.doi.org/10.1175/1520-0493%282003%29131%3C0634%3AALLSFF%3E2.0.CO%3B2"
target="_blank" >
doi: 10.1175/1520-0493(2003)131&lt;0634:ALLSFF&gt;2.0.CO;2</a>
<br />
</li>
<li>Anderson, J. L., 2007: 
An adaptive covariance inflation error correction algorithm for ensemble filters.
<span style="font-style: italic;">Tellus A</span>,
<span style="font-weight: bold;">59</span>, 210-224.<br />
<a href="http://dx.doi.org/10.1111/j.1600-0870.2006.00216.x"
target="_blank" >
doi: 10.1111/j.1600-0870.2006.00216.x </a>
<br />
</li>
<li>Anderson, J. L., 2007:
Exploring the need for localization in ensemble data 
assimilation using a hierarchical ensemble filter.
<span style="font-style: italic;">Physica D</span>,
<span style="font-weight: bold;">230</span>, 99-111.<br />
<a href="http://dx.doi.org/10.1016/j.physd.2006.02.011"
target="_blank" >
doi:10.1016/j.physd.2006.02.011</a>
<br />
</li>
<li>Anderson, J., Collins, N., 2007:
Scalable Implementations of Ensemble Filter Algorithms for Data Assimilation.
<span style="font-style: italic;">Journal of Atmospheric and Oceanic Technology</span>, 
<span style="font-weight: bold;">24</span>, 1452-1463.<br />
<a href="http://dx.doi.org/10.1175/JTECH2049.1"
target="_blank" >
doi: 10.1175/JTECH2049.1</a>
<br />
</li>
<li>Anderson, J. L., 2009: 
Spatially and temporally varying adaptive covariance inflation for ensemble filters.
<span style="font-style: italic;">Tellus A</span>,
<span style="font-weight: bold;">61</span>, 72-83.<br />
<a href="http://dx.doi.org/10.1111/j.1600-0870.2008.00361.x"
target="_blank" >
doi: 10.1111/j.1600-0870.2008.00361.x</a>
<br />
</li>
<li>Anderson, J., T. Hoar, K. Raeder, H. Liu,
N. Collins, R. Torn, and  A. Arellano, 2009:
The Data Assimilation Research Testbed: A Community Facility.
<span style="font-style: italic;">Bull. Amer. Meteor. Soc.</span>,
<span style="font-weight: bold;">90</span>, 1283-1296.<br />
<a href="http://dx.doi.org/10.1175/2009BAMS2618.1"
target="_blank" >
doi: 10.1175/2009BAMS2618.1</a>
<br />
</li>
<li>Anderson, J. L., 2010:
A Non-Gaussian Ensemble Filter Update for Data Assimilation.
<span style="font-style: italic;">Mon. Wea. Rev.</span>,
<span style="font-weight: bold;">139</span>, 4186-4198.<br />
<a href="http://dx.doi.org/10.1175/2010MWR3253.1"
target="_blank" >
doi: 10.1175/2010MWR3253.1</a>
<br />
</li>
<li>Anderson, J. L., 2011:
Localization and Sampling Error Correction
in Ensemble Kalman Filter Data Assimilation. 
Submitted for publication, Jan 2011.  
Contact author.</li>

</ul>
<br />

<!--==================================================================-->
<!-- Describe all the error conditions and codes.                     -->
<!--==================================================================-->

<A NAME="Errors"></A>
<HR>
<H2>ERROR CODES and CONDITIONS</H2>
<div class=errors>
<TABLE border=1 cellspacing=1 cellpadding=10 width=100%>
<TR><TH>Routine</TH><TH>Message</TH><TH>Comment</TH></TR>

<TR><!-- routine --><TD VALIGN=top>filter_main</TD>
    <!-- message --><TD VALIGN=top>ens_size in namelist is ###: Must be &gt; 1</TD>
    <!-- comment --><TD VALIGN=top>Ensemble size must be at least 2. </TD></TR>

<TR><!-- routine --><TD VALIGN=top>filter_main</TD>
    <!-- message --><TD VALIGN=top>inf_flavor= ### Must be 0, 1, 2, 3.</TD>
    <!-- comment --><TD VALIGN=top>Only inflation options 0 to 3 are supported. </TD></TR>

<TR><!-- routine --><TD VALIGN=top>filter_main</TD>
    <!-- message --><TD VALIGN=top>Posterior observation space inflation (type 1) not supported.</TD>
    <!-- comment --><TD VALIGN=top>Posterior observation space inflation doesn't work. </TD></TR>

<TR><!-- routine --><TD VALIGN=top>filter_main</TD>
    <!-- message --><TD VALIGN=top>Number of processes &gt; model size.</TD>
    <!-- comment --><TD VALIGN=top>Number of processes can't exceed model size for now. </TD></TR>

<TR><!-- routine --><TD VALIGN=top>filter_generate_copy_meta_data</TD>
    <!-- message --><TD VALIGN=top>output metadata in filter needs state ensemble size &lt; 10000, not ###.</TD>
    <!-- comment --><TD VALIGN=top>Only up to 10000 ensemble members with state output for now. </TD></TR>

<TR><!-- routine --><TD VALIGN=top>filter_generate_copy_meta_data</TD>
    <!-- message --><TD VALIGN=top>output metadata in filter needs obs ensemble size &lt; 10000, not ###.</TD>
    <!-- comment --><TD VALIGN=top>Only up to 10000 ensemble members with obs space output for now. </TD></TR>

<TR><!-- routine --><TD VALIGN=top>filter_setup_obs_sequence</TD>
    <!-- message --><TD VALIGN=top>input obs_seq file has ### qc fields; must be &lt; 2.</TD>
    <!-- comment --><TD VALIGN=top>Only 0 or 1 qc fields in input obs sequence for now. </TD></TR>

<TR><!-- routine --><TD VALIGN=top>get_obs_copy_index</TD>
    <!-- message --><TD VALIGN=top>Did not find observation copy with metadata observation.</TD>
    <!-- comment --><TD VALIGN=top>Only 0 or 1 qc fields in input obs sequence for now. </TD></TR>

</TABLE>
</div>

<H2>KNOWN BUGS</H2>
<P>
none
</P>

<!--==================================================================-->
<!-- Describe Future Plans.                                           -->
<!--==================================================================-->

<A NAME="FuturePlans"></A>
<HR>
<H2>FUTURE PLANS</H2>
<P>
Further development to better support observations that can only be
computed once is needed.
</P>

<!--==================================================================-->
<!-- Legalese & Metadata                                              -->
<!--==================================================================-->

<A NAME="Legalese"></A>
<HR>
<H2>Terms of Use</H2>

<P>
DART software - Copyright 2004 - 2011 UCAR.<br />
This open source software is provided by UCAR, "as is",<br />
without charge, subject to all terms of use at<br />
<a href="http://www.image.ucar.edu/DAReS/DART/DART_download">
http://www.image.ucar.edu/DAReS/DART/DART_download</a>
</P>

<TABLE border=0 cellpadding=0 width=100% summary="">
<TR><TD valign=top>Contact: </TD><TD> DART core group   </TD></TR>
<TR><TD valign=top>Revision: </TD><TD> $Revision$ </TD></TR>
<TR><TD valign=top>Source: </TD><TD> $URL$ </TD></TR>
<TR><TD valign=top>Change Date: </TD><TD> $Date$ </TD></TR>
<TR><TD valign=top>Change History: </TD><TD> try "svn log" or "svn diff" </TD></TR>
</TABLE>

<!--==================================================================-->

</BODY>
</HTML>
