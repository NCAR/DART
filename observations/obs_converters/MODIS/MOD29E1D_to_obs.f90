! DART software - Copyright UCAR. This open source software is provided
! by UCAR, "as is", without charge, subject to all terms of use at
! http://www.image.ucar.edu/DAReS/DART/DART_download

program MOD29E1D_to_obs

!-----------------------------------------------------------------------
!> MOD29E1D_to_obs - reads a daily netCDF file of SEA ICE TEMPERATURE
!>                   observations and writes a DART obs_seq file.
!> 
!>          original - ?? ???? 2016 Yongfei Zhang, University of Washington
!>          modified - 2 April 2025 Molly Wieringa, NCAR/ASP
!> 
!> "The MODIS/Terra Sea Ice Extent and IST Daily L3 Global 4km EASE-Grid Day 
!>  (MOD29E1D) data set consists of sea ice extent and ice surface temperature (IST), 
!>  generated by remapping 1 km resolution data from MOD29P1D to a 4 km resolution
!>  Equal Area Scalable Earth (EASE) grid, for both the Northern and Southern 
!>  Hemispheres. The gridded input observation nearest the center of the output 
!>  grid cell is assigned to that grid cell. As such, approximately every fourth 
!>  input grid cell is mapped to the output grid. No QA data is provided."
!>
!> Please make sure you cite the data in accordance to the agreement:
!>
!> Hall, D. K. and G. Riggs. 2021. MODIS/Terra Sea Ice Extent and IST Daily L3 Global 
!> 4km EASE-Grid Day, Version 61. [Indicate subset used]. Boulder, Colorado USA. NASA 
!> National Snow and Ice Data Center Distributed Active Archive Center. 
!> https://doi.org/10.5067/MODIS/MOD29E1D.061. [Date Accessed].
!>
!> MOD29E1D data files are provided in HDF format via the following link:
!> https://nsidc.org/data/mod29e1d/versions/61#anchor-documentation. They
!> must be preprocessed to netCDF files before this converter can be used. 
!> An example conversion script titled MOD29E1D_hdf_to_netcdf.py has been 
!> provided in MODIS/shell_scripts
!> 
!> Currently this code only converts IST for the Northern Hemisphere (lat > 40.0)
!-----------------------------------------------------------------------

! Call from required modules
use            types_mod, only : r8
use        utilities_mod, only : initialize_utilities, finalize_utilities,   &
                                 find_namelist_in_file, check_namelist_read, &
                                 nmlfileunit, do_nml_file, do_nml_term,      &
                                 error_handler, E_MSG
use     time_manager_mod, only : time_type, set_calendar_type, set_date,     &
                                 set_time, get_time, GREGORIAN,              &
                                 operator(>=), operator(-), operator(+)
use     obs_sequence_mod, only : obs_sequence_type, obs_type,                &
                                 static_init_obs_sequence, init_obs,         &
                                 write_obs_seq, init_obs_sequence,           &
                                 get_num_obs, set_copy_meta_data,            &
                                 set_qc_meta_data
use    obs_utilities_mod, only : create_3d_obs, add_obs_to_seq, getdimlen
use         obs_kind_mod, only : SAT_SEAICE_AGREG_SURFACETEMP
use         location_mod, only : VERTISSURFACE

use netcdf
use netcdf_utilities_mod, only : nc_open_file_readonly, nc_close_file,       &
                                 nc_check

implicit none

character(len=*), parameter :: routine = 'MOD29E1D_to_obs'

! Namelist input with default values
integer  :: year  = 2000
integer  :: doy   = 1
real(r8) :: terr  = 3.0_r8
logical  :: debug = .false. ! set .true. to print info
character(len=256) ::  input_file = 'seaicedata.nc'
character(len=256) :: output_file = 'obs_seq.mod29e1d'

namelist /MOD29E1D_to_obs_nml/ year, doy, terr, input_file, output_file,    &
                               debug

! Variable definition
character(len=128) :: varname
character(len=512) :: string1
integer  :: i, j, oday, osec, iunit, io
integer  :: num_copies, num_qc, max_obs, ncid, varid
integer  :: axdim, aydim
real(r8) :: qc
logical  :: first_obs

real(r8), allocatable :: lat(:, :), lon(:, :)
real(r8), allocatable :: seaice_temperature(:, :)

type(obs_sequence_type) :: obs_seq
type(obs_type)          :: obs, prev_obs
type(time_type)         :: comp_day0, time_obs, prev_time

!-----------------------------------------------------------------------
! Begin executable code

call initialize_utilities(routine)

! time setup
call set_calendar_type(GREGORIAN)
comp_day0 = set_date(year, 1, 1, 0, 0, 0)
time_obs = comp_day0 + set_time(0, doy)
call get_time(time_obs, osec, oday)

! read namelist
call find_namelist_in_file('input.nml', 'MOD29E1D_to_obs_nml', iunit)
read(iunit, nml = MOD29E1D_to_obs_nml, iostat = io)
call check_namelist_read(iunit, io, 'MOD29E1D_to_obs_nml')

! record namlist values used for the run
if (do_nml_file()) write(nmlfileunit, nml = MOD29E1D_to_obs_nml)
if (do_nml_term()) write(    *      , nml = MOD29E1D_to_obs_nml)

! open the netcdf file to read input data
ncid = nc_open_file_readonly(input_file, routine)

call getdimlen(ncid, 'x', axdim)
call getdimlen(ncid, 'y', aydim)

! allocate arrays for lat/lon and sea ice temperature
allocate(               lat(axdim, aydim))
allocate(               lon(axdim, aydim))
allocate(seaice_temperature(axdim, aydim))

! set max_obs to 1 million
max_obs = axdim * aydim

! initialize an obs_seq file
num_copies = 1
num_qc     = 1
first_obs = .true.
call static_init_obs_sequence()
call init_obs(obs,      num_copies, num_qc)
call init_obs(prev_obs, num_copies, num_qc)

call  init_obs_sequence(obs_seq, num_copies, num_qc, max_obs)
call set_copy_meta_data(obs_seq, 1, 'observation')
call   set_qc_meta_data(obs_seq, 1,     'Data QC')

! collect the observation data
varname = 'tsfc'
io = nf90_inq_varid(ncid, varname, varid)
call nc_check(io, routine, 'nf90_inq_varid "'//trim(varname)//'"')
io = nf90_get_var(ncid, varid, seaice_temperature)
call nc_check(io, routine, 'nf90_get_var "'//trim(varname)//'"')

varname = 'lat'
io = nf90_inq_varid(ncid, varname, varid)
call nc_check(io, routine, 'nf90_inq_varid "'//trim(varname)//'"')
io = nf90_get_var(ncid, varid, lat)
call nc_check(io, routine, 'nf90_get_var "'//trim(varname)//'"')

varname = 'lon'
io = nf90_inq_varid(ncid, varname, varid)
call nc_check(io, routine, 'nf90_inq_varid "'//trim(varname)//'"')
io = nf90_get_var(ncid, varid, lon)
call nc_check(io, routine, 'nf90_get_var "'//trim(varname)//'"')

call nc_close_file(ncid, routine, 'data file')

! convert -180/180 lon to 0/360
where (lon < 0.00_r8) lon = lon + 360.0_r8

! since there is no QC data provided for the dataset, assume all obs are good
qc = 0.0_r8

! loop across observations to create 3d_obs, checking for valid locations
!   and suspicious observation values
alongloop : do j = 1, aydim
    acrossloop : do i = 1, axdim

    ! check lat/lon values
    if (lat(i, j) > 90.0_r8 .or. lat(i, j) <  40.0_r8) cycle acrossloop
    if (lon(i, j) <  0.0_r8 .or. lon(i, j) > 360.0_r8) cycle acrossloop

    ! check if temperature values are reasonable, based on state valid range of values
    if (seaice_temperature(i, j) == -800_r8) then
        cycle acrossloop
    else if (seaice_temperature(i, j) > 0.0_r8 .or. seaice_temperature(i, j) < -63.15_r8) then
        qc = 6.0_r8
    else
        qc = 0.0_r8
    end if

    ! create obs type and add to sequence
    call create_3d_obs(lat(i, j), lon(i, j), 0.0_r8, VERTISSURFACE, seaice_temperature(i, j), &
                       SAT_SEAICE_AGREG_SURFACETEMP, terr, oday, osec, qc, obs)
    call add_obs_to_seq(obs_seq, obs, time_obs, prev_obs, prev_time, first_obs)

    ! debug info
    if (debug) then
        write(string1, *) 'Added sea ice temperature obs to output sequence'
        call error_handler(E_MSG, routine, string1)
    endif

    end do acrossloop
end do alongloop

! if observations were added to the sequence, write an obs_seq file
if (get_num_obs(obs_seq) > 0) then
    write(string1, *) 'Writing observations: obs_count = ', get_num_obs(obs_seq)
    call error_handler(E_MSG, routine, string1)
    call write_obs_seq(obs_seq, output_file)
else
    call error_handler(E_MSG, routine, 'There are no observations to write out.')
endif

! wrap up program
deallocate(seaice_temperature, lat, lon)
call finalize_utilities()

end program MOD29E1D_to_obs







