<HTML>
<TITLE>module ensemble_manager_mod</TITLE>
<link rel=stylesheet type=text/css href=../doc/html/doc.css>
<BODY>
<!--
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!                                                                       !!
!!                   GNU General Public License                          !!
!!                                                                       !!
!! This file is part of the Data Assimilation Research Testbed (DART).   !!
!!                                                                       !!
!! DART is free software; you can redistribute it and/or modify          !!
!! it and are expected to follow the terms of the GNU General Public     !!
!! License as published by the Free Software Foundation.                 !!
!!                                                                       !!
!! DART is distributed in the hope that it will be useful,               !!
!! but WITHOUT ANY WARRANTY; without even the implied warranty of        !!
!! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         !!
!! GNU General Public License for more details.                          !!
!!                                                                       !!
!! You should have received a copy of the GNU General Public License     !!
!! along with DART; if not, write to:                                    !!
!!          Free Software Foundation, Inc.                               !!
!!          59 Temple Place, Suite 330                                   !!
!!          Boston, MA  02111-1307  USA                                  !!
!! or see:                                                               !!
!!          http://www.gnu.org/licenses/gpl.txt                          !!
!!                                                                       !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-->


<DIV ALIGN=CENTER>
<A HREF="#Interface">INTERFACE</A> / 
<A HREF="#PublicEntities">PUBLIC COMPONENTS</A> / 
<A HREF="#Namelist">NAMELIST</A> / 
<A HREF="#FilesUsed">FILES</A> /
<A HREF="#References">REFERENCES</A> /
<A HREF="#Errors">ERRORS</A> /
<A HREF="#KnownBugs">BUGS</A> /
<A HREF="#FuturePlans">PLANS</A> /
<A HREF="#PrivateComponents">PRIVATE COMPONENTS</A>
</DIV>

<!--==================================================================-->

<H1>MODULE ensemble_manager_mod</H1>
<A NAME="HEADER"></A>
<TABLE summary="">
   <TR><TD>Contact:       </TD><TD> Jeff Anderson                </TD></TR>
   <TR><TD>Reviewers:     </TD><TD> &nbsp;                       </TD></TR>
   <TR><TD>Revision:      </TD><TD> $Revision$             </TD></TR>
   <TR><TD>Release Name:  </TD><TD> $Name$                       </TD></TR>
   <TR><TD>Change Date:   </TD><TD> $Date$ </TD></TR>
   <TR><TD>Change history:</TD><TD> see CVS log                  </TD></TR>
</TABLE>

<!--==================================================================-->

<A NAME="OVERVIEW"></A>
<HR>
<H2>OVERVIEW</H2>

<P>
Manages storage and a number of operations for multiple copies of a vector.
The most obvious use is to manage ensembles of model state vectors. In this
case, the number of copies stored for each state vector element is the 
ensemble size plus one or more additional copies like the mean, variance,
associated inflation values, etc. The ensemble_manager provides routines
to compute the mean and variance of a subset of the copies, to track the
time associated with the copies, and to write and read restart files. Most
importantly, it provides a capability to do transposes between two
storage representations of an ensemble. In one representation, each process
stores all copies of a subset of the state variables while in the other,
each process stores all of the state variables for a subset of copies. The
ensemble manager is also used to manage ensembles of observation priors
and quality control and ensembles of forward observation operator error 
status.

</P>

<!--==================================================================-->

<A NAME="OTHER MODULES USED"></A>
<BR><HR><BR>
<H2>OTHER MODULES USED</H2>
<PRE>
types_mod
utilities_mod
assim_model_mod
time_manager_mod
random_seq_mod
mpi_utilities_mod
</PRE>

<!--==================================================================-->
<!--Note to authors. The first row of the table is different.         -->

<A NAME="Interface"></A>
<BR><HR><BR>
<H2>PUBLIC INTERFACE</H2>

<TABLE>
<TR><TD><em class=call>use ensemble_manager_mod, only : </em></TD>
                   <TD><A HREF="#ensemble_type">ensemble_type</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#init_ensemble_manager">init_ensemble_manager</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#end_ensemble_manager">end_ensemble_manager</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_ensemble_time">get_ensemble_time</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#duplicate_ens">duplicate_ens</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_var_owner_index">get_var_owner_index</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_my_num_copies">get_my_num_copies</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_my_copies">get_my_copies</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_my_num_vars">get_my_num_vars</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_my_vars">get_my_vars</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#compute_copy_mean">compute_copy_mean</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#compute_copy_mean_sd">compute_copy_mean_sd</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#compute_copy_mean_var">compute_copy_mean_var</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_copy">get_copy</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#put_copy">put_copy</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#all_vars_to_all_copies">all_vars_to_all_copies</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#all_copies_to_all_vars">all_copies_to_all_vars</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#read_ensemble_restart">read_ensemble_restart</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#write_ensemble_restart">write_ensemble_restart</A></TD></TR>
</TABLE>

<H3 class=indent1>NOTES</H3>

<P>
Optional namelist interface <em class=code>&#38;ensemble_manager_nml</em> 
may be read from file <em class=file>input.nml</em>.
</P>

<!--==================================================================-->
<!-- Declare all public entities ...                                  -->
<!-- duplicate public routines template as many times as necessary    -->
<!-- make sure you replace all yyyroutine?? strings                   -->
<!--==================================================================-->

<A NAME="PublicEntities"></A>
<BR><HR><BR>
<H2>PUBLIC COMPONENTS</H2>
<P>
</P>

<!--==================================================================-->
<!--=================== DESCRIPTION OF A LOCAL TYPE ==================-->

<!--kdr no private in code -->
<A NAME="ensemble_type"></A>
<BR><HR><BR>
<div class=type><pre>
<em class=call>type ensemble_type</em>
   !!! private
   integer :: num_copies
   integer :: num_vars
   integer :: my_num_copies
   integer :: my_num_vars
   integer, pointer :: my_copies(:)
   integer, pointer :: my_vars(:)
   real(r8), pointer :: copies(:, :)
   real(r8), pointer :: vars(:, :)
   type(time_type), pointer :: time(:)
   integer :: distribution_type
end type ensemble_type
</pre></div>

<H3 class=indent1>Description</H3>

<P>
Provides a handle for an ensemble that manages copies of a vector. For efficiency,
the type internals are not private and direct access to the storage arrays is
used throughout DART. 
</P>

<TABLE border=0 cellpadding=3 width=100%>
<TR><TH align=left>Component      </TH>
    <TH align=left>Description    </TH></TR>
<TR><TD valign=top> num_copies </TD>
    <TD> Global number of copies of the vector.  </TD></TR>
<TR><TD valign=top> num_vars </TD>
    <TD> Global number of elements (variables) in the vector.  </TD></TR>
<TR><TD valign=top> my_num_copies </TD>
    <TD> Number of copies stored by this process.  </TD></TR>
<TR><TD valign=top> my_num_vars </TD>
    <TD> Number of variables stored by this process.  </TD></TR>
<TR><TD valign=top> my_copies </TD>
    <TD> Dimensioned to size my_num_copies. Contains a list of the global
         indices of copies stored by this process.  </TD></TR>
<TR><TD valign=top> my_vars </TD>
    <TD> Dimensioned to size my_num_vars. Contains a list of the global
         indices of variables stored by this process.  </TD></TR>
<TR><TD valign=top> copies </TD>
    <TD> Dimensioned (num_copies, my_num_vars). Storage for all copies
         of variables stored by this process.  </TD></TR>
<TR><TD valign=top> vars </TD>
    <TD> Dimensioned (num_vars, my_num_copies). Storage for all variables
         of copies stored by this process.  </TD></TR>
<TR><TD valign=top> time </TD>
    <TD> Dimensioned my_num_copies. A time_type that stores time associated
         with a given copy of the vector.  </TD></TR>
<TR><TD valign=top> distribution_type </TD>
    <TD>Does nothing at present. Can be used for future releases to control
         the layout of different copies and variables in storage.  </TD></TR>
</TABLE>

<!--=================================================================-->

 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="init_ensemble_manager"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call init_ensemble_manager(ens_handle,num_copies,num_vars,distr
 ibution_type_in) </em>
 <pre>
 type(ensemble_type), intent(out) :: <em class=code>ens_handle</em>
 integer, intent(in)              :: <em class=code>num_copies</em>
 integer, intent(in)              :: <em class=code>num_vars</em>
 integer, optional, intent(in)    :: <em class=code>distribution_type_in</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
 Initializes an instance of an ensemble. Storage is allocated and the
size descriptions in the ensemble_type are initialized.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>ens_handle&nbsp; &nbsp; </em></TD>
     <TD>Handle for the ensemble being initialized</TD></TR>
 <TR><TD valign=top><em class=code>num_copies&nbsp; &nbsp; </em></TD>
     <TD>Number of copies of vector.</TD></TR>
 <TR><TD valign=top><em class=code>num_vars&nbsp; &nbsp; </em></TD>
     <TD>Number of variables in the vector.</TD></TR>
 <TR><TD valign=top><em class=code>distribution_type_in&nbsp; &nbsp; </em></TD>
     <TD>Controls layout of storage on pe's. Currently only option 1 is supported.</TD></TR>
 </TABLE>
 <P>
 <!--================================================================-->

 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="get_var_owner_index"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call get_var_owner_index(var_number,owner,owners_index) </em>
 <pre>
 integer, intent(in)  :: <em class=code>var_number</em>
 integer, intent(out) :: <em class=code>owner</em>
 integer, intent(out) :: <em class=code>owners_index</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
 Given the global index of a variable in the vector, returns the process that
stores this variable when all copies of a subset of variables are stored and
the local storage index for this variable on that process.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>var_number&nbsp; &nbsp; </em></TD>
     <TD>Global index of a variable in the vector from an ensemble.</TD></TR>
 <TR><TD valign=top><em class=code>owner&nbsp; &nbsp; </em></TD>
     <TD>Process (0 to num_processes) that stores this variable when each has all 
          copies of subset of variables.</TD></TR>
 <TR><TD valign=top><em class=code>owners_index&nbsp; &nbsp; </em></TD>
     <TD>Local storage index for this variable on the owning process.</TD></TR>
 </TABLE>
 <P>
 <!--================================================================-->


 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="duplicate_ens"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call duplicate_ens(ens1,ens2,duplicate_time) </em>
 <pre>
 type(ensemble_type), intent(in)    :: <em class=code>ens1</em>
 type(ensemble_type), intent(inout) :: <em class=code>ens2</em>
 logical, intent(in)                :: <em class=code>duplicate_time</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
 Copies the contents of ens1 into ens2. If the num_copies and num_vars are
not consistent or if the distribution_type is not consistent, fails with an
error. If duplicate_time is true, the times from ens1 are copied over the
times of ens2.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>ens1&nbsp; &nbsp; </em></TD>
     <TD>Ensemble handle of ensemble to be copies into ens2.</TD></TR>
 <TR><TD valign=top><em class=code>ens2&nbsp; &nbsp; </em></TD>
     <TD>Ensemble handle of ensemble into which ens1 is copied.</TD></TR>
 <TR><TD valign=top><em class=code>duplicate_time&nbsp; &nbsp; </em></TD>
     <TD>If true, copy the times from ens1 into ens2, else leave ens2 times unchanged.</TD></TR>
 </TABLE>
 <P>
 <!--================================================================-->

 <!--============= DESCRIPTION OF A FUNCTION ========================-->
 <A NAME="get_my_num_copies"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> var = get_my_num_copies(ens_handle) </em>
 <pre>
 integer, intent(out)            :: <em class=code>get_my_num_copies</em>
 type(ensemble_type), intent(in) :: <em class=code>ens_handle</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
 Returns number of copies stored by this process when storing all
variables for a subset of copies.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>get_my_num_copies&nbsp; &nbsp; </em></TD>
     <TD>Returns the number of copies stored by this process when storing all 
         variables for a subset of copies. </TD></TR>
 <TR><TD valign=top><em class=code>ens_handle&nbsp; &nbsp; </em></TD>
     <TD>Handle for an ensemble.</TD></TR>
 </TABLE>
 <P>
 <!--================================================================-->

 <!--============= DESCRIPTION OF A FUNCTION ========================-->
 <A NAME="get_my_num_vars"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> var = get_my_num_vars(ens_handle) </em>
 <pre>
 integer, intent(out)            :: <em class=code>get_my_num_vars</em>
 type(ensemble_type), intent(in) :: <em class=code>ens_handle</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
 Returns number of variables stored by this process when storing all
copies of a subset of variables.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>get_my_num_vars&nbsp; &nbsp; </em></TD>
     <TD>Returns the number of vars stored by this process when storing all 
 copies of a subset of variables. </TD></TR>
 <TR><TD valign=top><em class=code>ens_handle&nbsp; &nbsp; </em></TD>
     <TD>Handle for an ensemble.</TD></TR>
 </TABLE>
 <P>
 <!--================================================================-->


 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="get_my_copies"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call get_my_copies(ens_handle,copies) </em>
 <pre>
 type(ensemble_type), intent(in) :: <em class=code>ens_handle</em>
 integer, intent(out)            :: <em class=code>copies</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Returns a list of all copies stored on this process when storing subset of copies
of all variables.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>ens_handle&nbsp; &nbsp; </em></TD>
     <TD>Handle for an ensemble.</TD></TR>
 <TR><TD valign=top><em class=code>copies&nbsp; &nbsp; </em></TD>
     <TD>List of all copies stored by this process when storing subset of copies
  of all variables.</TD></TR>
 </TABLE>
 <P>
 <!--================================================================-->

 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="get_my_vars"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call get_my_vars(ens_handle,copies) </em>
 <pre>
 type(ensemble_type), intent(in) :: <em class=code>ens_handle</em>
 integer, intent(out)            :: <em class=code>vars</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Returns a list of all variables stored on this process when storing all copies
of a subset of variables.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>ens_handle&nbsp; &nbsp; </em></TD>
     <TD>Handle for an ensemble.</TD></TR>
 <TR><TD valign=top><em class=code>vars&nbsp; &nbsp; </em></TD>
     <TD>List of all variables stored on this process when storing all copies
  of a subset of variables.</TD></TR>
 </TABLE>
 <P>
 <!--================================================================-->


 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="compute_copy_mean"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call compute_copy_mean(ens_handle,start_copy,end_copy,mean_copy,sd_copy) </em>
 <pre>
 type(ensemble_type), intent(inout) :: <em class=code>ens_handle</em>
 integer, intent(in)                :: <em class=code>start_copy</em>
 integer, intent(in)                :: <em class=code>end_copy</em>
 integer, intent(in)                :: <em class=code>mean_copy</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
 Computes the mean of a contiguous subset of copies
starting with global index start_copy and ending with global index ens_copy.
Mean is written to mean_copy.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>ens_handle&nbsp; &nbsp; </em></TD>
     <TD>Handle for an ensemble.</TD></TR>
 <TR><TD valign=top><em class=code>start_copy&nbsp; &nbsp; </em></TD>
     <TD>Global index of first copy in mean and sd computation.</TD></TR>
 <TR><TD valign=top><em class=code>end_copy&nbsp; &nbsp; </em></TD>
     <TD>Global index of last copy in mean and sd computation.</TD></TR>
 <TR><TD valign=top><em class=code>mean_copy&nbsp; &nbsp; </em></TD>
     <TD>Global index of copy into which mean is written.</TD></TR>
 </TABLE>
 <P>
 <!--================================================================-->

 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="compute_copy_mean_sd"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call compute_copy_mean_sd(ens_handle,start_copy,end_copy,mean_copy,sd_copy) </em>
 <pre>
 type(ensemble_type), intent(inout) :: <em class=code>ens_handle</em>
 integer, intent(in)                :: <em class=code>start_copy</em>
 integer, intent(in)                :: <em class=code>end_copy</em>
 integer, intent(in)                :: <em class=code>mean_copy</em>
 integer, intent(in)                :: <em class=code>sd_copy</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
 Computes the mean and standard deviation of a contiguous subset of copies
starting with global index start_copy and ending with global index ens_copy.
Mean is written to mean_copy and standard deviation to sd_copy.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>ens_handle&nbsp; &nbsp; </em></TD>
     <TD>Handle for an ensemble.</TD></TR>
 <TR><TD valign=top><em class=code>start_copy&nbsp; &nbsp; </em></TD>
     <TD>Global index of first copy in mean and sd computation.</TD></TR>
 <TR><TD valign=top><em class=code>end_copy&nbsp; &nbsp; </em></TD>
     <TD>Global index of last copy in mean and sd computation.</TD></TR>
 <TR><TD valign=top><em class=code>mean_copy&nbsp; &nbsp; </em></TD>
     <TD>Global index of copy into which mean is written.</TD></TR>
 <TR><TD valign=top><em class=code>sd_copy&nbsp; &nbsp; </em></TD>
     <TD>Global index of copy into which standard deviation is written.</TD></TR>
 </TABLE>
 <P>
 <!--================================================================-->

 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="compute_copy_mean_var"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call compute_copy_mean_var(ens_handle,start_copy,end_copy,mean_copy,sd_copy) </em>
 <pre>
 type(ensemble_type), intent(inout) :: <em class=code>ens_handle</em>
 integer, intent(in)                :: <em class=code>start_copy</em>
 integer, intent(in)                :: <em class=code>end_copy</em>
 integer, intent(in)                :: <em class=code>mean_copy</em>
 integer, intent(in)                :: <em class=code>var_copy</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
 Computes the mean and variance of a contiguous subset of copies
starting with global index start_copy and ending with global index ens_copy.
Mean is written to mean_copy and variance to var_copy.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>ens_handle&nbsp; &nbsp; </em></TD>
     <TD>Handle for an ensemble.</TD></TR>
 <TR><TD valign=top><em class=code>start_copy&nbsp; &nbsp; </em></TD>
     <TD>Global index of first copy in mean and sd computation.</TD></TR>
 <TR><TD valign=top><em class=code>end_copy&nbsp; &nbsp; </em></TD>
     <TD>Global index of last copy in mean and sd computation.</TD></TR>
 <TR><TD valign=top><em class=code>mean_copy&nbsp; &nbsp; </em></TD>
     <TD>Global index of copy into which mean is written.</TD></TR>
 <TR><TD valign=top><em class=code>var_copy&nbsp; &nbsp; </em></TD>
     <TD>Global index of copy into which variance is written.</TD></TR>
 </TABLE>
 <P>
 <!--================================================================-->


 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="get_copy"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call get_copy(receiving_pe,ens_handle,copy,vars,mtime) </em>
 <pre>
 integer, intent(in)                    :: <em class=code>receiving_pe</em>
 type(ensemble_type), intent(in)        :: <em class=code>ens_handle</em>
 integer, intent(in)                    :: <em class=code>copy</em>
 real(r8), dimension(:), intent(out)    :: <em class=code>vars</em>
 type(time_type), optional, intent(out) :: <em class=code>mtime</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Retreives a copy of the state vector, indexed by the global index copy. The
process that is to receive the copy is receiving_pe and the copy is returned
in the one dimensional array vars. The time of the copy is also returned if
mtime is present. This is generally used for operations, like IO, that require
a single processor to do things with the entire state vector.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>receiving_pe&nbsp; &nbsp; </em></TD>
     <TD>This process ends up with the requested copy of the state vector.</TD></TR>
 <TR><TD valign=top><em class=code>ens_handle&nbsp; &nbsp; </em></TD>
     <TD>Handle for ensemble.</TD></TR>
 <TR><TD valign=top><em class=code>copy&nbsp; &nbsp; </em></TD>
     <TD>The global index of the copy of the state vector that is to be retreived.</TD></TR>
 <TR><TD valign=top><em class=code>vars&nbsp; &nbsp; </em></TD>
     <TD>One dimensional array in which the requested copy of the state vector 
          is returned.</TD></TR>
 <TR><TD valign=top><em class=code>mtime&nbsp; &nbsp; </em></TD>
     <TD>If present returns the time of the requested copy.</TD></TR>
 </TABLE>
 <P>
 <!--================================================================-->

 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="put_copy"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call put_copy(sending_pe,ens_handle,copy,vars,mtime) </em>
 <pre>
 integer, intent(in)                    :: <em class=code>sending_pe</em>
 type(ensemble_type), intent(inout)     :: <em class=code>ens_handle</em>
 integer, intent(in)                    :: <em class=code>copy</em>
 real(r8), dimension(:), intent(in)     :: <em class=code>vars</em>
 type(time_type), optional, intent(in)  :: <em class=code>mtime</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Sends a copy of the state vector, indexed by the global index copy, from
a given process to the process that stores it. The
process that is to send the copy is sending_pe which places the copy in the
one dimensional array vars. The time of the copy is also sent if
mtime is present. This is generally used for operations, like IO, that require
a single processor to do things with the entire state vector. For instance,
if a single process reads in a state vector, it can be shipped to the storing
process by this subroutine.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>sending_pe&nbsp; &nbsp; </em></TD>
     <TD>This process sends the copy of the state vector.</TD></TR>
 <TR><TD valign=top><em class=code>ens_handle&nbsp; &nbsp; </em></TD>
     <TD>Handle for ensemble.</TD></TR>
 <TR><TD valign=top><em class=code>copy&nbsp; &nbsp; </em></TD>
     <TD>The global index of the copy of the state vector that is to be sent. 
 </TD></TR>
 <TR><TD valign=top><em class=code>vars&nbsp; &nbsp; </em></TD>
     <TD>One dimensional array in which the requested copy of the state vector 
         is placed.</TD></TR>
 <TR><TD valign=top><em class=code>mtime&nbsp; &nbsp; </em></TD>
     <TD>If present send the time of the copy.</TD></TR>
 </TABLE>
 <P>
 <!--================================================================-->


 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="all_vars_to_all_copies"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call all_vars_to_all_copies(ens_handle) </em>
 <pre>
 type(ensemble_type), intent(inout) :: <em class=code>ens_handle</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Transposes data from a representation in which each processor has a subset of
copies of all variables to one in which each has all copies of a subset of
variables. In the current implementation, storage is not released so both
representations are always available. However, one representation may be
current while the other is out of date.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>ens_handle&nbsp; &nbsp; </em></TD>
     <TD>The handle of the ensemble being transposed.</TD></TR>
 </TABLE>
 <P>
 <!--================================================================-->

 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="all_copies_to_all_vars"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call all_copies_to_all_vars(ens_handle) </em>
 <pre>
 type(ensemble_type), intent(inout) :: <em class=code>ens_handle</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Transposes data from a representation in which each processor has all copies
of a subset of variables to one in which each has a subset of copies
of all variables. In the current implementation, storage is not released so both
representations are always available. However, one representation may be
current while the other is out of date.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>ens_handle&nbsp; &nbsp; </em></TD>
     <TD>The handle of the ensemble being transposed.</TD></TR>
 </TABLE>
 <P>
 <!--================================================================-->

 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="read_ensemble_restart"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call read_ensemble_restart(ens_handle,start_copy,end_copy,start
 _from_restart,file_name,init_time,force_single_file) </em>
 <pre>
 type(ensemble_type), intent(inout)    :: <em class=code>ens_handle</em>
 integer, intent(in)                   :: <em class=code>start_copy</em>
 integer, intent(in)                   :: <em class=code>end_copy</em>
 logical, intent(in)                   :: <em class=code>start_from_restart</em>
 character(len=*), intent(in)          :: <em class=code>file_name</em>
 type(time_type), optional, intent(in) :: <em class=code>init_time</em>
 logical, optional, intent(in)         :: <em class=code>force_single_file</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Read in a set of copies of a vector from file file_name. The copies read are
place into global copies start_copy:end_copy in the ens_handle. All reads are
done by process 0 in the current version and then shipped to the pe that
stores the copies when each process stores all variables of a subset of copies.
If start_from_restart is false, then only a single copy of the vector is
read from the file and then it is perturbed using routines in assim_model_mod
to generate the required number of copies. The read can be from a single file
that contains all needed copies or from a different file for each copy. This
choice is controlled by the namelist entry single_restart_file_in. However, the
optional argument force_single_file forces the read to be from a single file
if it is present and true. This is used for ensembles that contain the
inflation values for state space inflation. If multiple files are to be read,
the file names are generated by appending integers to the input file_name.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>ens_handle&nbsp; &nbsp; </em></TD>
     <TD>Handle of ensemble.</TD></TR>
 <TR><TD valign=top><em class=code>start_copy&nbsp; &nbsp; </em></TD>
     <TD>Global index of first of continguous set of copies to be read.</TD></TR>
 <TR><TD valign=top><em class=code>end_copy&nbsp; &nbsp; </em></TD>
     <TD>Global index of last of contiguous set of copies to be read, 
        copies(start_copy:end_copy).</TD></TR>
 <TR><TD valign=top><em class=code>start_from_restart&nbsp; &nbsp; </em></TD>
     <TD>If true, read all copies from file. If false, read one copy and perturb
  to get required number.</TD></TR>
 <TR><TD valign=top><em class=code>file_name&nbsp; &nbsp; </em></TD>
     <TD>Name of file from which to read.</TD></TR>
 <TR><TD valign=top><em class=code>init_time&nbsp; &nbsp; </em></TD>
     <TD>If present, set time of all copies read to this value.</TD></TR>
 <TR><TD valign=top><em class=code>force_single_file&nbsp; &nbsp; </em></TD>
     <TD>If present and true, force the read to be from a single file which 
       contains all copies.</TD></TR>
 </TABLE>
 <P>
 <!--================================================================-->


 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="write_ensemble_restart"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call write_ensemble_restart(ens_handle,file_name,start_copy,end_copy,
force_single_file) </em>
 <pre>
 type(ensemble_type), intent(inout)    :: <em class=code>ens_handle</em>
 character(len=*), intent(in)          :: <em class=code>file_name</em>
 integer, intent(in)                   :: <em class=code>start_copy</em>
 integer, intent(in)                   :: <em class=code>end_copy</em>
 logical, optional, intent(in)         :: <em class=code>force_single_file</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Writes a set of copies of a vector to file file_name. The copies written are
from global copies start_copy:end_copy in the ens_handle. 
The write can be to a single file or to a different file for each copy. This
choice is controlled by the namelist entry single_restart_file_out. However, the
optional argument force_single_file forces the write to be to a single file
if it is present and true. This is used for ensembles that contain the
inflation values for state space inflation. If multiple files are to be written,
the file names are generated by appending integers to the input file_name.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>ens_handle&nbsp; &nbsp; </em></TD>
     <TD>Handle of ensemble.</TD></TR>
 <TR><TD valign=top><em class=code>file_name&nbsp; &nbsp; </em></TD>
     <TD>Name of file from which to read.</TD></TR>
 <TR><TD valign=top><em class=code>start_copy&nbsp; &nbsp; </em></TD>
     <TD>Global index of first of continguous set of copies to be written.</TD></TR>
 <TR><TD valign=top><em class=code>end_copy&nbsp; &nbsp; </em></TD>
     <TD>Global index of last of contiguous set of copies to be written, 
           copies(start_copy:end_copy).</TD></TR>
 <TR><TD valign=top><em class=code>force_single_file&nbsp; &nbsp; </em></TD>
     <TD>If present and true, force the write to be to a single file which 
      contains all copies.</TD></TR>
 </TABLE>
 <P>
 <!--================================================================-->


 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
<A NAME="end_ensemble_manager"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call end_ensemble_manager(ens_handle) </em>
 <pre>
 type(ensemble_type), intent(in)          :: <em class=code>ens_handle</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Frees up storage associated with an ensemble.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>ens_handle&nbsp; &nbsp; </em></TD>
     <TD>Identifies ensemble</TD></TR>
 </TABLE>
 <BR>

 <!--================================================================-->


 <!--============== DESCRIPTION OF A NAMELIST ========================-->
 <A NAME="Namelist"></A>
 <BR><HR><BR>
 <P>We adhere to the F90 standard of starting a namelist with an ampersand
 '&' and terminating with a slash '/'.
 <div class=namelist><pre>
 <em class=call>namelist / ensemble_manager_nml / </em>
 single_restart_file_in,single_restart_file_out,perturbation_amplitude



 </pre></div>
 <H3 class=indent1>Discussion</H3>
 <P>

 </em>
 </P>
 <P>This namelist is read in a file called <em class=file>input.nml</em>
 </P>
 <TABLE border=0 cellpadding=3 width=100%>
 <TR><TH align=left>Contents    </TH>
     <TH align=left>Type        </TH>
     <TH align=left>Description </TH></TR>
 <TR><!--contents--><TD valign=top>single_restart_file_in</TD>
     <!--  type  --><TD>logical</TD>
 <!--descript--><TD>True if all copies read from a single file. False for one 
    file per copy. Default: .true.</TD></TR>
 <TR><!--contents--><TD valign=top>single_restart_file_out</TD>
     <!--  type  --><TD>logical</TD>
 <!--descript--><TD>True if all copies written to a single file. False for one
      file per copy. Default: .true.</TD></TR>
 <TR><!--contents--><TD valign=top>perturbation_amplitude</TD>
     <!--  type  --><TD>real(r8)</TD>
 <!--descript--><TD>Perturbation standard deviation for generating ensemble 
    members if assim_model_mod will not do it. Default: 0.2_r8</TD></TR>
 </TABLE>
 <P>
 <!--================================================================-->


<!--==================================================================-->
<!-- Describe the Files Used by this module.                          -->
<!--==================================================================-->

<A NAME="FilesUsed"></A>
<BR><HR><BR>
<H2>FILES</H2>
<UL><LI>input.nml
    <LI>State vector restart files, either one for all copies or one per copy.
    <LI>State vector output files, either one for all copies or one per copy.
</UL>

<!--==================================================================-->
<!-- Cite references, if need be.                                     -->
<!--==================================================================-->

<A NAME="References"></A>
<BR><HR><BR>
<H2>REFERENCES</H2>

<!--==================================================================-->
<!-- Describe all the error conditions and codes.                     -->
<!-- Putting a <BR> after the synopsis creates a nice effect.         -->
<!--==================================================================-->

<A NAME="Errors"></A>
<HR>
<H2>ERROR CODES and CONDITIONS</H2>
<div class="errors">
<TABLE border=1 cellspacing=1 cellpadding=10 width=100%>
<TR><TH>Routine</TH><TH>Message</TH><TH>Comment</TH></TR>

<TR><!-- routine --><TD VALIGN=top>init_ensemble_manager</TD>
    <!-- message --><TD VALIGN=top>only distribution type 1 is implemented</TD>
    <!-- comment --><TD VALIGN=top>For now, can't request option other than 1 for layout</TD>
</TR>
<TR><!-- routine --><TD VALIGN=top>read_ensemble_restart</TD>
    <!-- message --><TD VALIGN=top>start_from_restart in filter_nml and 
        single_restart_file_in in ensemble_manager_nml cannot both be false</TD>
    <!-- comment --><TD VALIGN=top>Doesn't make sense to specify both of these options.</TD>
</TR>
<TR><!-- routine --><TD VALIGN=top>get_copy</TD>
    <!-- message --><TD VALIGN=top>Requested copy is > maximum_copy</TD>
    <!-- comment --><TD VALIGN=top>Can't ask for a copy that is greater than the maximum.</TD>
</TR>
<TR><!-- routine --><TD VALIGN=top>get_copy</TD>
    <!-- message --><TD VALIGN=top>Size of vars ### Must be at least ###</TD>
    <!-- comment --><TD VALIGN=top>The vars array is not big enough to hold the returned
                copy of the vector.</TD>
</TR>
<TR><!-- routine --><TD VALIGN=top>put_copy</TD>
    <!-- message --><TD VALIGN=top>Requested copy: ### is > maximum_copy: ###</TD>
    <!-- comment --><TD VALIGN=top>Can't ask for a copy that is greater than maximum.</TD>
</TR>
<TR><!-- routine --><TD VALIGN=top>put_copy</TD>
    <!-- message --><TD VALIGN=top>Size of vars: ### Must be at least ###</TD>
    <!-- comment --><TD VALIGN=top>The vars array is not big enough to hold the state vector.</TD>
</TR>
<TR><!-- routine --><TD VALIGN=top>get_ensemble_time</TD>
    <!-- message --><TD VALIGN=top>indx ### cannot exceed ###</TD>
    <!-- comment --><TD VALIGN=top>The index of the requested copy must
       be no greater than the maximum number of copies. </TD>
</TR>
<TR><!-- routine --><TD VALIGN=top>duplicate_ens</TD>
    <!-- message --><TD VALIGN=top>num_copies ### and ### must be equal</TD>
    <!-- comment --><TD VALIGN=top>Number of copies in ensembles being copied must
       be the same.</TD>
</TR>
<TR><!-- routine --><TD VALIGN=top>duplicate_ens</TD>
    <!-- message --><TD VALIGN=top>num_vars ### and ### must be equal</TD>
    <!-- comment --><TD VALIGN=top>Number of variables in ensembles being copied must 
        be the same.</TD>
</TR>
<TR><!-- routine --><TD VALIGN=top>duplicate_ens</TD>
    <!-- message --><TD VALIGN=top>distribution_type ### and ### must be equal. </TD>
    <!-- comment --><TD VALIGN=top>Distribution types of ensembles being copies must
        be the same.</TD>
</TR>
<TR><!-- routine --><TD VALIGN=top>get_my_copies</TD>
    <!-- message --><TD VALIGN=top>Array copies only has size ### but must be 
        at least ###</TD>
    <!-- comment --><TD VALIGN=top>The copies array must be large enough to hold
       all copies of the state vector.</TD>
</TR>
<TR><!-- routine --><TD VALIGN=top>get_my_vars</TD>
    <!-- message --><TD VALIGN=top>Array vars only has size ### but must
        be at least ###</TD>
    <!-- comment --><TD VALIGN=top>The vars array must be large enough to hold
      all variables of the state vector.</TD>
</TR>
</TABLE>
</div>

<!--==================================================================-->
<!-- Describe the bugs.                                               -->
<!--==================================================================-->

<A NAME="KnownBugs"></A>
<BR><HR><BR>
<H2>KNOWN BUGS</H2>
<P>
</P>

<!--==================================================================-->
<!-- Descibe Future Plans.                                            -->
<!--==================================================================-->

<A NAME="FuturePlans"></A>
<BR><HR><BR>
Additional options for the layout of ensemble storage may lead to improved
performance for different problem sizes on different architectures.
<BR><HR><BR>
<H2>FUTURE PLANS</H2>
<P>
</P>

<!--==================================================================-->
<!-- Have not fleshed out this part yet ... ha ha ha                  -->
<!--==================================================================-->

<A NAME="PrivateComponents"></A>
<BR><HR><BR>
<H2>PRIVATE COMPONENTS</H2>

<!-- <div class=routine> -->
<!-- <pre> -->
<!-- type location_type -->
<!--    private -->
<!--    real(r8) :: x -->
<!-- end type location_type</pre> -->
<!-- </div> -->

<H3 class=indent1>Discussion</H3>

<!--==================================================================-->

<HR>
</BODY>
</HTML>
