<!--
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!                                                                       !!
!!                   GNU General Public License                          !!
!!                                                                       !!
!! This file is part of the Data Assimilation Research Testbed (DART).   !!
!!                                                                       !!
!! DART is free software; you can redistribute it and/or modify          !!
!! it and are expected to follow the terms of the GNU General Public     !!
!! License as published by the Free Software Foundation.                 !!
!!                                                                       !!
!! DART is distributed in the hope that it will be useful,               !!
!! but WITHOUT ANY WARRANTY; without even the implied warranty of        !!
!! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         !!
!! GNU General Public License for more details.                          !!
!!                                                                       !!
!! You should have received a copy of the GNU General Public License     !!
!! along with DART; if not, write to:                                    !!
!!          Free Software Foundation, Inc.                               !!
!!          59 Temple Place, Suite 330                                   !!
!!          Boston, MA  02111-1307  USA                                  !!
!! or see:                                                               !!
!!          http://www.gnu.org/licenses/gpl.txt                          !!
!!                                                                       !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-->

<HTML>
<TITLE>module model_mod (Ikeda)</TITLE>
<link rel=stylesheet type=text/css href=../../doc/html/doc.css>
<BODY>

<!--kdr PRIVATE COMPONENTS has no destination -->
<DIV ALIGN=CENTER>
<A HREF="#Interface">INTERFACE</A> / 
<A HREF="#PublicEntities">PUBLIC COMPONENTS</A> / 
<A HREF="#Namelist">NAMELIST</A> / 
<A HREF="#FilesUsed">FILES</A> /
<A HREF="#References">REFERENCES</A> /
<A HREF="#Errors">ERRORS</A> /
<A HREF="#KnownBugs">BUGS</A> /
<A HREF="#FuturePlans">PLANS</A> /
<A HREF="#PrivateComponents">PRIVATE COMPONENTS</A>
</DIV>

<!--==================================================================-->

<H1>MODULE model_mod (Ikeda)</H1>
<A NAME="HEADER"></A>
<TABLE summary="">
   <TR><TD>Contact:       </TD><TD> Jeff Anderson                </TD></TR>
   <TR><TD>Reviewers:     </TD><TD> &nbsp;                       </TD></TR>
   <TR><TD>Revision:      </TD><TD> $Revision: 2565 $             </TD></TR>
   <TR><TD>Release Name:  </TD><TD> $Name$                       </TD></TR>
   <TR><TD>Change Date:   </TD><TD> $Date: 2007-01-23 21:38:37 -0700 (Tue, 23 Jan 2007) $ </TD></TR>
   <TR><TD>Change history:</TD><TD> see CVS log                  </TD></TR>
</TABLE>

<!--==================================================================-->

<A NAME="OVERVIEW"></A>
<HR>
<H2>OVERVIEW</H2>

<P>
DART interface module for the Ikeda model. The 13 public interfaces
are standardized for all DART compliant models. These interfaces allow
DART to advance the model, get the model state and metadata describing 
this state, find state variables that are close to a given location, 
and do spatial interpolation for model state variables.
</P>
<P>
The Ikeda model is a 2D chaotic map useful for visualization 
data assimilation updating directly in state space.  
There are three parameters:  a, b, & mu.  The state is 2D, x = [X Y].
The equations are:
<pre>
X(i+1) = 1 + mu * ( X(i) * cos( t ) - Y(i) * sin( t ) )
Y(i+1) =     mu * ( X(i) * sin( t ) + Y(i) * cos( t ) ),
</pre>
where
<pre>
t = a - b / ( X(i)**2 + Y(i)**2 + 1 )
</pre>
<P>
Note the system is time-discrete already, meaning there is no delta_t.  The
system stems from nonlinear optics (Ikeda 1979, Optics Communications).
</P>
<P>
The model_mod.f90 file is very similar to that of the Lorenz 63 system.
</P>


<!--==================================================================-->

<A NAME="OTHER MODULES USED"></A>
<BR><HR><BR>
<H2>OTHER MODULES USED</H2>
<PRE>
types_mod
time_manager_mod
oned/location_mod
utilities_mod
</PRE>

<!--==================================================================-->
<!--Note to authors. The first row of the table is different.         -->

<A NAME="Interface"></A>
<BR><HR><BR>
<H2>PUBLIC INTERFACE</H2>

<TABLE>
<TR><TD><em class=call>use model_mod, only : </em></TD>
                   <TD><A HREF="#yyyroutine1">get_model_size</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine2">adv_1step</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine3">get_state_meta_data</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine4">model_interpolate</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine5">get_model_time_step</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine6">end_model</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine7">static_init_model</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine8">init_time</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine9">init_conditions</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine10">model_get_close_states</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine11">nc_write_model_atts</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine12">nc_write_model_vars</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine13">pert_model_state</A></TD></TR>
</TABLE>

<H3 class=indent1>NOTES</H3>
<P>
The namelist interface
<A HREF="#Namelist"> <em class=code>&#38;model_nml</em> </A>
is read from the file <em class=file>input.nml</em>.
</P>


<!--==================================================================-->
<!-- Declare all public entities ...                                  -->
<!-- duplicate public routines template as many times as necessary    -->
<!-- make sure you replace all yyyroutine?? strings                   -->
<!--==================================================================-->

<A NAME="PublicEntities"></A>
<BR><HR><BR>
<H2>PUBLIC COMPONENTS</H2>
<P>
</P>

<!--===================== DESCRIPTION OF FUNCTION =====================-->

<A NAME="yyyroutine1"></A>
<P></P><HR><P></P>
<div class=routine>
<em class=call> var = get_model_size( )</em>
<pre>
integer                               :: <em class=code> get_model_size </em>
</pre></div>

<H3 class=indent1>Description</H3>

<P>
Returns the length of the model state vector as an integer.
</P>


<!--===================== DESCRIPTION OF SUBROUTINE =====================-->

<A NAME="yyyroutine2"></A>
<P></P><HR><P></P>
<div class=routine>
<em class=call>call adv_1step(x, time)</em>
<pre>
real(r8), dimension(:),   intent(inout) :: <em class=code> x </em>
type(time_type),          intent(in)    :: <em class=code> time </em>
</pre></div>

<H3 class=indent1>Description</H3>

<P>
Advances a model for a single time step if this operation is defined. 
The time associated with the initial model state is also required. 
This interface is only required if `synchronous' model state advance 
is supported (the model is called directly as a Fortran90 subroutine 
from the assimilation programs). This is generally not the preferred 
method for large models which can provide a stub for this interface. 
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>x</em></TD>
    <TD>State vector of length model_size.</TD></TR>

<TR><TD valign=top><em class=code>time</em></TD>
    <TD>Gives time of the initial model state. Needed for models that 
have real time state requirements, for instance the computation of 
radiational parameters. Note that DART provides a time_manager_mod 
module that is used to support time computations 
throughout the facility. </TD></TR>

</TABLE>


<!--===================== DESCRIPTION OF SUBROUTINE =====================-->

<A NAME="yyyroutine3"></A>
<P></P><HR><P></P>
<div class=routine>
<em class=call>call get_state_meta_data (index_in, location, 
                          <em class=optionalcode>[,var_type]</em> )</em>
<pre>
integer,               intent(in)    :: <em class=code> index_in </em>
type(location_type),   intent(out)   :: <em class=code> location </em>
integer, optional,     intent(out)   :: <em class=optionalcode> var_type </em>
</pre></div>

<H3 class=indent1>Description</H3>

<P>
 Returns metadata about a given element, indexed by index_in, in the model 
state vector. The location defines where the state variable is located 
(at present, a variety of simple location models for support of gridpoint 
models are provided) while the type of the variable (for instance temperature, 
or u wind component) is returned by var_type. The integer values used to 
indicate different variable types in var_type are themselves defined as 
public interfaces to model_mod if required. Low order models in which var_type 
is not necessarily meaningful should simply return a single integer value.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>index_in</em></TD>
    <TD>Index into the long state vector.</TD></TR>

<TR><TD valign=top><em class=code>location</em></TD>
    <TD>Returns location of indexed state variable. The location should 
use a location_mod that is appropriate for the model domain. For 
realistic atmospheric models, for instance, a three-dimensional 
spherical location module that can represent height in a variety  
of ways is provided. </TD></TR>

<TR><TD valign=top><em class=optionalcode>var_type</em></TD>
    <TD>Returns the type of the indexed state variable as an 
         optional argument.</TD></TR>

</TABLE>

<H3 class=indent1>Notes</H3>

<!--===================== DESCRIPTION OF FUNCTION =====================-->

<A NAME="yyyroutine4"></A>
<P></P><HR><P></P>
<div class=routine>
<em class=call>call model_interpolate(x, location, itype, obs_val, istatus)</em>
<pre>
real(r8), dimension(:),   intent(in)  :: <em class=code> x </em>
type(location_type),      intent(in)  :: <em class=code> location </em>
integer,                  intent(in)  :: <em class=code> itype </em>
real(r8)                              :: <em class=code> var </em>
real(r8),                 intent(out) :: <em class=code> obs_val </em>
integer,                  intent(out) :: <em class=code> istatus </em>
</pre></div>

<H3 class=indent1>Description</H3>

<P>
Given model state, returns the value of variable itype interpolated to a given 
location by a method of the model's choosing. At present, this is the only 
support for forward operators that is required from the model_mod. 
As observations 
with more complex forward operators are explored a significant additional 
complexity may be required for forward operator interfaces.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>x &nbsp; &nbsp; </em></TD>
    <TD>Model state vector. </TD></TR>

<TR><TD valign=top><em class=code>location</em></TD>
    <TD>Location to which to interpolate.</TD></TR>

<TR><TD valign=top><em class=code>itype</em></TD>
    <TD>Integer indexing which type of state variable is to be interpolated. 
Can be ignored for low order models with a single type of variable.</TD></TR>

<TR><TD valign=top><em class=code>obs_val</em></TD>
    <TD> The value of the observation from the model.</TD></TR>

<TR><TD valign=top><em class=code>istatus</em></TD>
    <TD>Quality control information about the observation of the 
          model state.</TD></TR>

</TABLE>

<H3 class=indent1>Notes</H3>


<!--===================== DESCRIPTION OF FUNCTION =====================-->

<A NAME="yyyroutine5"></A>
<P></P><HR><P></P>
<div class=routine>
<em class=call> var = get_model_time_step( )</em>
<pre>
type(time_type)                :: <em class=code> get_model_time_step </em>
</pre></div>

<H3 class=indent1>Description</H3>

<P>
Returns the models base time step, or forecast length, as a time_type. 
In the long run, a more general extended interface may be required that 
specifies the models range of time stepping possibilities.
</P>

<H3 class=indent1>Notes</H3>


<!--===================== DESCRIPTION OF SUBROUTINE =====================-->

<A NAME="yyyroutine6"></A>
<P></P><HR><P></P>
<div class=routine>
<em class=call>call end_model( )</em>
<pre>
</pre></div>

<H3 class=indent1>Description</H3>

<P>
Called when use of a model is completed to clean up storage, etc. 
Can be a stub for most applications.
</P>

<H3 class=indent1>Notes</H3>


<!--===================== DESCRIPTION OF SUBROUTINE =====================-->

<A NAME="yyyroutine7"></A>
<P></P><HR><P></P>
<div class=routine>
<em class=call>call static_init_model( )</em>
<pre>
</pre></div>

<H3 class=indent1>Description</H3>

<P>
Used for runtime initialization of a model, for instance calculating storage 
requirements, initializing model parameters, etc. This is the first call 
made to a model by any DART compliant assimilation routine.
</P>

<H3 class=indent1>Notes</H3>


<!--===================== DESCRIPTION OF SUBROUTINE =====================-->

<A NAME="yyyroutine8"></A>
<P></P><HR><P></P>
<div class=routine>
<em class=call>call init_time(time) </em>
<pre>
type(time_type),          intent(out)    :: <em class=code> time </em>
</pre></div>

<H3 class=indent1>Description</H3>

<P>
Returns the time at which the model will start if no input initial conditions 
are to be used. This is frequently used to spin-up models from rest, 
but is often not meaningfully supported in comprehensive GCMs. 
</P>

<H3 class=indent1>Notes</H3>


<!--===================== DESCRIPTION OF SUBROUTINE =====================-->

<A NAME="yyyroutine9"></A>
<P></P><HR><P></P>
<div class=routine>
<em class=call>call init_conditions( x )</em>
<pre>
real(r8), dimension(:),   intent(out)   :: <em class=code> x </em>
</pre></div>

<H3 class=indent1>Description</H3>

<P>
Returns default initial conditions for model; generally used for spinning up 
initial model states. For GCMs can conceivably just return 0's if initial 
state is always to be provided from input files.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>x</em></TD>
    <TD>Model state vector.</TD></TR>

</TABLE>

<H3 class=indent1>Notes</H3>


<!--===================== DESCRIPTION OF SUBROUTINE =====================-->

<A NAME="yyyroutine10"></A>
<P></P><HR><P></P>
<div class=routine>
<em class=call>call model_get_close_states( o_loc, radius, inum, indices, dist, x) </em>
<pre>
type(location_type),      intent(in)    :: <em class=code> o_loc </em>
real(r8),                 intent(in)    :: <em class=code> radius </em>
integer,                  intent(out)   :: <em class=code> inum </em>
integer, dimension(:),    intent(out)   :: <em class=code> indices </em>
real(r8), dimension(:),   intent(out)   :: <em class=code> dist </em>
real(r8), dimension(:),   intent(in)    :: <em class=code> x </em>
</pre></div>

<H3 class=indent1>Description</H3>

<P>
Returns the number of state variables that are within a given radius (the units 
for the radius depend upon the location_mod module being used by the model) of 
an observation at location o_loc. The indices in the long state vector as well 
as the distance between each close state variable and the observation are also 
returned, provided there is sufficient storage available for them in the 
arrays indices and dist.  
This tends to be the most complicated routine for large models because it 
must be implemented in a very efficient fashion to support a number of 
assimilation algorithms.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>o_loc</em></TD>
    <TD>Location of observation.</TD></TR>

<TR><TD valign=top><em class=code>radius</em></TD>
    <TD>Maximum distance between state and observation.</TD></TR>

<TR><TD valign=top><em class=code>inum</em></TD>
    <TD>Number of close state variables.</TD></TR>

<TR><TD valign=top><em class=code>indices</em></TD>
    <TD>Indices of close state variables found in long model state vector. If 
allocated size of this array is too small, only a subset of the close indices 
is returned. The model_mod gets to decide what subset this is.. </TD></TR>

<TR><TD valign=top><em class=code>dist</em></TD>
    <TD>Distance between observation and state variables indexed in 
        indices array.</TD></TR>

<TR><TD valign=top><em class=code>x</em></TD>
    <TD>Model state vector.  Often needed by GCMs to calculate vertical 
        distance.</TD></TR>

</TABLE>

<H3 class=indent1>Notes</H3>



<!--===================== DESCRIPTION OF FUNCTION =====================-->

<A NAME="yyyroutine11"></A>
<P></P><HR><P></P>
<div class=routine>
<em class=call> ierr = nc_write_model_atts(ncFileId) </em>
<pre>
integer,                     :: <em class=code> nc_write_model_atts </em>
integer,         intent(in)  :: <em class=code> ncFileId </em>
</pre></div>

<H3 class=indent1>Description</H3>

<P>
 Function to write model specific attributes to a netCDF file. At present,
DART is using the NetCDF format to output diagnostic information. This is not
a requirement, and models could choose to provide output in other formats.
This function writes the metadata associated with the model to a NetCDF file
opened to a file identified by ncFileID.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>ncFileId &nbsp; &nbsp; </em></TD>
    <TD>Integer file descriptor opened to NetCDF file.</TD></TR>

<TR><TD valign=top><em class=code>ierr</em></TD>
    <TD>Returned error code.</TD></TR>

</TABLE>

<H3 class=indent1>Notes</H3>



<!--===================== DESCRIPTION OF FUNCTION =====================-->

<A NAME="yyyroutine12"></A>
<P></P><HR><P></P>
<div class=routine>
<em class=call> ierr = nc_write_model_vars(ncFileID, statevec, copyindex, timeindex)</em>
<pre>
integer                             :: <em class=code> nc_write_model_vars </em>
integer,                intent(in)  :: <em class=code> ncFileID </em>
real(r8), dimension(:), intent(in)  :: <em class=code> statevec </em>
integer,                intent(in)  :: <em class=code> copyindex</em>
integer,                intent(in)  :: <em class=code> timeindex </em>
</pre></div>

<H3 class=indent1>Description</H3>

<P>
Writes a copy of the state variables to a NetCDF file. Multiple copies of the 
state for a given time are supported, allowing, for instance, a single file to 
include multiple ensemble estimates of the state.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>ncFileID &nbsp; &nbsp; </em></TD>
    <TD>Integer file descriptor opened to NetCDF file.</TD></TR>

<TR><TD valign=top><em class=code>statevec</em></TD>
    <TD>State vector.</TD></TR>

<TR><TD valign=top><em class=code>copyindex</em></TD>
    <TD> Integer index to which copy is to be written. </TD></TR>

<TR><TD valign=top><em class=code>timeindex</em></TD>
    <TD>Integer index of which time in the file is being written.</TD></TR>

<TR><TD valign=top><em class=code>ierr</em></TD>
    <TD>Returned error code.</TD></TR>

</TABLE>

<H3 class=indent1>Notes</H3>


<!--===================== DESCRIPTION OF SUBROUTINE =====================-->

<A NAME="yyyroutine13"></A>
<P></P><HR><P></P>
<div class=routine>
<em class=call>call pert_model_state(state, pert_state, interf_provided)</em>
<pre>
real(r8), dimension(:),   intent(in)    :: <em class=code> state </em>
real(r8), dimension(:),   intent(out)   :: <em class=code> pert_state </em>
logical,                  intent(out)   :: <em class=code> interf_provided </em>
</pre></div>

<H3 class=indent1>Description</H3>

<P>
Given a model state, produces a perturbed model state. This is used to
generate initial ensemble conditions perturbed around some control
trajectory state when one is preparing to spin-up ensembles. A DART
compliant model can choose not to provide an implementation of this
algorithm and use the default mechanism in DART by simply returning .false.
as a returned value for the interf_provided argument. In this case, DART
perturbs the state to generate ensemble members by adding a random sample
from a N(0.0, 0.002) distribution independently to each state variable.
Models should override this if some structure is required for perturbations
or if the magnitude of perturbations in DART is too large. For instance, the
CAM GCM moisture fields have values that are generally much smaller than
0.002 and perturbing them by this magnitude can cause serious model errors.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>state</em></TD>
    <TD>State vector to be perturbed.</TD></TR>

<TR><TD valign=top><em class=code>pert_state</em></TD>
    <TD>Perturbed state vector is returned. </TD></TR>

<TR><TD valign=top><em class=code>interf_provided</em></TD>
    <TD>Return false to have DART perturb state .</TD></TR>

</TABLE>

<H3 class=indent1>Notes</H3>


<!--==================================================================-->
<!--=================== DESCRIPTION OF A NAMELIST  ===================-->

<A NAME="Namelist"></A>
<BR><HR><BR>
<H2>NAMELIST</H2>
<P>We adhere to the F90 standard of starting a namelist with an ampersand 
'&#38;' and terminating with a slash '/'.
<div class=namelist>
<pre>
<em class=call>namelist / model_nml / </em> &#38
    a, b, mu, time_step_days, time_step_seconds, output_state_vector
</pre>
</div>
</P>

<H3 class=indent1>Discussion</H3>

<P>This namelist is read in a file called <em class=file>input.nml</em>
</P>

<TABLE border=0 cellpadding=3 width=100%>
<TR><TH align=left>Contents    </TH>
    <TH align=left>Type        </TH>
    <TH align=left>Description </TH></TR>
<TR><!--contents--><TD valign=top>a           </TD>
    <!--  type  --><TD valign=top>real(r8)    </TD>
    <!--descript--><TD>Default is 0.40_r8.    </TD></TR>
<TR><!--contents--><TD valign=top>b           </TD>
    <!--  type  --><TD valign=top>real(r8)    </TD>
    <!--descript--><TD>Default is 6.00_r8.    </TD></TR>
<TR><!--contents--><TD valign=top>mu          </TD>
    <!--  type  --><TD valign=top>real(r8)    </TD>
    <!--descript--><TD>Default is 0.83_r8.    </TD></TR>
<TR><!--contents--><TD valign=top>time_step_days  </TD>
    <!--  type  --><TD valign=top>integer         </TD>
    <!--descript--><TD>Default is 0               </TD></TR>
<TR><!--contents--><TD valign=top>time_step_seconds </TD>
    <!--  type  --><TD valign=top>integer           </TD>
    <!--descript--><TD>Default is 3600 (1 hour)     </TD></TR>
<TR><!--contents--><TD valign=top>output_state_vector  </TD>
    <!--  type  --><TD>logical                         </TD>
    <!--descript--><TD>Default is .true.               </TD></TR>
</TABLE>

<!--==================================================================-->
<!-- Describe the Files Used by this module.                          -->
<!--==================================================================-->

<A NAME="FilesUsed"></A>
<BR><HR><BR>
<H2>FILES</H2>
<UL> 
    <LI>model_mod.nml in input.nml
    <LI>netCDF output state diagnostics files
</UL>

<!--==================================================================-->
<!-- Cite references, if need be.                                     -->
<!--==================================================================-->

<A NAME="References"></A>
<BR><HR><BR>
<H2>REFERENCES</H2>

Ikeda 1979, Optics Communications

<!--==================================================================-->
<!-- Describe all the error conditions and codes.                     -->
<!-- Putting a <BR> after the synopsis creates a nice effect.         -->
<!--==================================================================-->

<A NAME="Errors"></A>
<HR>
<H2>ERROR CODES and CONDITIONS</H2>
<div class="errors">

</TABLE>
<TABLE border=1 cellspacing=1 cellpadding=10 width=100%>
<TR><TH>Routine</TH><TH>Message</TH><TH>Comment</TH></TR>
<TR><!-- routine --><TD VALIGN=top>
                                   nc_write_model_atts <BR>
                                   nc_write_model_vars <BR>
    </TD>
    <!-- message --><TD VALIGN=top>Various NetCDF-f90 interface error messages</TD>
    <!-- comment --><TD VALIGN=top>From one of the NetCDF calls in the named routine</TD>
</TR>
</TABLE>
</div>

<!--==================================================================-->
<!-- Describe the bugs.                                               -->
<!--==================================================================-->

<A NAME="KnownBugs"></A>
<BR><HR><BR>
<H2>KNOWN BUGS</H2>
<P>
</P>

<!--==================================================================-->
<!-- Descibe Future Plans.                                            -->
<!--==================================================================-->

<A NAME="FuturePlans"></A>
<BR><HR><BR>
<H2>FUTURE PLANS</H2>
<P>
</P>


<!--==================================================================-->

<HR>
</BODY>
</HTML>
