<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<HTML>
<HEAD>
<TITLE>module model_mod (GITM)</TITLE>
<link rel="stylesheet" type="text/css" href="../../doc/html/doc.css" />
<link href="../../doc/images/dart.ico" rel="shortcut icon" />
</HEAD>
<BODY>
<A NAME="TOP"></A>

<H1>MODULE model_mod (GITM)</H1>

<table border=0 summary="" cellpadding=5>
<tr>
    <td valign=middle>
    <img src="../../doc/images/Dartboard7.png" alt="DART project logo" height=70 />
    </td>
    <td>
       <P><a href="../../index.html">DART Documentation Main Index</a><br />
          <small>version information for this file: <br />
          <!-- version tag follows, do not edit -->
          $Id$</small>
       </P></td>
</tr>
</table>

<A HREF="#Namelist">NAMELIST</A> /
<A HREF="#Interface">INTERFACES</A> /
<A HREF="#FilesUsed">FILES</A> /
<A HREF="#References">REFERENCES</A> /
<A HREF="#Errors">ERRORS</A> /
<A HREF="#FuturePlans">PLANS</A> /
<A HREF="#PrivateComponents">PRIVATE COMPONENTS</A> /
<A HREF="#Legalese">TERMS OF USE</A>

<H2>Overview</H2>

<P> The <a href="http://ccmc.gsfc.nasa.gov/models/modelinfo.php?model=GITM"
    >Global Ionosphere Thermosphere Model (GITM)</a> is a 3-dimensional spherical
    code that models the Earth's thermosphere and ionosphere system using a
    stretched grid in latitude and altitude.
</P>

<P>The <strong>GITM </strong> interface for 
   <strong>Data Assimilation Research Testbed (DART)</strong> is under development.
   If you wish to use GITM, you are urged to contact us. The original scripts were
   configured to run on the University of Michigan machine <strong>NYX</strong> using
   the Portable Batch System (<strong>PBS</strong>). We have attempted to extend the
   scripts to work with both PBS and LSF and are only partway through the process
   at the time of the Lanai release.
   <br />
   <br />
   <strong>DART does not come with the GITM code.</strong> You need to get that on your own.
   The normal procedure of building GITM creates some resource files that are subsequently
   needed by DART - just to compile. These include:
   <ol><li><em class=file>GITM/src/ModSize.f90</em>,
       <li><em class=file>GITM/src/ModTime.f90</em>, and (for example) 
       <li><em class=file>GITM/src/ModEarth.f90</em>&nbsp;.
   </ol>
</P>
<P>
GITM uses binary files for their restart mechanisms, so no metadata is available
to confirm the number and order of fields in the file. Care must be used
to make sure the namelist-controlled set of variables to be included in the
DART state vector is consistent with the restart files.
Each variable must also correspond to a DART "KIND"; required for the DART
interpolate routines. For example, this is nowhere close to being correct:
</P>
   <pre>&amp;model_nml
   gitm_state_variables = 'Temperature',      'KIND_TEMPERATURE',
                          'eTemperature',     'KIND_TEMPERATURE_ELECTRON',
                          'ITemperature',     'KIND_TEMPERATURE_ION',
                          'iO_3P_NDensityS',  'KIND_DENSITY_NEUTRAL_O3P',
                          'iO2_NDensityS',    'KIND_DENSITY_NEUTRAL_O2',
                          'iN2_NDensityS',    'KIND_DENSITY_NEUTRAL_N2',
                               ...                    ...
   /
   </pre>
<P>These variables are then adjusted to be consistent
   with observations and stuffed back into the same netCDF restart files.
   Since DART is an ensemble algorithm, there are multiple restart files for a 
   single restart time: one for each ensemble member. Creating the initial ensemble
   of states is an area of active research.
</P>
   <br />
   <br />
<P>
   DART reads grid information for GITM from several sources. The <em class=file>UAM.in</em>
   file specifies the number of latitudes/longitudes per block, and the number of blocks comes
   from the <em class=file>GITM2/src/ModSize.f90</em> module. 
   Internal to the DART code, the following variables exist:
</P>

   <table width="100%" cellpadding="2">
   <tr><td valign="top">real(r8) :: LON(:)</td>
       <td>longitude array [0, 360) </td></tr>
   <tr><td valign="top">real(r8) :: LAT(:)</td>
       <td>latitude array (-90,90) </td></tr>
   <tr><td valign="top">real(r8) :: ALT(:)</td>
       <td>altitude array (0,~inf) </td></tr>
   <tr><td valign="top">integer :: NgridLon </td>
       <td>the length of the longitude array</td></tr>
   <tr><td valign="top">integer :: NgridLat </td>
       <td>the length of the latitude array</td></tr>
   <tr><td valign="top">integer :: NgridAlt </td>
       <td>the length of the altitude array</td></tr>
   </table>

<P>
   <!-- em class=file>input.nml</em><em class=code>&amp;model_nml:gitm_restart_dirname</em> 
   and checks for the existence and shape of the desired state variables. This not
   only determines the size of the DART state vector, but DART also inherits much 
   of the metadata for the variables from the GITM restart file. 
   When DART is responsible for starting/stopping GITM, the information is 
   conveyed through the command line arguments to GITM. -->
</P>

<div class=indent1>
   <h2>GITM</h2>
   <P>
      was compiled with the gfortran 4.2.3 compilers and run on a Mac.
      <br />
      <br />
      The DART components were built with the following <em class=file>mkmf.template</em> settings:
   </P>
   <pre>
      FC = gfortran
      LD = gfortran
      NETCDF = /Users/thoar/GNU
      INCS = -I${NETCDF}/include
      LIBS = -L${NETCDF}/lib -lnetcdf -lcurl -lhdf5_hl -lhdf5 -lz  -lm
      FFLAGS = -O0 -fbounds-check -frecord-marker=4 -ffpe-trap=invalid $(INCS)
      LDFLAGS = $(FFLAGS) $(LIBS)
   </pre>
</div> 

<a name="conversions"></a>
<div class=indent1>
   <h3>Converting between DART files and GITM restart files</h3>
   <P>The binary GITM files contain no metadata, so care is needed when
      converting between DART state variables and GITM files.
   </P>
      <br />
      <br />
   <P>
      There are two programs - both require the list of GITM variables to use in
      the DART state vector: the
       <em class="code">model_nml:gitm_state_variables</em> variable in the 
       <em class="file">input.nml</em> file.
   </P>
   <table width="100%" cellpadding="10">
   <tr><td valign="top"><a href="gitm_to_dart.html">gitm_to_dart.f90</a></td>
       <td>converts a set of GITM restart files (there is one restart file per block) 
       <em class=file>bxxxx.rst</em> into a 
       DART-compatible file normally called <em class=file>dart_ics</em>&nbsp;.
       We usually wind up linking to this static filename.
       </td>
   </tr>
   <tr><td valign="top"><a href="dart_to_gitm.html">dart_to_gitm.f90</a></td>
       <td>inserts the DART output into existing GITM restart files.
       There are two different types of DART output files, so there is a namelist
       option to specify if the DART file has two time records or just one.
       If there are two, the first one is the 'advance_to' time, followed 
       by the 'valid_time' of the ensuing state. If there is just one, it is
       the 'valid_time' of the ensuing state.
       <em class=program>dart_to_gitm</em> determines the GITM restart file 
       name from the <em class=file>input.nml</em>
       <em class=code>model_nml:gitm_restart_dirname</em>.
       If the DART file contains an 'advance_to' time, 
       <em class=program>dart_to_gitm</em> creates a 
       <em class=file>DART_GITM_time_control.txt</em> file which can be used 
       to control the length of the GITM integration.
       </td>
   </tr>
   </table>
</div>

<!-- gitm source code in DART/pub as GITM2_29May2013.tar -->

<a name="simpletest"></a>
<div class=indent1>
   <h3>Simple test.</h3>
   <P>
   The simplest way to test the converter is to compile GITM and run a single
   model state forward using <em class=program>work/clean.sh</em>.
   To build GITM ... download GITM and unpack the code into
   <em class=file>DART/models/gitm/GITM2</em> and follow these instructions:
   </P>
<div class=unix>
<pre>
cd models/gitm/GITM2
./Config.pl -install -compiler=ifortmpif90 -earth
make
cd ../work
./clean.sh 1 1 0 150.0 170.0 1.0
</pre>
</div>

</div>

<!--==================================================================-->
<!--=================== DESCRIPTION OF A NAMELIST  ===================-->
<!--==================================================================-->

<A NAME="Namelist"></A>
<div class="top">[<a href="#">top</a>]</div><hr />
<H2>NAMELIST</H2>
<P>We adhere to the F90 standard of starting a namelist with an ampersand
'&amp;' and terminating with a slash '/' for all our namelist input.
Consider yourself forewarned that character strings that contain a '/' must be
enclosed in quotes to prevent them from prematurely terminating the namelist.
</P>
<div class=namelist><pre>

# The list of variables to put into the state vector is here:
# The definitions for the DART kinds are in DART/obs_def/obs_def*f90
# The order doesn't matter to DART. It may to you.

&amp;model_nml
   gitm_restart_dirname         = 'advance_temp_e1/UA/restartOUT',
   assimilation_period_days     = 0,
   assimilation_period_seconds  = 1800,
   model_perturbation_amplitude = 0.2,
   output_state_vector          = .false.,
   calendar                     = 'Gregorian',
   debug                        = 0,
   gitm_state_variables  = 'Temperature',            'KIND_TEMPERATURE',
                           'eTemperature',           'KIND_TEMPERATURE_ELECTRON',
                           'ITemperature',           'KIND_TEMPERATURE_ION',
                           'iO_3P_NDensityS',        'KIND_DENSITY_NEUTRAL_O3P',
                           'iO2_NDensityS',          'KIND_DENSITY_NEUTRAL_O2',
                           'iN2_NDensityS',          'KIND_DENSITY_NEUTRAL_N2',
                           'iN_4S_NDensityS',        'KIND_DENSITY_NEUTRAL_N4S',
                           'iNO_NDensityS',          'KIND_DENSITY_NEUTRAL_NO',
                           'iN_2D_NDensityS',        'KIND_DENSITY_NEUTRAL_N2D',
                           'iN_2P_NDensityS',        'KIND_DENSITY_NEUTRAL_N2P',
                           'iH_NDensityS',           'KIND_DENSITY_NEUTRAL_H',
                           'iHe_NDensityS',          'KIND_DENSITY_NEUTRAL_HE',
                           'iCO2_NDensityS',         'KIND_DENSITY_NEUTRAL_CO2',
                           'iO_1D_NDensityS',        'KIND_DENSITY_NEUTRAL_O1D',
                           'iO_4SP_IDensityS',       'KIND_DENSITY_ION_O4SP',
                           'iO2P_IDensityS',         'KIND_DENSITY_ION_O2P',
                           'iN2P_IDensityS',         'KIND_DENSITY_ION_N2P',
                           'iNP_IDensityS',          'KIND_DENSITY_ION_NP',
                           'iNOP_IDensityS',         'KIND_DENSITY_ION_NOP',
                           'iO_2DP_IDensityS',       'KIND_DENSITY_ION_O2DP',
                           'iO_2PP_IDensityS',       'KIND_DENSITY_ION_O2PP',
                           'iHP_IDensityS',          'KIND_DENSITY_ION_HP',
                           'iHeP_IDensityS',         'KIND_DENSITY_ION_HEP',
                           'ie_IDensityS',           'KIND_DENSITY_ION_E',
                           'U_Velocity_component',   'KIND_VELOCITY_U',
                           'V_Velocity_component',   'KIND_VELOCITY_V',
                           'W_Velocity_component',   'KIND_VELOCITY_W',
                           'U_IVelocity_component',  'KIND_VELOCITY_U_ION',
                           'V_IVelocity_component',  'KIND_VELOCITY_V_ION',
                           'W_IVelocity_component',  'KIND_VELOCITY_W_ION',
                           'iO_3P_VerticalVelocity', 'KIND_VELOCITY_VERTICAL_O3P',
                           'iO2_VerticalVelocity',   'KIND_VELOCITY_VERTICAL_O2',
                           'iN2_VerticalVelocity',   'KIND_VELOCITY_VERTICAL_N2',
                           'iN_4S_VerticalVelocity', 'KIND_VELOCITY_VERTICAL_N4S',
                           'iNO_VerticalVelocity',   'KIND_VELOCITY_VERTICAL_NO',
                           'f107',                   'KIND_1D_PARAMETER',
                           'Rho',                    'KIND_DENSITY',
    /
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>This namelist is read in a file called <em class=file>input.nml</em>.
   This namelist provides control over the assimilation period for the model.
   All observations within (+/-) half of the assimilation period are assimilated.
   The assimilation period is the minimum amount of time the model can be advanced,
   and checks are performed to ensure that the assimilation window is a multiple of
   the model dynamical timestep.
</P>

<TABLE border=0 cellpadding=3 width=100%>
<TR><TH align=left>Contents    </TH>
    <TH align=left>Type        </TH>
    <TH align=left>Description </TH></TR>

<TR><!--contents--><TD valign=top>gitm_restart_dirname&nbsp;&nbsp;</TD>
    <!--  type  --><TD valign=top>character(len=256)&nbsp;&nbsp;</TD>
    <!--descript--><TD>The name of the directory containing the
                       GITM restart files and runtime control information.
                       </em></TD></TR>

<TR><!--contents--><TD valign=top>assimilation_period_days</TD>
    <!--  type  --><TD valign=top>integer</em></TD>
    <!--descript--><TD valign=top>The number of days to advance the model for each assimilation.
                       </TD></TR>

<TR><!--contents--><TD valign=top>assimilation_period_seconds</TD>
    <!--  type  --><TD valign=top>integer</em></TD>
    <!--descript--><TD valign=top>In addition to <em class=code>assimilation_period_days</em>, 
                    the number of seconds to advance the model for each assimilation.
                       </TD></TR>

<TR><!--contents--><TD valign=top>model_perturbation_amplitude</TD>
    <!--  type  --><TD valign=top>real(r8)</em></TD>
    <!--descript--><TD valign=top> Reserved for future use.
                  <!-- The amount of noise to add when trying to perturb a single
                       state vector to create an ensemble. Only used when 
<em class=file>input.nml</em><em class=code>&amp;filter_nml:start_from_restart = .false.</em>
                       See also 
                       <a href="#InitialEnsemble">Generating the initial ensemble</a> 
                       at the start of this document. units: standard deviation 
                       of a gaussian distribution with the mean at the value of 
                       the state vector element. --> </TD></TR> 

<TR><!--contents--><TD valign=top>output_state_vector</TD>
    <!--  type  --><TD valign=top>logical</em></TD>
    <!--descript--><TD valign=top>The switch to determine the form of the state vector in the
                       output netCDF files. If <em class=code>.true.</em> 
                       the state vector will be output exactly as DART uses it 
                       ... one long array.  If <em class=code>.false.</em>, 
                       the state vector is parsed into prognostic variables and 
                       output that way -- much easier to use with 'ncview', for
                       example.</TD></TR>

<TR><!--contents--><TD valign=top>calendar</TD>
    <!--  type  --><TD valign=top>character(len=32)</TD>
    <!--descript--><TD valign=top>
                       Character string specifying the calendar being used by GITM.</TD></TR>

<TR><!--contents--><TD valign=top>debug</TD>
    <!--  type  --><TD valign=top>integer</em></TD>
    <!--descript--><TD valign=top>The switch to specify the run-time verbosity.<br />
                       <em class=code>0</em> is as quiet as it gets.<br />
                       <em class=code>&gt; 1</em> provides more run-time messages.<br />
                       <em class=code>&gt; 5</em> provides ALL run-time messages.
                       </TD></TR>

<TR><!--contents--><TD valign=top>gitm_state_variables</TD>
    <!--  type  --><TD valign=top>character(len=NF90_MAX_NAME)::&nbsp;&nbsp;<br />
                                  dimension(160)</TD>
    <!--descript--><TD valign=top>The table that relates the GITM variables 
                   to use to build the DART state vector, and the corresponding 
                   DART kinds for those variables.</TD></TR>
</TABLE>

</div>
<P>&nbsp;</P>

<!--==================================================================-->

<A NAME="OtherModulesUsed"></A>
<div class="top">[<a href="#">top</a>]</div><hr />
<H2>OTHER MODULES USED</H2>

<PRE>
<a href="../../common/types_mod.html">types_mod</a>
<a href="../../time_manager/time_manager_mod.html">time_manager_mod</a>
<a href="../../location/threed_sphere/location_mod.html">threed_sphere/location_mod</a>
<a href="../../utilities/utilities_mod.html">utilities_mod</a>
<a href="../../obs_kind/obs_kind_mod.html">obs_kind_mod</a>
<a href="../../mpi_utilities/mpi_utilities_mod.html">mpi_utilities_mod</a>
<a href="../../random_seq/random_seq_mod.html">random_seq_mod</a>
<a href="dart_gitm_mod.html">dart_gitm_mod</a>
</PRE>

<!--==================================================================-->
<!-- Note to authors. The first row of the table is different.        -->
<!--==================================================================-->
<!-- Declare all public entities ...                                  -->
<!-- duplicate public routines template as many times as necessary    -->
<!-- make sure you replace all yyyroutine?? strings                   -->
<!--==================================================================-->

<A NAME="Interface"></A>
<div class="top">[<a href="#">top</a>]</div><hr />
<H2>PUBLIC INTERFACES</H2>

<P>
Only a select number of interfaces used are discussed here.
Each module has its own discussion of their routines. 
</P>

<h3 class=indent1>Required Interface Routines</h3>
<TABLE width=50%>
<TR><TD><em class=call>use model_mod,&nbsp;only&nbsp;:</em></TD>
                   <TD><A HREF="#get_model_size">get_model_size</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#adv_1step">adv_1step</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_state_meta_data">get_state_meta_data</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#model_interpolate">model_interpolate</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_model_time_step">get_model_time_step</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#static_init_model">static_init_model</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#end_model">end_model</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#init_time">init_time</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#init_conditions">init_conditions</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#nc_write_model_atts">nc_write_model_atts</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#nc_write_model_vars">nc_write_model_vars</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#pert_model_state">pert_model_state</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_close_maxdist_init">get_close_maxdist_init</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_close_obs_init">get_close_obs_init</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_close_obs">get_close_obs</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#ens_mean_for_model">ens_mean_for_model</A></TD></TR>
</TABLE>

<h3 class=indent1>Unique Interface Routines</h3>
<TABLE width=50%>
<TR><TD><em class=call>use model_mod, only : </em></TD>
<TR><TD>&nbsp;</TD><TD><A HREF="#restart_file_to_statevector">restart_file_to_statevector</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#statevector_to_restart_file">statevector_to_restart_file</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_gitm_restart_dirname">get_gitm_restart_dirname</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_state_time">get_state_time</A></TD></TR>
</TABLE>

<TABLE>
<TR><TD><em class=call>use location_mod, only : </em></TD>
    <TD><A HREF="../../location/threed_sphere/location_mod.html#get_close_obs">get_close_obs</A></TD></TR>
</TABLE>

<P>
   A note about documentation style.
   Optional arguments are enclosed in brackets
   <em class=optionalcode>[like this]</em>.
</P>

<!--==================================================================-->
<H3 class=indent1>Required Interface Routines</H3>
<!--==================================================================-->

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="get_model_size"></A>
<br />
<div class=routine>
<em class=call>model_size = get_model_size( )</em>
<pre>
integer :: <em class=code>get_model_size</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Returns the length of the model state vector.
Required.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>model_size</em></TD>
    <TD>The length of the model state vector.</TD></TR>

</TABLE>

</div>
<br />

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="adv_1step"></A>
<br />
<div class=routine>
<em class=call>call adv_1step(x, time)</em>
<pre>
real(r8), dimension(:), intent(inout) :: <em class=code>x</em>
type(time_type),        intent(in)    :: <em class=code>time</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
<em class=code>adv_1step</em>
is not used for the gitm model.
Advancing the model is done through the <em class=program>advance_model</em> script.
This is a NULL_INTERFACE, provided only for compatibility with the DART requirements.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>x</em></TD>
    <TD>State vector of length model_size.</TD></TR>

<TR><TD valign=top><em class=code>time&nbsp;&nbsp;&nbsp;</em></TD>
    <TD>Specifies time of the initial model state.</TD></TR>

</TABLE>

</div>
<br />

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="get_state_meta_data"></A>
<br />
<div class=routine>
<em class=call>call get_state_meta_data (index_in, location, 
                          <em class=optionalcode>[,&nbsp;var_type]</em> )</em>
<pre>
integer,             intent(in)  :: <em class=code>index_in</em>
type(location_type), intent(out) :: <em class=code>location</em>
integer, optional,   intent(out) :: <em class=optionalcode> var_type </em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
<em class=code>get_state_meta_data</em>
returns metadata about a given element of the DART representation of the 
model state vector. Since the DART model state vector is a 1D array and the
native model grid is multidimensional, <em class=code>get_state_meta_data</em>  
returns information about the native model state vector representation. Things
like the <em class=code>location</em>, or the type of the variable 
(for instance: temperature, u wind component, ...). 
The integer values used to indicate different variable types in 
<em class=code>var_type</em> are themselves defined as public interfaces 
to model_mod if required.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>index_in&nbsp;&nbsp;&nbsp;</em></TD>
    <TD>Index of state vector element about which information is requested.</TD></TR>

<TR><TD valign=top><em class=code>location</em></TD>
    <TD>Returns the 3D location of the indexed state variable.
        The <em class=code>location_ type</em> comes from
        <em class=file>DART/location/threed_sphere/location_mod.f90</em>.
        Note that the lat/lon are specified in degrees by the user but are converted
        to radians internally.</TD></TR>

<TR><TD valign=top><em class=optionalcode>var_type</em></TD>
    <TD>Returns the type of the indexed state variable as an optional argument.
        The type is one of the list of supported observation types, found in
        the block of code starting 
        <em class=code>!&nbsp;Integer&nbsp;definitions&nbsp;for&nbsp;DART&nbsp;TYPES</em>
        in <em class=file>DART/obs_kind/obs_kind_mod.f90</em> 
        </TD></TR>

</TABLE>

<P>
The list of supported variables in <em class=file>DART/obs_kind/obs_kind_mod.f90</em>
is created by <em class=program>preprocess</em>.
</P>

</div>
<br />

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="model_interpolate"></A>
<br />
<div class=routine>
<em class=call>call model_interpolate(x, location, itype, obs_val, istatus)</em>
<pre>
real(r8), dimension(:), intent(in)  :: <em class=code>x</em>
type(location_type),    intent(in)  :: <em class=code>location</em>
integer,                intent(in)  :: <em class=code>itype</em>
real(r8),               intent(out) :: <em class=code>obs_val</em>
integer,                intent(out) :: <em class=code>istatus</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Given a model state, <em class=code>model_interpolate</em> returns the value of 
the desired observation type (which could be a state variable) that would be 
observed at the desired location. The interpolation method is either
completely specified by the model, or uses some standard 2D or 3D scalar
interpolation routines.
Put another way, <em class=code>model_interpolate</em> will apply the forward
operator <strong>H</strong> to the model state to create an observation at the desired 
location.
<br />
<br />
If the interpolation is valid, <em class=code>istatus = 0</em>. 
In the case where the observation operator is not defined at the given 
location (e.g. the observation is below the lowest model level, above the top
level, or 'dry'), interp_val is returned as 0.0 and istatus = 1. 
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>x</em></TD>
    <TD>A model state vector.</TD></TR>

<TR><TD valign=top><em class=code>location&nbsp;&nbsp;&nbsp;</em></TD>
    <TD>Location to which to interpolate.</TD></TR>

<TR><TD valign=top><em class=code>itype</em></TD>
    <TD>Integer indexing which type of observation is desired.</TD></TR>

<TR><TD valign=top><em class=code>obs_val</em></TD>
    <TD> The interpolated value from the model.</TD></TR>

<TR><TD valign=top><em class=code>istatus</em></TD>
    <TD>Integer flag indicating the success of the interpolation.
       <br />success == 0, failure == anything else</TD></TR>

</TABLE>

</div>
<br />

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="get_model_time_step"></A>
<br />
<div class=routine>
<em class=call>var = get_model_time_step()</em>
<pre>
type(time_type) :: <em class=code>get_model_time_step</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
<em class=code>get_model_time_step</em>
returns the forecast length to be used as the "model base time step" in the filter.
This is the minimum amount of time the model can be advanced by 
<em class=program>filter</em>.  
<em class="strong">This is also the assimilation window</em>. 
All observations within (+/-) one half of the forecast
length are used for the assimilation.
In the <em class=program>GITM</em> case, this is set from 
the namelist values for <em class=file>input.nml</em><em
class=code>&amp;model_nml:assimilation_period_days, assimilation_period_seconds</em>.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>var&nbsp;&nbsp;&nbsp;</em></TD>
    <TD>Smallest time step of model.</TD></TR>

</TABLE>

</div>
<br />

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="static_init_model"></A>
<br />
<div class=routine>
<em class=call>call static_init_model()</em>
</div>

<div class=indent1>
<!-- Description -->

<P>
<em class=code>static_init_model</em>
is called for runtime initialization of the model. 
The namelists are read to determine runtime configuration of the model, 
the grid coordinates, etc. There are no input arguments and no return values. 
The routine sets module-local private attributes that can then be queried by the
public interface routines.
<br />
<br />
See the GITM documentation for all namelists in <em class=file>gitm_in</em>&nbsp;.
Be aware that DART reads the GITM <em class=code>&amp;grid_nml</em> namelist
to get the filenames for the horizontal and vertical grid information as well
as the topography information.
<br />
<br />
The namelists (all mandatory) are:<br />
<em class=file>input.nml</em><em class=code>&amp;model_mod_nml</em>,<br />
<em class=file>gitm_in</em><em class=code>&amp;time_manager_nml</em>,<br />
<em class=file>gitm_in</em><em class=code>&amp;io_nml</em>,<br />
<em class=file>gitm_in</em><em class=code>&amp;init_ts_nml</em>,<br />
<em class=file>gitm_in</em><em class=code>&amp;restart_nml</em>,<br />
<em class=file>gitm_in</em><em class=code>&amp;domain_nml</em>, and<br />
<em class=file>gitm_in</em><em class=code>&amp;grid_nml</em>.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>
</TABLE>

</div>
<br />

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="end_model"></A>
<br />
<div class=routine>
<em class=call>call end_model()</em>
</div>

<div class=indent1>
<!-- Description -->

<P>
<em class=code>end_model</em>
is used to clean up storage for the model, etc. 
when the model is no longer needed. There are no arguments and no return values.
The grid variables are deallocated.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>
</TABLE>

</div>
<br />

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="init_time"></A>
<br />
<div class=routine>
<em class=call>call init_time(time)</em>
<pre>
type(time_type), intent(out) :: <em class=code>time</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
<em class=code>init_time</em>
returns the time at which the model will start if no input initial conditions are
to be used. This is frequently used to spin-up models from rest, but is not
meaningfully supported for the GITM model.  
The only time this routine would get called is if the 
<em class=file>input.nml</em><em class=code>&amp;perfect_model_obs_nml:start_from_restart</em> is .false., which is
not supported in the GITM model.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>time&nbsp;&nbsp;&nbsp;</em></TD>
    <TD>the starting time for the model if no initial conditions are to be supplied.
    This is hardwired to 0.0</TD></TR>

</TABLE>

</div>
<br />

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="init_conditions"></A>
<br />
<div class=routine>
<em class=call>call init_conditions(x)</em>
<pre>
real(r8), dimension(:), intent(out) :: <em class=code>x</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
<em class=code>init_conditions</em>
returns default initial conditions for model; generally used for spinning up
initial model states. For the GITM model it is just a stub because 
the initial state is always provided by the input files.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>x&nbsp;&nbsp;&nbsp;</em></TD>
    <TD>Initial conditions for state vector.
    This is hardwired to 0.0</TD></TR>

</TABLE>

</div>
<br />

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="nc_write_model_atts"></A>
<br />
<div class=routine>
<em class=call>ierr = nc_write_model_atts(ncFileID)</em>
<pre>
integer             :: <em class=code>nc_write_model_atts</em>
integer, intent(in) :: <em class=code>ncFileID</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
<em class=code>nc_write_model_atts</em>
writes model-specific attributes to an opened netCDF file:
In the GITM case, this includes information like the 
coordinate variables (the grid arrays: ULON, ULAT, TLON, TLAT, ZG, ZC, KMT, KMU), 
information from some of the namelists, and either the 1D state 
vector or the prognostic variables (SALT,TEMP,UVEL,VVEL,PSURF). 
All the required information (except for the netCDF file identifier) 
is obtained from the scope of the <em class=program>model_mod</em> module.
Both the <em class=file>input.nml</em> and <em class=file>gitm_in</em> files
are preserved in the netCDF file as variables <em class=code>inputnml</em> and
<em class=code>gitm_in</em>, respectively.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>ncFileID&nbsp;&nbsp;&nbsp;</em></TD>
    <TD>Integer file descriptor to previously-opened netCDF file.</TD></TR>

<TR><TD valign=top><em class=code>ierr</em></TD>
    <TD>Returns a 0 for successful completion.</TD></TR>

</TABLE>

<P>
<em class=code>nc_write_model_atts</em>
is responsible for the model-specific attributes in the following DART-output netCDF files:
<em class=file>True_State.nc</em>, 
<em class=file>Prior_Diag.nc</em>, and 
<em class=file>Posterior_Diag.nc</em>.
</P>

</div>
<br />

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="nc_write_model_vars"></A>
<br />
<div class=routine>
<em class=call>ierr = nc_write_model_vars(ncFileID, statevec, copyindex, timeindex)</em>
<pre>
integer,                intent(in) :: <em class=code>ncFileID</em>
real(r8), dimension(:), intent(in) :: <em class=code>statevec</em>
integer,                intent(in) :: <em class=code>copyindex</em>
integer,                intent(in) :: <em class=code>timeindex</em>
integer                            :: <em class=code>ierr</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
<em class=code>nc_write_model_vars</em>
writes a copy of the state variables to a NetCDF file. Multiple copies of the
state for a given time are supported, allowing, for instance, a single file to
include multiple ensemble estimates of the state. Whether the state vector is 
parsed into prognostic variables (SALT, TEMP, UVEL, VVEL, PSURF) or simply written 
as a 1D array is controlled by 
<em class=file>input.nml</em><em class=code>&amp;model_mod_nml:output_state_vector</em>.
If <em class=code>output_state_vector&nbsp;=&nbsp;.true.</em> the state vector is 
written as a 1D array (the simplest case, but hard to explore with the diagnostics).
If <em class=code>output_state_vector&nbsp;=&nbsp;.false.</em> the state vector is 
parsed into prognostic variables before being written.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>ncFileID</em></TD>
    <TD>file descriptor to previously-opened netCDF file.</TD></TR>

<TR><TD valign=top><em class=code>statevec</em></TD>
    <TD>A model state vector.</TD></TR>

<TR><TD valign=top><em class=code>copyindex&nbsp;&nbsp;&nbsp;</em></TD>
    <TD>Integer index of copy to be written.</TD></TR>

<TR><TD valign=top><em class=code>timeindex</em></TD>
    <TD>The timestep counter for the given state.</TD></TR>

<TR><TD valign=top><em class=code>ierr</em></TD>
    <TD>Returns 0 for normal completion.</TD></TR>

</TABLE>

</div>
<br />

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="pert_model_state"></A>
<br />
<div class=routine>
<em class=call>call pert_model_state(state, pert_state, interf_provided)</em>
<pre>
real(r8), dimension(:), intent(in)  :: <em class=code>state</em>
real(r8), dimension(:), intent(out) :: <em class=code>pert_state</em>
logical,                intent(out) :: <em class=code>interf_provided</em>
</pre>
</div>

<div class=indent1> <!-- Description -->
<P>
Given a model state, <em class=code>pert_model_state</em> produces a 
perturbed model state. This is used to generate ensemble initial conditions 
perturbed around some control trajectory state when one is preparing to 
spin-up ensembles.  Since the DART state vector for the GITM model 
contains both 'wet' and 'dry' cells, it is imperative to provide an 
interface to perturb <strong>just</strong> the wet cells 
(<em class=code>interf_provided == .true.</em>).
<br />
<br />
The magnitude of the perturbation is wholly determined by 
<em class=file>input.nml</em><em class=code>&amp;model_mod_nml:model_perturbation_amplitude</em>
and <strong>utterly, completely fails</strong>.
<br />
<br />
A more robust perturbation mechanism is needed. 
Until then, avoid using this routine by using your own ensemble of initial conditions. 
This is determined by setting
<em class=file>input.nml</em><em class=code>&amp;filter_nml:start_from_restart = .false.</em>
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>state</em></TD>
    <TD>State vector to be perturbed.</TD></TR>

<TR><TD valign=top><em class=code>pert_state</em></TD>
    <TD>The perturbed state vector.</TD></TR>

<TR><TD valign=top><em class=code>interf_provided&nbsp;&nbsp;&nbsp;</em></TD>
    <TD>Because of the 'wet/dry' issue discussed above, this is always 
        <em class=code>.true.</em>, indicating a model-specific perturbation 
        is available.</TD></TR>

</TABLE>

</div>
<br />

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="get_close_maxdist_init"></A>
<br />
<div class=routine>
<em class=call>call get_close_maxdist_init(gc, maxdist)</em>
<pre>
type(get_close_type), intent(inout) :: <em class=code>gc</em>
real(r8),             intent(in)    :: <em class=code>maxdist</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Pass-through to the 3-D sphere locations module. See
<A HREF="../../location/threed_sphere/location_mod.html#get_close_maxdist_init">get_close_maxdist_init()</A> for the documentation of this subroutine.
</P>

</div>
<br />

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="get_close_obs_init"></A>
<br />
<div class=routine>
<em class=call>call get_close_obs_init(gc, num, obs)</em>
<pre>
type(get_close_type), intent(inout) :: <em class=code>gc</em>
integer,              intent(in)    :: <em class=code>num</em>
type(location_type),  intent(in)    :: <em class=code>obs(num)</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Pass-through to the 3-D sphere locations module. See
<A HREF="../../location/threed_sphere/location_mod.html#get_close_obs_init">
get_close_obs_init()</A> for the documentation of this subroutine.
</P>

</div>
<br />

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="get_close_obs"></A>
<br />
<div class=routine>
<em class=call>call get_close_obs(gc, base_obs_loc, base_obs_kind, obs, obs_kind, &amp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;num_close, close_ind
  <em class=optionalcode>[,&nbsp;dist]</em>) </em>
<pre>
type(get_close_type),              intent(in ) :: <em class=code>gc</em>
type(location_type),               intent(in ) :: <em class=code>base_obs_loc</em>
integer,                           intent(in ) :: <em class=code>base_obs_kind</em>
type(location_type), dimension(:), intent(in ) :: <em class=code>obs</em>
integer,             dimension(:), intent(in ) :: <em class=code>obs_kind</em>
integer,                           intent(out) :: <em class=code>num_close</em>
integer,             dimension(:), intent(out) :: <em class=code>close_ind</em>
real(r8), optional,  dimension(:), intent(out) :: <em class=optionalcode>dist</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Given a DART location (referred to as "base") and a set of locations, and a
definition of 'close' - return a subset of locations that are 'close', as well
as their distances to the DART location and their indices. This routine intentionally
masks a routine of the same name in <em class=program>location_mod</em> because we
want to be able to discriminate against selecting 'dry land' locations.
<br />
<br />
Given a single location and a list of other locations, returns the indices
of all the locations close to the single one along with the number of
these and the distances for the close ones.  The list of locations
passed in via the <em class=code>obs</em> argument must be identical to
the list of <em class=code>obs</em> passed into the most recent call
to <em class=code>get_close_obs_init()</em>.  If the list of locations
of interest changes, <em class=code>get_close_obs_destroy()</em> must
be called and then the two initialization routines must be called
before using <em class=code>get_close_obs()</em> again.
<br />
<br />
For vertical distance computations, the general philosophy is to convert all
vertical coordinates to a common coordinate. This coordinate type is defined
in the namelist with the variable "vert_localization_coord".
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>
<TR><TD valign=top><em class=code>gc</em></TD>
    <TD>Structure to allow efficient identification of
        locations 'close' to a given location.</TD></TR>
<TR><TD valign=top><em class=code>base_obs_loc</em></TD>
    <TD>Single given location.</TD></TR>
<TR><TD valign=top><em class=code>base_obs_kind</em></TD>
    <TD>Kind of the single location.</TD></TR>
<TR><TD valign=top><em class=code>obs</em></TD>
    <TD>List of candidate locations.</TD></TR>
<TR><TD valign=top><em class=code>obs_kind</em></TD>
    <TD>Kind associated with candidate locations.</TD></TR>
<TR><TD valign=top><em class=code>num_close</em></TD>
    <TD>Number of locations close to the given location.</TD></TR>
<TR><TD valign=top><em class=code>close_ind</em></TD>
    <TD>Indices of those locations that are close.</TD></TR>
<TR><TD valign=top><em class=optionalcode>dist</em></TD>
    <TD>Distance between given location and the
        close ones identified in close_ind.</TD></TR>
</TABLE>

</div>
<br />

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="ens_mean_for_model"></A>
<br />
<div class="routine">
<em class=call>call ens_mean_for_model(ens_mean)</em>
<pre>
real(r8), dimension(:), intent(in) :: <em class=code>ens_mean</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
<em class=code>ens_mean_for_model</em>
normally saves a copy of the ensemble mean to module-local storage.
This is a NULL_INTERFACE for the GITM model. At present there is
no application which requires module-local storage of the ensemble mean.
No storage is allocated.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>ens_mean</em></TD>
    <TD>State vector containing the ensemble mean.</TD></TR>

</TABLE>

</div>
<br />

<!--====================================================================-->
<div class="top">[<a href="#">top</a>]</div><hr />
<H3 class=indent1>Unique Interface Routines</H3>
<!--====================================================================-->


<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="get_gridsize"></A>
<br />
<div class="routine">
<em class=call>call get_gridsize( num_x, num_y, num_z )</em>
<pre>
integer, intent(out) :: <em class=code>num_x, num_y, num_z</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
<em class=code>get_gridsize</em>
returns the dimensions of the compute domain.
The horizontal gridsize is determined from <em class=file>gitm_restart.nc</em>.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>num_x</em></TD>
    <TD>The number of longitudinal gridpoints.</TD></TR>

<TR><TD valign=top><em class=code>num_y</em></TD>
    <TD>The number of latitudinal gridpoints.</TD></TR>

<TR><TD valign=top><em class=code>num_z</em></TD>
    <TD>The number of vertical gridpoints.</TD></TR>

</TABLE>

</div>
<br />

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="restart_file_to_statevector"></A>
<br />
<div class="routine">
<em class=call>call restart_file_to_statevector(dirname, state_vector, model_time)</em>
<pre>
character(len=*),       intent(in)    :: <em class=code>dirname</em>
real(r8), dimension(:), intent(inout) :: <em class=code>state_vector</em>
type(time_type),        intent(out)   :: <em class=code>model_time</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
   <em class=code>restart_file_to_statevector</em>
   Reads a GITM netCDF format restart file and packs the desired variables
   into a DART state vector.  The desired variables are specified in the
   <em class=file>input_nml</em> <em class=code>model_nml</em> namelist.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>dirname</em></TD>
    <TD>The name of the directory containing the GITM restart files.
        The restart files have names like <em class=file>b0001.rst</em>.
        There are as many restart files as blocks.</TD></TR>

<TR><TD valign=top><em class=code>state_vector</em></TD>
    <TD>the 1D array containing the concatenated GITM variables.

<TR><TD valign=top><em class=code>model_time</em></TD>
    <TD>the time of the model state as read from <em class=file>&lt;dirname&gt;/header.rst</em>.
    </TD></TR>

</TABLE>

</div>
<br />

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="statevector_to_restart_file"></A>
<br />
<div class="routine">
<em class=call>call statevector_to_restart_file(state_vector, dirname, statedate)</em>
<pre>
real(r8), dimension(:), intent(in) :: <em class=code>state_vector</em>
character(len=*),       intent(in) :: <em class=code>dirname</em>
type(time_type),        intent(in) :: <em class=code>statedate</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
<em class=code>statevector_to_restart_file</em>
updates the variables in the GITM restart files with values from 
the DART vector <em class=code>state_vector</em>. The time in the
GITM files must match the <em class=code>statedate</em>.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>state_vector</em></TD>
    <TD>the 1D array containing the DART state vector.</TD></TR>

<TR><TD valign=top><em class=code>dirname</em></TD>
    <TD>The name of the directory containing the GITM restart files.
        The restart files have names like <em class=file>b0001.rst</em>.
        There are as many restart files as blocks.</TD></TR>

<TR><TD valign=top><em class=code>statedate</em></TD>
    <TD>the 'valid_time' of the DART state vector.
    </TD></TR>

</TABLE>

</div>
<br />

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="get_gitm_restart_dirname"></A>
<br />
<div class="routine">
<em class=call>call get_gitm_restart_dirname( dirname )</em>
<pre>
character(len=*), intent(out) :: <em class=code>dirname</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
<em class=code>get_gitm_restart_dirname</em>
returns the name of the directory containing the GITM restart files.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>filename&nbsp;&nbsp;&nbsp;</em></TD>
    <TD>The name of the GITM restart directory as specified by the 
    <em class=file>input.nml</em><em class=code>:model_nml:gitm_restart_dirname</em>
    varible.</TD></TR>

</TABLE>

</div>
<br />

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="get_state_time"></A>
<br />
<div class="routine">
<em class=call>time = get_state_time( dirname )</em>
<pre>
character(len=*), intent(in)  :: <em class=code>dirname</em>
type(time_type),  intent(out) :: <em class=code>time</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
<em class=code>get_state_time</em>
extracts the time of the model state as contained in the 
<em class=file>&lt;gitm_restart_dirname&gt;/header.rst</em> file. 
</P>

</div>
<br />

<!--==================================================================-->
<!-- Describe the Files Used by this module.                          -->
<!--==================================================================-->

<A NAME="FilesUsed"></A>
<div class="top">[<a href="#">top</a>]</div><hr />
<H2>FILES</H2>

<TABLE border=0 width=100%>
<TR><TH align=left>filename</TH>
    <TH align=left>purpose</TH></TR>
<TR><TD>input.nml</TD>
    <TD>to read the model_mod namelist</TD></TR>
<TR><TD>Several GITM source modules: ModConstants, ModSizeGitm, ModEarth ...</TD>
    <TD>provides grid dimensions, model state, and 'valid_time' of the model state</TD></TR>
<TR><TD>header.rst, bNNNN.rst</TD>
    <TD>provides the 'valid_time' of the model state and the model state, respectively</TD></TR>
<TR><TD>True_State.nc</TD>
    <TD>the time-history of the "true" model state from an OSSE</TD></TR>
<TR><TD>Prior_Diag.nc</TD>
    <TD>the time-history of the model state before assimilation</TD></TR>
<TR><TD>Posterior_Diag.nc&nbsp;</TD>
    <TD>the time-history of the model state after assimilation</TD></TR>
<TR><TD>dart_log.out [default name]</TD>
    <TD>the run-time diagnostic output</TD></TR>
<TR><TD>dart_log.nml [default name]</TD>
    <TD>the record of all the namelists actually USED - 
        contains the default values</TD></TR>
</TABLE>
<br />

<!--==================================================================-->
<!-- Cite references, if need be.                                     -->
<!--==================================================================-->

<A NAME="References"></A>
<div class="top">[<a href="#">top</a>]</div><hr />
<H2>REFERENCES</H2>
<ul>
<li>The official <em class=program>GITM</em> site is:
can be found at <a href="http://ccmc.gsfc.nasa.gov/models/modelinfo.php?model=GITM"
                               >ccmc.gsfc.nasa.gov/models/modelinfo.php?model=GITM</a>
</ul>

<!--==================================================================-->
<!-- Describe all the error conditions and codes.                     -->
<!--==================================================================-->

<A NAME="Errors"></A>
<div class="top">[<a href="#">top</a>]</div><hr />
<H2>ERROR CODES and CONDITIONS</H2>
<div class=errors>
<TABLE border=1 cellspacing=1 cellpadding=10 width=100%>
<TR><TH>Routine</TH><TH width="50%">Message</TH><TH>Comment</TH></TR>

<TR><!-- routine --><TD VALIGN=top>restart_file_to_statevector</TD>
    <!-- message --><TD VALIGN=top>cannot open file "xxxx" for reading</TD>
    <!-- comment --><TD VALIGN=top>The GITM restart file "xxxx" does not exist.</TD>
</TR>

<TR><!-- routine --><TD VALIGN=top>restart_file_to_statevector</TD>
    <!-- message --><TD VALIGN=top>'WARNING!!!   year 0 not supported; setting to year 1</TD>
    <!-- comment --><TD VALIGN=top>year 0 ... is not
    supported in a Gregorian calendar. Our intent here is to do data assimilation,
    normally 'real' observations have 'real' dates.</TD>
</TR>

<TR><!-- routine --><TD VALIGN=top>statevector_to_restart_file</TD>
    <!-- message --><TD VALIGN=top>current time /= model time. FATAL error.</TD>
    <!-- comment --><TD VALIGN=top>The DART time does not match the time of the GITM restart file.
    This message is preceeded by several lines indicating the expected times of both DART and GITM.</TD>
</TR>

</TABLE>
</div>

<H2>KNOWN BUGS</H2>
<P>
The scripts to advance the model and run an experiment are in a state of flux
in response to changing hardware.
</P>

<!--==================================================================-->
<!-- Describe Future Plans.                                           -->
<!--==================================================================-->

<A NAME="FuturePlans"></A>
<div class="top">[<a href="#">top</a>]</div><hr />
<H2>FUTURE PLANS</H2>
<P>
Provide a better mechanism for generating a set of perturbed initial 
conditions - <em class=code>pert_model_state()</em> 
</P>

<!--==================================================================-->
<!-- PrivateComponents                                                -->
<!--==================================================================-->

<A NAME="PrivateComponents"></A>
<div class="top">[<a href="#">top</a>]</div><hr />
<H2>PRIVATE COMPONENTS</H2>
<P>
N/A
</P>

<!--==================================================================-->
<!-- Legalese & Metadata                                              -->
<!--==================================================================-->

<A NAME="Legalese"></A>
<div class="top">[<a href="#">top</a>]</div><hr />
<H2>Terms of Use</H2>

<P>
DART software - Copyright 2004 - 2013 UCAR.<br />
This open source software is provided by UCAR, "as is",<br />
without charge, subject to all terms of use at<br />
<a href="http://www.image.ucar.edu/DAReS/DART/DART_download">
http://www.image.ucar.edu/DAReS/DART/DART_download</a>
</P>

<TABLE border=0 cellpadding=0 width=100% summary="">
<TR><TD valign=top>Contact:       </TD><TD> DART core group   </TD></TR>
<TR><TD valign=top>Revision:      </TD><TD> $Revision$ </TD></TR>
<TR><TD valign=top>Source:        </TD><TD> $URL$ </TD></TR>
<TR><TD valign=top>Change Date:   </TD><TD> $Date$ </TD></TR>
<TR><TD valign=top>Change&nbsp;history:&nbsp;</TD><TD> try "svn&nbsp;log" or "svn&nbsp;diff" </TD></TR>
</TABLE>

<!--==================================================================-->

</BODY>
</HTML>
