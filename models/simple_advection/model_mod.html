<HTML>
<HEAD>
<TITLE>module model_mod (simple_advection)</TITLE>
<link rel="stylesheet" type="text/css" href="../../doc/html/doc.css"></link> 
</HEAD>
<BODY>
<!--
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!                                                                       !!
!!                   GNU General Public License                          !!
!!                                                                       !!
!! This file is part of the Data Assimilation Research Testbed (DART).   !!
!!                                                                       !!
!! DART is free software; you can redistribute it and/or modify          !!
!! it and are expected to follow the terms of the GNU General Public     !!
!! License as published by the Free Software Foundation.                 !!
!!                                                                       !!
!! DART is distributed in the hope that it will be useful,               !!
!! but WITHOUT ANY WARRANTY; without even the implied warranty of        !!
!! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         !!
!! GNU General Public License for more details.                          !!
!!                                                                       !!
!! You should have received a copy of the GNU General Public License     !!
!! along with DART; if not, write to:                                    !!
!!          Free Software Foundation, Inc.                               !!
!!          59 Temple Place, Suite 330                                   !!
!!          Boston, MA  02111-1307  USA                                  !!
!! or see:                                                               !!
!!          http://www.gnu.org/licenses/gpl.txt                          !!
!!                                                                       !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-->

<DIV ALIGN=CENTER>
<A HREF="#Interface">INTERFACE</A> / 
<A HREF="#PublicEntities">PUBLIC COMPONENTS</A> / 
<A HREF="#Namelist">NAMELIST</A> / 
<A HREF="#FilesUsed">FILES</A> /
<A HREF="#References">REFERENCES</A> /
<A HREF="#Errors">ERRORS</A> /
<A HREF="#KnownBugs">BUGS</A> /
<A HREF="#FuturePlans">PLANS</A>
</DIV>

<!--==================================================================-->

<H1>MODULE model_mod (simple_advection)</H1>
<A NAME="HEADER"></A>
<TABLE summary="">
<TR><TD>Contact:       </TD><TD> Jeff Anderson     </TD></TR>
<TR><TD>Revision:      </TD><TD> $Revision: 2801 $ </TD></TR>
<TR><TD>Source:        </TD><TD> $URL: http://subversion.ucar.edu/DAReS/DART/trunk/models/simple_advection/model_mod.html $ </TD></TR>
<TR><TD>Change Date:   </TD><TD> $Date: 2007-04-04 22:11:48 -0600 (Wed, 04 Apr 2007) $ </TD></TR>
<TR><TD>Change history:</TD><TD> try "svn log" or "svn diff" </TD></TR>
</TABLE>

<!--==================================================================-->

<A NAME="OVERVIEW"></A>
<HR>
<H2>OVERVIEW</H2>

<P>
DART interface module for the simple advection model. The 17 public interfaces
are standardized for all DART compliant models. These interfaces allow
DART to advance the model, get the model state and metadata describing 
this state, find state variables that are close to a given location, 
and do spatial interpolation for model state variables.
</P>
<P>
This model is on a periodic one-dimensional domain. A wind field is 
modeled using Burger's Equation with an upstream semi-lagrangian 
differencing. This diffusive numerical scheme is stable and forcing
is provided by adding in random gaussian noise to each wind grid
variable independently at each timestep. The domain mean value of the 
wind is relaxed to a constant fixed value set by the namelist parameter
mean_wind. The random forcing magnitude is set by namelist parameter
wind_random_amp and the damping of the mean wind is controlled by
parameter wind_damping_rate. An Eulerian option with centered in 
space differencing is also provided and can be used by setting namelist
parameter lagrangian_for_wind to .false. The Eulerian differencing is
both numerically unstable and subject to shock formation. However, it
can sometimes be made stable in assimilation mode (see recent work by
Majda and collaborators). 

The model state includes a single passive tracer that is advected by
the wind field using semi-lagrangian upstream differencing. The state
also includes a tracer source value at each gridpoint. At each time
step, the source is added into the concentration at each gridpoint.
There is also a constant global destruction of tracer that is controlled
by the namelist parameter destruction_rate. The appropriate percentage
of tracer is destroyed at each gridpoint at each timestep. 

The model also includes an associated model for the tracer source rate.
At each gridpoint, there is a value of the time mean source rate and
a value of the phase offset for a diurnal component of the source rate.
The diurnal source rate has an amplitude that is proportional to the
source rate (this proportion is controlled by namelist parameter
source_diurnal_rel_amp). At each grid point, the source is the sum
of the source rate plus the appropriate diurnally varying component.
The phase_offset at the gridpoint controls the diurnal phase. The
namelist parameter source_phase_noise controls the amplitude of
random gaussian noise that is added into the source phase at each
time step. If source_phase_noise is zero then the phase offset is
fixed. Finally, the time mean source rate is constant in time in the
present model version. The time mean source rate controls the 
amplitude of the diurnal cycle of the tracer source.

</P>

<!--==================================================================-->

<A NAME="OTHER MODULES USED"></A>
<HR>
<H2>OTHER MODULES USED</H2>
<PRE>
types_mod
time_manager_mod
oned/location_mod
utilities_mod
obs_kind_mod
random_seq_mod
</PRE>

<!--==================================================================-->
<!--Note to authors. The first row of the table is different.         -->

<A NAME="Interface"></A>
<HR>
<H2>PUBLIC INTERFACE</H2>

<TABLE>
<TR><TD><em class=call>use model_mod, only : </em></TD>
                   <TD><A HREF="#yyyroutine1">get_model_size</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine2">adv_1step</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine3">get_state_meta_data</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine4">model_interpolate</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine5">get_model_time_step</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine6">end_model</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine7">static_init_model</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine8">init_time</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine9">init_conditions</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine11">nc_write_model_atts</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine12">nc_write_model_vars</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine13">pert_model_state</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_close_maxdist_init">get_close_maxdist_init</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_close_obs_init">get_close_obs_init</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_close_obs">get_close_obs</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#ens_mean_for_model">ens_mean_for_model</A></TD></TR>
</TABLE>

<H3 class=indent1>NOTES</H3>
<P>
Optional namelist interface
<A HREF="#Namelist"> <em class=code>&#38;model_nml</em> </A>
may be read from file <em class=file>input.nml</em>.
</P>


<!--==================================================================-->
<!-- Declare all public entities ...                                  -->
<!-- duplicate public routines template as many times as necessary    -->
<!-- make sure you replace all yyyroutine?? strings                   -->
<!--==================================================================-->

<A NAME="PublicEntities"></A>
<HR>
<H2>PUBLIC COMPONENTS</H2>
<P>
The following routines are public:
</P>

<!--===================== DESCRIPTION OF FUNCTION =====================-->

<A NAME="yyyroutine1"></A>
<P></P><HR><P></P>
<div class=routine>
<em class=call> var = get_model_size( )</em>
<pre>
integer                               :: <em class=code> get_model_size </em>
</pre></div>

<H3 class=indent1>Description</H3>

<P>
Returns the length of the model state vector. For this model, the length
is 5 times the number of grid points. The number of grid points is settable by
namelist and defaults to 10, giving a total default size of 50.
</P>


<!--===================== DESCRIPTION OF SUBROUTINE =====================-->

<A NAME="yyyroutine2"></A>
<P></P><HR><P></P>
<div class=routine>
<em class=call>call adv_1step(x, time)</em>
<pre>
real(r8), dimension(:),   intent(inout) :: <em class=code> x </em>
type(time_type),          intent(in)    :: <em class=code> time </em>
</pre></div>

<H3 class=indent1>Description</H3>

<P>
Advances a model for a single time step.
The time associated with the initial model state is also
input although is it not used in this model.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>x</em></TD>
    <TD>State vector of length model_size</TD></TR>

<TR><TD valign=top><em class=code>time</em></TD>
    <TD>Gives time of the initial model state</TD></TR>

</TABLE>


<!--===================== DESCRIPTION OF SUBROUTINE =====================-->

<A NAME="yyyroutine3"></A>
<P></P><HR><P></P>
<div class=routine>
<em class=call>call get_state_meta_data (index_in, location, 
                          <em class=optionalcode>[,var_type]</em> )</em>
<pre>
integer,                  intent(in)    :: <em class=code> index_in </em>
type(location_type),      intent(out)   :: <em class=code> location </em>
integer, optional,        intent(out)   :: <em class=optionalcode> var_type </em>
</pre></div>

<H3 class=indent1>Description</H3>

<P>
 Returns metadata about a given element, indexed by index_in, in the model 
state vector. The location defines where the state variable is located.
For the simple advection model with the default grid size, variable 1 is at 0.0, 
variable 2 is at 1/10., variable 3 is at 2/10., etc. on a cyclic [0, 1] domain.  
The variable type, if specified, is an integer kind between 1 and 5.
The types are indexed as follows:
	1. Tracer concentration.
	2. Tracer source rate.
	3. Wind velocity.
	4. Tracer source diurnal phase offset.
	5. Time mean tracer source value.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>index_in</em></TD>
    <TD>Index into the long state vector.</TD></TR>

<TR><TD valign=top><em class=code>location</em></TD>
    <TD>Returns location of indexed state variable.</TD></TR>

<TR><TD valign=top><em class=optionalcode>var_type</em></TD>
    <TD>If present, returns an index between 1 and 5 as the type</TD></TR>

</TABLE>

<H3 class=indent1>Notes</H3>

<!--===================== DESCRIPTION OF FUNCTION =====================-->

<A NAME="yyyroutine4"></A>
<P></P><HR><P></P>
<div class=routine>
<em class=call>call model_interpolate(x, location, itype, obs_val, istatus)</em>
<pre>
real(r8), dimension(:),   intent(in)  :: <em class=code> x </em>
type(location_type),      intent(in)  :: <em class=code> location </em>
integer,                  intent(in)  :: <em class=code> itype </em>
real(r8)                              :: <em class=code> var </em>
real(r8),                 intent(out) :: <em class=code> obs_val </em>
integer,                  intent(out) :: <em class=code> istatus </em>
</pre></div>

<H3 class=indent1>Description</H3>

<P>
Given model state, returns the value interpolated to a given location 
in [0, 1] by linear interpolation.
The type variable selects which type (tracer concentration,
tracer source, velocity) is being interpolated.
<em class=code>istatus</em> is returned as 0 for a successful interpolation.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>x &nbsp; &nbsp; </em></TD>
    <TD>Model state vector. </TD></TR>

<TR><TD valign=top><em class=code>location</em></TD>
    <TD>Location to which to interpolate.</TD></TR>

<TR><TD valign=top><em class=code>itype</em></TD>
    <TD>An index variable type</TD></TR>

<TR><TD valign=top><em class=code>obs_val</em></TD>
    <TD> The interpolated value from the model.</TD></TR>

<TR><TD valign=top><em class=code>istatus</em></TD>
    <TD>Quality control information (0 is a good return).
        This model stops on error, since it should never fail to
        generate an interpolated value.
    </TD></TR>

</TABLE>

<H3 class=indent1>Notes</H3>


<!--===================== DESCRIPTION OF FUNCTION =====================-->

<A NAME="yyyroutine5"></A>
<P></P><HR><P></P>
<div class=routine>
<em class=call> var = get_model_time_step( )</em>
<pre>
type(time_type)                       :: <em class=code> get_model_time_step </em>
</pre></div>

<H3 class=indent1>Description</H3>

<P>
Returns the models base time step, or forecast length, as a time_type. 
This is settable via namelist and defaults to 1 hour.
</P>

<H3 class=indent1>Notes</H3>


<!--===================== DESCRIPTION OF SUBROUTINE =====================-->

<A NAME="yyyroutine6"></A>
<P></P><HR><P></P>
<div class=routine>
<em class=call>call end_model( )</em>
<pre>
</pre></div>

<H3 class=indent1>Description</H3>

<P>
A stub since the simple advection model requires no cleanup.
</P>

<H3 class=indent1>Notes</H3>


<!--===================== DESCRIPTION OF SUBROUTINE =====================-->

<A NAME="yyyroutine7"></A>
<P></P><HR><P></P>
<div class=routine>
<em class=call>call static_init_model( )</em>
<pre>
</pre></div>

<H3 class=indent1>Description</H3>

<P>
Used for runtime initialization of a model, for instance calculating storage 
requirements, initializing model parameters, etc. This is the first call 
made to a model by any DART compliant assimilation routine.
</P>
<P>
In this case, it reads the namelist values, allocates space for the state vector,
and initializes module variables needed during the run.
</P>

<H3 class=indent1>Notes</H3>


<!--===================== DESCRIPTION OF SUBROUTINE =====================-->

<A NAME="yyyroutine8"></A>
<P></P><HR><P></P>
<div class=routine>
<em class=call>call init_time(time) </em>
<pre>
type(time_type),          intent(out)    :: <em class=code> time </em>
</pre></div>

<H3 class=indent1>Description</H3>

<P>
Returns the time at which the model will start if no input initial conditions are 
to be used.  This model sets the time to 0.
</P>

<H3 class=indent1>Notes</H3>


<!--===================== DESCRIPTION OF SUBROUTINE =====================-->

<A NAME="yyyroutine9"></A>
<P></P><HR><P></P>
<div class=routine>
<em class=call>call init_conditions( x )</em>
<pre>
real(r8), dimension(:),   intent(out)   :: <em class=code> x </em>
</pre></div>

<H3 class=indent1>Description</H3>

<P>
Returns default initial conditions for model; generally used for spinning up 
initial model states.  This model sets all concentrations to 0, sets up one
source, and sets the wind and time/phase defaults to the
namelist-specified values.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>x</em></TD>
    <TD>Model state vector.</TD></TR>

</TABLE>

<H3 class=indent1>Notes</H3>


<!--===================== DESCRIPTION OF FUNCTION =====================-->

<A NAME="yyyroutine11"></A>
<P></P><HR><P></P>
<div class=routine>
<em class=call> ierr = nc_write_model_atts(ncFileId) </em>
<pre>
integer,                              :: <em class=code> nc_write_model_atts </em>
integer,                  intent(in)  :: <em class=code> ncFileId </em>
</pre></div>

<H3 class=indent1>Description</H3>

<P>
 Function to write model specific attributes to a netCDF file. This function
writes the metadata associated with the model to a NetCDF file opened to a file 
identified by ncFileID.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>ncFileId &nbsp; &nbsp; </em></TD>
    <TD>Integer file descriptor opened to NetCDF file.</TD></TR>

<TR><TD valign=top><em class=code>ierr</em></TD>
    <TD>Returned error code.</TD></TR>

</TABLE>

<H3 class=indent1>Notes</H3>



<!--===================== DESCRIPTION OF FUNCTION =====================-->

<A NAME="yyyroutine12"></A>
<P></P><HR><P></P>
<div class=routine>
<em class=call> ierr = nc_write_model_vars(ncFileID, statevec, copyindex, timeindex)</em>
<pre>
integer                               :: <em class=code> nc_write_model_vars </em>
integer,                  intent(in)  :: <em class=code> ncFileID </em>
real(r8), dimension(:),   intent(in)  :: <em class=code> statevec </em>
integer,                  intent(in)  :: <em class=code> copyindex</em>
integer,                  intent(in)  :: <em class=code> timeindex </em>
</pre></div>

<H3 class=indent1>Description</H3>

<P>
Writes a copy of the state variables to a NetCDF file. Multiple copies of the 
state for a given time are supported, allowing, for instance, a single file to 
include multiple ensemble estimates of the state.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>ncFileID &nbsp; &nbsp; </em></TD>
    <TD>Integer file descriptor opened to NetCDF file.</TD></TR>

<TR><TD valign=top><em class=code>statevec</em></TD>
    <TD>State vector.</TD></TR>

<TR><TD valign=top><em class=code>copyindex</em></TD>
    <TD> Integer index to which copy is to be written. </TD></TR>

<TR><TD valign=top><em class=code>timeindex</em></TD>
    <TD>Integer index of which time in the file is being written.</TD></TR>

<TR><TD valign=top><em class=code>ierr</em></TD>
    <TD>Returned error code.</TD></TR>

</TABLE>

<H3 class=indent1>Notes</H3>


<!--===================== DESCRIPTION OF SUBROUTINE =====================-->

<A NAME="yyyroutine13"></A>
<P></P><HR><P></P>
<div class=routine>
<em class=call>call pert_model_state(state, pert_state, interf_provided)</em>
<pre>
real(r8), dimension(:),   intent(in)    :: <em class=code> state </em>
real(r8), dimension(:),   intent(out)   :: <em class=code> pert_state </em>
logical,                  intent(out)   :: <em class=code> interf_provided </em>
</pre></div>

<H3 class=indent1>Description</H3>

<P>
Given a model state, produces a perturbed model state.
Generates random gaussian values for the tracer concentrations,
the U field, the mean source field and the phase.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>state</em></TD>
    <TD>State vector to be perturbed</TD></TR>

<TR><TD valign=top><em class=code>pert_state</em></TD>
    <TD>Perturbed state vector</TD></TR>

<TR><TD valign=top><em class=code>interf_provided</em></TD>
    <TD>Return .true. because it has code to generate the 
        perturbed state</TD></TR>

</TABLE>

<H3 class=indent1>Notes</H3>

<!--=================================================================-->
<!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="get_close_maxdist_init"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call get_close_maxdist_init(gc, maxdist) </em>
 <pre>
 type(get_close_type), intent(inout) :: <em class=code>gc</em>
 real(r8),             intent(in)    :: <em class=code>maxdist</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Pass-through to the 1-D locations module. See
<A HREF="../../location/oned/location_mod.html#get_close_maxdist_init">
get_close_maxdist_init()</A> for the documentation of this subroutine.

<!--=================================================================-->
<!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="get_close_obs_init"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call get_close_obs_init(gc, num, obs) </em>
 <pre>
 type(get_close_type), intent(inout) :: <em class=code>gc</em>
 integer,              intent(in)    :: <em class=code>num</em>
 type(location_type),  intent(in)    :: <em class=code>obs(num)</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Pass-through to the 1-D locations module. See
<A HREF="../../location/oned/location_mod.html#get_close_obs_init">
get_close_obs_init()</A> for the documentation of this subroutine.

<!--=================================================================-->
<!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="get_close_obs"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call get_close_obs(gc, base_obs_loc, base_obs_kind, 
   obs, obs_kind, num_close, close_ind
   <em class=code>[, dist]</em>) </em>
 <pre>
 type(get_close_type), intent(in)  :: <em class=code>gc</em>
 type(location_type),  intent(in)  :: <em class=code>base_obs_loc</em>
 integer,              intent(in)  :: <em class=code>base_obs_kind</em>
 type(location_type),  intent(in)  :: <em class=code>obs(:)</em>
 integer,              intent(in)  :: <em class=code>obs_kind(:)</em>
 integer,              intent(out) :: <em class=code>num_close</em>
 integer,              intent(out) :: <em class=code>close_ind(:)</em>
 real(r8), optional,   intent(out) :: <em class=optionalcode>dist(:)</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Pass-through to the 1-D locations module. See
<A HREF="../../location/oned/location_mod.html#get_close_obs">
get_close_obs()</A> for the documentation of this subroutine.

<!--=================================================================-->
<!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="ens_mean_for_model"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call ens_mean_for_model(ens_mean) </em>
 <pre>
 real(r8), dimension(:), intent(in)  :: <em class=code>ens_mean</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
A NULL INTERFACE in this model.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>ens_mean&nbsp; &nbsp; </em></TD>
     <TD>Ensemble mean state vector</TD></TR>
 </TABLE>
 <BR>


<!--==================================================================-->
<!--=================== DESCRIPTION OF A NAMELIST  ===================-->

<A NAME="Namelist"></A>
<BR><HR><BR>
<H2>NAMELIST</H2>
<P>We adhere to the F90 standard of starting a namelist with an ampersand 
'&#38;' and terminating with a slash '/'.
<div class=namelist>
<pre>
<em class=call>namelist / model_nml / </em> &#38
     num_grid_points, grid_spacing_meters, time_step_days, time_step_seconds, &#38
     mean_wind, wind_random_amp, wind_damping_rate, lagrangian_for_wind, &#38
     destruction_rate, source_random_amp_frac, source_damping_rate, &#38
     source_diurnal_rel_amp, source_phase_noise, output_state_vector
</pre>
</div>
</P>

<H3 class=indent1>Discussion</H3>

<P>This namelist is read in a file called <em class=file>input.nml</em>
</P>

<TABLE border=0 cellpadding=3 width=100%>
<TR><TH align=left>Contents    </TH>
    <TH align=left>Type        </TH>
    <TH align=left>Description </TH></TR>

<TR><!--contents--><TD valign=top>num_grid_points </TD>
    <!--  type  --><TD valign=top>integer         </TD>
    <!--descript--><TD>Number of grid points in model, default is 10. 
                       State vector size is 5 times this number.
                   </TD></TR>

<TR><!--contents--><TD valign=top>grid_spacing_meters </TD>
    <!--  type  --><TD valign=top>integer             </TD>
    <!--descript--><TD>Grid spacing in meters. 
                       Default 100,000 (100 Km)
                    </TD></TR>

<TR><!--contents--><TD valign=top>time_step_days       </TD>
    <!--  type  --><TD valign=top>real(r8)             </TD>
    <!--descript--><TD>Number of days for dimensional timestep,
                       mapped to delta_t. Default 0
                    </TD></TR>

<TR><!--contents--><TD valign=top>time_step_seconds    </TD>
    <!--  type  --><TD valign=top>real(r8)             </TD>
    <!--descript--><TD>Number of seconds for dimensional timestep,
                       mapped to delta_t. Default 3600
                    </TD></TR>

<TR><!--contents--><TD valign=top>mean_wind            </TD>
    <!--  type  --><TD valign=top>real(r8)             </TD>
    <!--descript--><TD>Base wind velocity (expected value over
                       time) in meters/second.  Default 20
                    </TD></TR>

<TR><!--contents--><TD valign=top>wind_random_amp      </TD>
    <!--  type  --><TD valign=top>real(r8)             </TD>
    <!--descript--><TD>Random walk amplitude for wind
                       in meters/second<sup>2</sup>.  Default 1/3600
                    </TD></TR>

<TR><!--contents--><TD valign=top>wind_damping_rate    </TD>
    <!--  type  --><TD valign=top>real(r8)             </TD>
    <!--descript--><TD>Rate of damping towards mean wind value
                       in fraction/second.  Default 0.01/3600
                    </TD></TR>

<TR><!--contents--><TD valign=top>lagrangian_for_wind  </TD>
    <!--  type  --><TD valign=top>logical              </TD>
    <!--descript--><TD>Can use Lagrangian (stable) or
                       Eulerian (unstable) scheme for wind.
                       Default .true. (Lagrangian)
                    </TD></TR>

<TR><!--contents--><TD valign=top>destruction_rate     </TD>
    <!--  type  --><TD valign=top>real(r8)             </TD>
    <!--descript--><TD>Tracer destruction rate in fraction/second.
                       Default 0.2/3600
                    </TD></TR>

<TR><!--contents--><TD valign=top>source_random_amp_frac</TD>
    <!--  type  --><TD valign=top>real(r8)              </TD>
    <!--descript--><TD>Random walk amplitude for source as a
                       fraction of mean source (per second)<sup>2</sup>.
                       Default 0.00001
                    </TD></TR>

<TR><!--contents--><TD valign=top>source_damping_rate  </TD>
    <!--  type  --><TD valign=top>real(r8)             </TD>
    <!--descript--><TD>Damping towards mean source rate
                       in fraction/second.  Default 0.01/3600
                    </TD></TR>

<TR><!--contents--><TD valign=top>source_diurnal_rel_amp</TD>
    <!--  type  --><TD valign=top>real(r8)              </TD>
    <!--descript--><TD>Relative amplitude of diurnal cycle of
                       source (dimensionless).  Default 0.5
                    </TD></TR>

<TR><!--contents--><TD valign=top>source_phase_noise</TD>
    <!--  type  --><TD valign=top>real(r8)              </TD>
    <!--descript--><TD>Amplitude of gaussian noise to be added
                       to source phase offset (per second).
                       Default 0.0
                    </TD></TR>

<TR><!--contents--><TD valign=top>output_state_vector  </TD>
    <!--  type  --><TD valign=top>logical              </TD>
    <!--descript--><TD>Controls the output to netCDF files. If .true., 
         output the raw dart state vector. Otherwise, output the 
         prognostic version (gridded data) for easier plotting (recommended). 
         Defaults .false. (prognostic format)
                    </TD></TR>

</TABLE>

<!--==================================================================-->
<!-- Describe the Files Used by this module.                          -->
<!--==================================================================-->

<A NAME="FilesUsed"></A>
<HR>
<H2>FILES</H2>
<UL> 
    <LI>model_mod.nml in input.nml
    <LI>netCDF output state diagnostics files
</UL>

<!--==================================================================-->
<!-- Cite references, if need be.                                     -->
<!--==================================================================-->

<A NAME="References"></A>
<HR>
<H2>REFERENCES</H2>



<!--==================================================================-->
<!-- Describe all the error conditions and codes.                     -->
<!-- Putting a <BR> after the synopsis creates a nice effect.         -->
<!--==================================================================-->

<A NAME="Errors"></A>
<HR>
<H2>ERROR CODES and CONDITIONS</H2>
<div class="errors">

</TABLE>
<TABLE border=1 cellspacing=1 cellpadding=10 width=100%>
<TR><TH>Routine</TH><TH>Message</TH><TH>Comment</TH></TR>
<TR><!-- routine --><TD VALIGN=top>
                                   nc_write_model_atts <BR>
                                   nc_write_model_vars <BR>
    </TD>
    <!-- message --><TD VALIGN=top>Various NetCDF-f90 interface error messages</TD>
    <!-- comment --><TD VALIGN=top>From one of the NetCDF calls in the named routine</TD>
</TR>
</TABLE>
</div>

<!--==================================================================-->
<!-- Describe the bugs.                                               -->
<!--==================================================================-->

<A NAME="KnownBugs"></A>
<HR>
<H2>KNOWN BUGS</H2>
<P>
</P>

<!--==================================================================-->
<!-- Describe Future Plans.                                            -->
<!--==================================================================-->

<A NAME="FuturePlans"></A>
<BR><HR><BR>
<H2>FUTURE PLANS</H2>
<P>
</P>

<!--==================================================================-->

<HR>
</BODY>
</HTML>
