<!--
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!                                                                       !!
!!                   GNU General Public License                          !!
!!                                                                       !!
!! This file is part of the Data Assimilation Research Testbed (DART).   !!
!!                                                                       !!
!! DART is free software; you can redistribute it and/or modify          !!
!! it and are expected to follow the terms of the GNU General Public     !!
!! License as published by the Free Software Foundation.                 !!
!!                                                                       !!
!! DART is distributed in the hope that it will be useful,               !!
!! but WITHOUT ANY WARRANTY; without even the implied warranty of        !!
!! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         !!
!! GNU General Public License for more details.                          !!
!!                                                                       !!
!! You should have received a copy of the GNU General Public License     !!
!! along with DART; if not, write to:                                    !!
!!          Free Software Foundation, Inc.                               !!
!!          59 Temple Place, Suite 330                                   !!
!!          Boston, MA  02111-1307  USA                                  !!
!! or see:                                                               !!
!!          http://www.gnu.org/licenses/gpl.txt                          !!
!!                                                                       !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-->

<HTML>
<TITLE>module model_mod</TITLE>
<link rel=stylesheet type=text/css href=../../doc/html/doc.css>
<BODY>

<DIV ALIGN=CENTER>
<A HREF="#Interface">INTERFACE</A> / 
<A HREF="#PublicEntities">PUBLIC COMPONENTS</A> / 
<A HREF="#Namelist">NAMELIST</A> / 
<A HREF="#FilesUsed">FILES</A> /
<A HREF="#References">REFERENCES</A> /
<A HREF="#Errors">ERRORS</A> /
<A HREF="#KnownBugs">BUGS</A> /
<A HREF="#FuturePlans">PLANS</A> /
<A HREF="#PrivateComponents">PRIVATE COMPONENTS</A>
</DIV>

<!--==================================================================-->

<H1>MODULE model_mod (PBL 1D)</H1>
<A NAME="HEADER"></A>
<TABLE summary="">
   <TR><TD>Contact:       </TD><TD> Jeff Anderson                </TD></TR>
   <TR><TD>Reviewers:     </TD><TD> &nbsp;                       </TD></TR>
   <TR><TD>Revision:      </TD><TD> $Revision$             </TD></TR>
   <TR><TD>Release Name:  </TD><TD> $Name$                       </TD></TR>
   <TR><TD>Change Date:   </TD><TD> $Date$ </TD></TR>
   <TR><TD>Change history:</TD><TD> see CVS log                  </TD></TR>
</TABLE>

<!--==================================================================-->

<A NAME="OVERVIEW"></A>
<HR>
<H2>OVERVIEW</H2>

<P>
DART interface module for the PBL 1D model. The 17 public interfaces are
standardized for all DART compliant models. These interfaces allow DART to
advance the model, get the model state and metadata describing this state,
find state variables that are close to a given location, and do spatial
interpolation for model state variables. The distinctive part of the model
interfaces is the namelist.
</P>
<P>
The PBL model is a single column version of the WRF model.
</P>

<!--==================================================================-->

<A NAME="OTHER MODULES USED"></A>
<BR><HR><BR>
<H2>OTHER MODULES USED</H2>
<PRE>
use types_mod
use time_manager_mod
use location_mod (threed-sphere)
use utilities_mod
use sort_mod
use random_seq_mod
use obs_kind_mod
use map_utils

also these WRF modules:

use module_model_constants
use module_initialize
use module_namelist
use module_wrf
</PRE>

<!--==================================================================-->
<!--Note to authors. The first row of the table is different.         -->

<A NAME="Interface"></A>
<BR><HR><BR>
<H2>PUBLIC INTERFACE</H2>

<TABLE>
<TR><TD><em class=call>use module_mod, only : </em></TD>
                   <TD><A HREF="#get_model_size">get_model_size</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#adv_1step">adv_1step</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_state_meta_data">get_state_meta_data</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#model_interpolate">model_interpolate</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_model_time_step">get_model_time_step</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#end_model">end_model</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#static_init_model">static_init_model</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#init_time">init_time</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#init_conditions">init_conditions</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#nc_write_model_atts">nc_write_model_atts</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#nc_write_model_vars">nc_write_model_vars</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#pert_model_state">pert_model_state</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_close_maxdist_init">get_close_maxdist_init</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_close_obs_init">get_close_obs_init</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_close_obs">get_close_obs</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#ens_mean_for_model">ens_mean_for_model</A></TD></TR>
<TR><TD>The following are also public routines</TD><TD>&nbsp;</TD></TR>
<TR><TD>but are not used by DART code.</TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_pblh">get_pblh</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#pert_params_time">pert_params_time</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#adjust_param_spread">adjust_param_spread</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#real_obs_period">real_obs_period</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#start_real_obs">start_real_obs</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#synchronize_mavail">synchronize_mavail</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#ok_to_nudge">ok_to_nudge</A></TD></TR>
</TABLE>

<H3 class=indent1>NOTES</H3>

<P>
Optional namelist interface <em class=code>&#38;model_nml</em> 
may be read from file <em class=file>input.nml </em> 
</P>

<!--==================================================================-->
<!-- Declare all public entities ...                                  -->
<!-- duplicate public routines template as many times as necessary    -->
<!-- make sure you replace all yyyroutine?? strings                   -->
<!--==================================================================-->

<A NAME="PublicEntities"></A>
<BR><HR><BR>
<H2>PUBLIC COMPONENTS</H2>
<P>fill in text here
</P>

<!--================================================================-->
<!--============= DESCRIPTION OF A FUNCTION ========================-->
 <A NAME="get_model_size"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> var = get_model_size() </em>
 <pre>
 integer :: <em class=code>get_model_size</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
 Returns the size of the model as an integer.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>get_model_size&nbsp; &nbsp; </em></TD>
     <TD>The size of the model state vector.</TD></TR>
 </TABLE>
 <BR>

<!--=================================================================-->
<!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="adv_1step"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call adv_1step(x,time) </em>
 <pre>
 real(r8), dimension(:), intent(inout) :: <em class=code>x</em>
 type(time_type), intent(in)           :: <em class=code>time</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Does a single timestep advance of the model. The input value of
the vector x is the starting condition and x is updated to reflect
the changed state after a timestep. The time argument is intent
in and is used for models that need to know the date/time to
compute a timestep, for instance for radiation computations.
This interface is only called if the namelist parameter
async is set to 0 in perfect_model_obs of filter or if the
program integrate_model is to be used to advance the model
state as a separate executable.
In this model this is a call to code in wrf.F .
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>x&nbsp; &nbsp; </em></TD>
     <TD>Input state vector that is returned at the next timestep.</TD></TR>
 <TR><TD valign=top><em class=code>time&nbsp; &nbsp; </em></TD>
      <TD>Initial time of the model state that is returned at the 
	  advanced time.</TD></TR>
 </TABLE>
 <BR>

<!--=================================================================-->
<!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="get_state_meta_data"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call get_state_meta_data(index_in,location,var_type) </em>
 <pre>
 integer, intent(in)              :: <em class=code>index_in</em>
 type(location_type), intent(out) :: <em class=code>location</em>
 integer, optional, intent(out)   :: <em class=code>var_type</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Given an integer index into the state vector structure, returns the
associated location. A second intent(out) optional argument kind
can be returned if the model has more than one type of field (which
is true in this model.)
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>index_in&nbsp; &nbsp; </em></TD>
     <TD>Index of state vector element about which information is requested.</TD
 ></TR>
 <TR><TD valign=top><em class=code>location&nbsp; &nbsp; </em></TD>
     <TD>The location of state variable element.</TD></TR>
 <TR><TD valign=top><em class=code>var_type&nbsp; &nbsp; </em></TD>
     <TD>The type of the state variable element.</TD></TR>
 </TABLE>
 <BR>

<!--=================================================================-->
<!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="model_interpolate"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call model_interpolate(x,location,itype,obs_val,istatus) </em>
 <pre>
 real(r8), dimension(:), intent(in) :: <em class=code>x</em>
 type(location_type), intent(in)    :: <em class=code>location</em>
 integer, intent(in)                :: <em class=code>itype</em>
 real(r8), intent(out)              :: <em class=code>obs_val</em>
 integer, intent(out)               :: <em class=code>istatus</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Given a state vector, a location, and a model state variable type,
interpolates the state variable field to that location and returns 
the value in obs_val. The istatus variable should be returned as
0 unless there is some problem in computing the interpolation in
which case an alternate value should be returned. The itype variable
is a model specific integer that specifies the type of field
(of which there are many in this model).
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>x&nbsp; &nbsp; </em></TD>
     <TD>A model state vector.</TD></TR>
 <TR><TD valign=top><em class=code>location&nbsp; &nbsp; </em></TD>
     <TD>Location to which to interpolate.</TD></TR>
 <TR><TD valign=top><em class=code>itype&nbsp; &nbsp; </em></TD>
     <TD>Type of state field to be interpolated.</TD></TR>
 <TR><TD valign=top><em class=code>obs_val&nbsp; &nbsp; </em></TD>
     <TD>The returned interpolated value.</TD></TR>
 <TR><TD valign=top><em class=code>istatus&nbsp; &nbsp; </em></TD>
     <TD>Integer value returning 0 for successful, other values can 
     be defined for various failures.</TD></TR>
 </TABLE>
 <BR>

<!--================================================================-->
<!--============= DESCRIPTION OF A FUNCTION ========================-->
 <A NAME="get_model_time_step"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> var = get_model_time_step() </em>
 <pre>
 type(time_type) :: <em class=code>get_model_time_step</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Returns the the time step of the model.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>get_model_time_step&nbsp; &nbsp; </em></TD>
     <TD>Time step of model.</TD></TR>
 </TABLE>
 <BR>

<!--=================================================================-->
<!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="end_model"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call end_model() </em>
 <pre>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
A NULL INTERFACE (stub) in this model at this point.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 </TABLE>
 <BR>
 
<!--=================================================================-->
<!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="static_init_model"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call static_init_model() </em>
 <pre>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Called to do one time initialization of the model. 
Reads the namelist, initializes random sequences,
sets up many local derived types with sizes and info
about the WRF data, allocates space and fills it in.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 </TABLE>
 <BR>

<!--=================================================================-->
<!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="init_time"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call init_time(time) </em>
 <pre>
 type(time_type), intent(out) :: <em class=code>time</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Sets starting time based on namelist values.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>time&nbsp; &nbsp; </em></TD>
     <TD>Initial model time.</TD></TR>
 </TABLE>
 <BR>

<!--=================================================================-->
<!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="init_conditions"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call init_conditions(x) </em>
 <pre>
 real(r8), dimension(:), intent(out) :: <em class=code>x</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Returns a model state vector, x, that is some sort of appropriate
initial condition for starting up a long integration of the model.
Most of the work in this model is done by calling the
init_wrf() subroutine from the WRF module.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>x&nbsp; &nbsp; </em></TD>
     <TD>Initial conditions for state vector.</TD></TR>
 </TABLE>
 <BR>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A FUNCTION ========================-->
 <A NAME="nc_write_model_atts"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> var = nc_write_model_atts(ncFileID) </em>
 <pre>
 integer             :: <em class=code>nc_write_model_atts</em>
 integer, intent(in) :: <em class=code>ncFileID</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
 Writes the model-specific attributes to a netCDF file.
</P>
<P>
 Typical sequence for adding new dimensions,variables,attributes:
<pre>
 NF90_OPEN             ! open existing netCDF dataset           
    NF90_redef         ! put into define mode                  
    NF90_def_dim       ! define additional dimensions (if any)
    NF90_def_var       ! define variables: from name, type, and dims
    NF90_put_att       ! assign attribute values             
 NF90_ENDDEF           ! end definitions: leave define mode 
    NF90_put_var       ! provide values for variable         
 NF90_CLOSE            ! close: save updated netCDF dataset  
</pre>
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>nc_write_model_atts&nbsp; &nbsp; </em></TD>
     <TD>Returns a 0 for successful completion.</TD></TR>
 <TR><TD valign=top><em class=code>ncFileID&nbsp; &nbsp; </em></TD>
     <TD>netCDF file identifier.</TD></TR>
 </TABLE>
 <BR>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A FUNCTION ========================-->
 <A NAME="nc_write_model_vars"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> var = nc_write_model_vars(ncFileID, statevec, copyindex, timeindex)</em>
 <pre>
 integer                            :: <em class=code>nc_write_model_vars</em>
 integer, intent(in)                :: <em class=code>ncFileID</em>
 real(r8), dimension(:), intent(in) :: <em class=code>statevec</em>
 integer, intent(in)                :: <em class=code>copyindex</em>
 integer, intent(in)                :: <em class=code>timeindex</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
 Writes the model variables to a netCDF file.
<P>
 Typical sequence for adding new dimensions,variables,attributes:
<pre>
 NF90_OPEN             ! open existing netCDF dataset           
    NF90_redef         ! put into define mode                  
    NF90_def_dim       ! define additional dimensions (if any)
    NF90_def_var       ! define variables: from name, type, and dims
    NF90_put_att       ! assign attribute values             
 NF90_ENDDEF           ! end definitions: leave define mode 
    NF90_put_var       ! provide values for variable         
 NF90_CLOSE            ! close: save updated netCDF dataset  
</pre>
</P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>nc_write_model_vars&nbsp; &nbsp; </em></TD>
     <TD>Returns 0 for normal completion.</TD></TR>
 <TR><TD valign=top><em class=code>ncFileID&nbsp; &nbsp; </em></TD>
     <TD>NetCDF file id.</TD></TR>
 <TR><TD valign=top><em class=code>statevec&nbsp; &nbsp; </em></TD>
     <TD>A model state vector.</TD></TR>
 <TR><TD valign=top><em class=code>copyindex&nbsp; &nbsp; </em></TD>
     <TD>Which copy of state in output file is being written</TD></TR>
 <TR><TD valign=top><em class=code>timeindex&nbsp; &nbsp; </em></TD>
     <TD>What time level of output is this.</TD></TR>
 </TABLE>
 <BR>

<!--=================================================================-->
<!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="pert_model_state"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call pert_model_state(state, pert_state, interf_provided) </em>
 <pre>
 real(r8), dimension(:), intent(in)  :: <em class=code>state</em>
 real(r8), dimension(:), intent(out) :: <em class=code>pert_state</em>
 logical, intent(out)                :: <em class=code>interf_provided</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Given a model state vector, perturbs this vector. Used to generate initial
conditions for spinning up ensembles. 
This model calls init_conditions() to generate
a perturbed state.  
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>state&nbsp; &nbsp; </em></TD>
     <TD>State vector to be perturbed.</TD></TR>
 <TR><TD valign=top><em class=code>pert_state&nbsp; &nbsp; </em></TD>
     <TD>Perturbed state vector</TD></TR>
 <TR><TD valign=top><em class=code>interf_provided&nbsp; &nbsp; </em></TD>
     <TD>Returned true from this model</TD
 ></TR>
 </TABLE>
 <BR>

<!--=================================================================-->
<!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="get_close_maxdist_init"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call get_close_maxdist_init(gc, maxdist) </em>
 <pre>
 type(get_close_type), intent(inout) :: <em class=code>gc</em>
 real(r8),             intent(in)    :: <em class=code>maxdist</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Pass-through to the 3-D sphere locations module. See
<A HREF="../../location/threed-sphere/location_mod.html#get_close_maxdist_init">
get_close_maxdist_init()</A> for the documentation of this subroutine.

<!--=================================================================-->
<!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="get_close_obs_init"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call get_close_obs_init(gc, num, obs) </em>
 <pre>
 type(get_close_type), intent(inout) :: <em class=code>gc</em>
 integer,              intent(in)    :: <em class=code>num</em>
 type(location_type),  intent(in)    :: <em class=code>obs(num)</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Pass-through to the 3-D sphere locations module. See
<A HREF="../../location/threed-sphere/location_mod.html#get_close_obs_init">
get_close_obs_init()</A> for the documentation of this subroutine.

<!--=================================================================-->
<!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="get_close_obs"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call get_close_obs(gc, base_obs_loc, base_obs_kind, 
   obs, obs_kind, num_close, close_ind
   <em class=code>[, dist]</em>) </em>
 <pre>
 type(get_close_type), intent(in)  :: <em class=code>gc</em>
 type(location_type),  intent(in)  :: <em class=code>base_obs_loc</em>
 integer,              intent(in)  :: <em class=code>base_obs_kind</em>
 type(location_type),  intent(in)  :: <em class=code>obs(:)</em>
 integer,              intent(in)  :: <em class=code>obs_kind(:)</em>
 integer,              intent(out) :: <em class=code>num_close</em>
 integer,              intent(out) :: <em class=code>close_ind(:)</em>
 real(r8), optional,   intent(out) :: <em class=optionalcode>dist(:)</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Pass-through to the 3-D sphere locations module. See
<A HREF="../../location/threed-sphere/location_mod.html#get_close_obs">
get_close_obs()</A> for the documentation of this subroutine.

<!--=================================================================-->
<!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="ens_mean_for_model"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call ens_mean_for_model(ens_mean) </em>
 <pre>
 real(r8), dimension(:), intent(in)  :: <em class=code>ens_mean</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
A NULL INTERFACE in this model.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>ens_mean&nbsp; &nbsp; </em></TD>
     <TD>Ensemble mean state vector</TD></TR>
 </TABLE>
 <BR>

<!--================================================================-->
<!--============= DESCRIPTION OF A FUNCTION ========================-->
 <A NAME="get_pblh"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> var = get_pblh(x) </em>
 <pre>
 real(r8)              :: <em class=code>get_pblh</em>
 real(r8), intent(in)  :: <em class=code>x(:)</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Get diagnosed PBL height.
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>var&nbsp; &nbsp; </em></TD>
     <TD>Diagnosed PBL height.</TD></TR>
 <TR><TD valign=top><em class=code>x&nbsp; &nbsp; </em></TD>
     <TD>State vector</TD></TR>
 </TABLE>
 <BR>

<!--=================================================================-->
<!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="pert_params_time"></A>
<div class=routine>
 <em class=call> subroutine pert_params_time(x) </em>
 <pre>
   real(r8), intent(inout)  :: x(:)
</pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Adds a little noise to any stochastic parameters.
This is separate in case we want a different distribution from the
initial perturbations.
 </P>

<!--=================================================================-->
<!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="adjust_param_spread"></A>
<div class=routine>
 <em class=call> subroutine adjust_param_spread(ens, nens) </em>
 <pre>
   integer, intent(in) :: nens
   real(r8), intent(inout) :: ens(:,:)
</pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Given the ensemble, find the parameters and adjust the spread to the initial
values IF IT IS LESS.  In other words, this is only a lower bound.
 </P>

<!--=================================================================-->
<!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="synchronize_mavail"></A>
<div class=routine>
 <em class=call> subroutine synchronize_mavail(obs, ens, ens_size, 
                 domain_size) </em>
 <pre>
   integer,                  intent(in)    :: ens_size, domain_size
   real(r8),                 intent(in)    :: obs
   real(r8), dimension(ens_size,domain_size), intent(inout) :: ens
</pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Argument ens is dimension(n_ensemble,n_state).  Want to either update
them all independently (they are all being nudged) or pick the first one.
 </P>


<!--================================================================-->
<!--============= DESCRIPTION OF A FUNCTION ========================-->
 <A NAME="ok_to_nudge"></A>
<div class=routine>
 <em class=call> function ok_to_nudge(obs_kind,state_index) </em>
 <pre>
   integer, intent(in)  :: obs_kind, state_index
   logical              :: ok_to_nudge
</pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Checks for physical quantity consistency between obs and state.
 </P>

<!--=================================================================-->
<!--============= DESCRIPTION OF A VARIABLE =========================-->
 <A NAME="real_obs_period"></A>
<div class=routine>
 <em class=call> integer                :: real_obs_period = 1800 </em>
 </div>
 <H3 class=indent1>Description</H3>
 <P>
Public variable.
 </P>


<!--=================================================================-->
<!--============= DESCRIPTION OF A VARIABLE =========================-->
 <A NAME="start_real_obs"></A>
<div class=routine>
 <em class=call> integer                :: start_real_obs  = 1800 </em>
 </div>
 <H3 class=indent1>Description</H3>
 <P>
Public variable.
 </P>


<!--=================================================================-->
<!--============== DESCRIPTION OF A NAMELIST ========================-->
 <A NAME="Namelist"></A>
 <BR><HR><BR>
 <H2>NAMELIST</H2>
 <P>We adhere to the F90 standard of starting a namelist with an ampersand
 '&338;' and terminating with a slash '/'.
 <div class=namelist><pre>
 <em class=call>namelist / model_nml / </em>  &#38;
         num_est_params, est_param_types, pert_param_sd, &#38;
         pert_init_sd, pert_init_beta_1, pert_init_beta_2, &#38;
         maintain_initial_spread, dist_shape, pert_param_min, &#38;
         pert_param_max, real_obs_period, start_real_obs
 </pre></div>
 <H3 class=indent1>Discussion</H3>
 <P>
Need descriptions here (in table form).
 </em>
 </P>
 <P>This namelist is read from the file <em class=file>input.nml</em>
 </P>
 <BR>

<!--==================================================================-->
<!-- Describe the Files Used by this module.                          -->
<!--==================================================================-->

<A NAME="FilesUsed"></A>
<BR><HR><BR>
<H2>FILES</H2>
<UL><LI> Models are free to read and write files as they see fit.
</UL>

<!--==================================================================-->
<!-- Cite references, if need be.                                     -->
<!--==================================================================-->

<A NAME="References"></A>
<BR><HR><BR>
<H2>REFERENCES</H2>

<!--==================================================================-->
<!-- Describe all the error conditions and codes.                     -->
<!-- Putting a <BR> after the synopsis creates a nice effect.         -->
<!--==================================================================-->

<A NAME="Errors"></A>
<HR>
<H2>ERROR CODES and CONDITIONS</H2>
<BR><HR><BR>
<UL><LI> Models are free to issue calls to the error handler as they see
fit. No standard error handler calls are mandated.
</UL>

<!--==================================================================-->
<!-- Describe the bugs.                                               -->
<!--==================================================================-->

<A NAME="KnownBugs"></A>
<BR><HR><BR>
<H2>KNOWN BUGS</H2>
<P>
1.  The model cannot successfully use existing initial conditions.  Make sure start_from_restart = .false. at all times.</P>
<P>
2.  If you want to try some parameter estimation experiments, you must become familiar with the gen_init external utility to create a filter_ics file with the proper state size.
</P>
<P>
3.  Ideal runs (gen_init=.FALSE.) may not work for the MYJ schemes.  This will be corrected shortly.
</P>

<!--==================================================================-->
<!-- Descibe Future Plans.                                            -->
<!--==================================================================-->

<A NAME="FuturePlans"></A>
<BR><HR><BR>
<H2>FUTURE PLANS</H2>
<P>
It is likely that a number of additional optional interfaces will be
added to the model_mod structure. For instance, hints about how to 
divide the state vector into regions for parallel assimilation will
need to be obtained from the model. It is planned that the interf_provided
mechanism used in pert_model_state will allow those who do not wish
to support enhanced interfaces to add NULL interfaces by simply 
pasting in an interface block.
</P>

<!--==================================================================-->
<!-- Have not fleshed out this part yet ... ha ha ha                  -->
<!--==================================================================-->

<!--==================================================================-->

<HR>
</BODY>
</HTML>
