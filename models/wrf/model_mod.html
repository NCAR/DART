<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
          "http://www.w3.org/TR/html4/strict.dtd">
<HTML>
<HEAD>
<TITLE>module model_mod (wrf)</TITLE>
<link rel="stylesheet" type="text/css" href="../../doc/html/doc.css" />
</HEAD>
<BODY>
<A NAME="TOP"></A>

<H1>MODULE model_mod (WRF)</H1>

<table border=0 summary="" cellpadding=5>
<tr>
    <td valign=middle>
    <img src="../../doc/html/Dartboard9.png" alt="DART project logo" height=70 />
    </td>
    <td>
       <P>Jump to <a href="../../index.html">DART Documentation Main Index</a><br />
          <small><small>version information for this file: <br />
          <!-- version tag follows, do not edit -->
          $Id$</small></small>
       </P></td>
</tr>
</table>

<A HREF="#Namelist">NAMELIST</A> /
<A HREF="#Interface">INTERFACES</A> /
<A HREF="#FilesUsed">FILES</A> /
<A HREF="#References">REFERENCES</A> /
<A HREF="#Errors">ERRORS</A> /
<A HREF="#FuturePlans">PLANS</A> /
<A HREF="#PrivateComponents">PRIVATE COMPONENTS</A> /
<A HREF="#Legalese">TERMS OF USE</A>

<H2>Overview</H2>

<P>
DART interface module for the WRF model.   There is extensive documentation
for running a WRF/DART assimilation on the 
<a href="https://wiki.ucar.edu/display/DARTusers/DART+Users+Home+Page">DART Wiki</a>.  
Send email to
<a href="mailto:dart@ucar.edu">dart@ucar.edu</a> to get added to the access list.
</P>
<P>
The WRF model_mod reads a <em class=file>wrfinput_d01</em>
file to get WRF grid and surface elevation information.  The actual state
data is read from a filter initial condition/restart file (typically
called 'filter_ics' or 'filter_restart') but the WRF input NetCDF file
in the current directory must match the configuration used when generating
the IC files.   See the <a href="WRF_DART_utilities/dart_to_wrf.html">wrf_to_dart</a>
documentation for more information on how to generate DART IC/restart files
given WRF NetCDF files.
</P>
<P>The 17 public interfaces
are standardized for all DART compliant models. These interfaces allow
DART to advance the model, get the model state and metadata describing 
this state, find state variables that are close to a given location, 
and do spatial interpolation for a variety of variables required in
observational operators.
</P>

<!--==================== DESCRIPTION OF A NAMELIST =====================-->

<A NAME="Namelist"></A>
<HR>
<H2>NAMELIST</H2>
<P>We adhere to the F90 standard of starting a namelist with an ampersand
'&amp;' and terminating with a slash '/' for all our namelist input.
The declarations have a different syntax, naturally.
</P>
<div class=namelist>
<pre>
<em class=call>namelist / model_nml / </em>                          &amp;
   default_state_variables, wrf_state_variables, wrf_state_bounds,   &amp;
   output_state_vector, num_domains, calendar_type,                  &amp;
   assimilation_period_seconds, allow_obs_below_vol,                 &amp;
   vert_localization_coord, sfc_elev_max_diff,                       &amp;
   polar, periodic_x, periodic_y, scm,                               &amp;
   center_search_half_length, center_spline_grid_scale,              &amp;
   circulation_pres_level, circulation_radius,                       &amp;
   adv_mod_command, num_moist_vars, surf_obs, soil_data, h_diab
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
This namelist is read in a file called <em class=file>input.nml</em>
</P>

<TABLE border=0 cellpadding=3 width=100%>
<TR><TH align=left>Contents    </TH>
    <TH align=left>Type        </TH>
    <TH align=left>Description </TH></TR>

<TR><!--contents--><TD valign=top>default_state_variables      </TD>
    <!--  type  --><TD valign=top>logical                      </TD>
    <!--descript--><TD>If .true., the dart state vector contains
    the fields U, V, W, PH, T, MU, in that order, and only those.
    Any values listed in the wrf_state_variables namelist item will
    be ignored.  Defaults to .true.</TD></TR>

<TR><!--contents--><TD valign=top>wrf_state_variables      </TD>
    <!--  type  --><TD valign=top>character(:, 5)          </TD>
    <!--descript--><TD>A 2D array of strings, 5 per wrf array
    to be added to the dart state vector.  If default_state_variables
    is .true., this is ignored.  When .false., this list of array
    names controls which arrays and the order that they are added
    to the state vector.  The 5 strings are:  
    <OL> <LI>WRF field name - must match netcdf name exactly</LI>
         <LI>DART KIND name - must match a valid DART KIND_xxx exactly</LI>
         <LI>TYPE_NN - will hopefully be obsolete, but for now NN 
             should match the field name. </LI>
         <LI>the string UPDATE.  at some future point, non-updatable
             fields may become part of the state vector. </LI>
         <LI>A numeric string listing the domain numbers this array
             is part of.  The specical string 999 means all domains.
             For example, '12' means domains 1 and 2, '13' means 1 and 3.</LI>
   </OL>
    No defaults.  All fields must be listed explicitly.</TD></TR>

<TR><!--contents--><TD valign=top>wrf_state_bounds      </TD>
    <!--  type  --><TD valign=top>character(:, 4)          </TD>
    <!--descript--><TD>A 2D array of strings, 4 per wrf array.
    During the copy of data to and from the wrf netcdf file,
    variables listed here will have minimum and maximum values
    enforced.  The 4 strings are:  
    <OL> <LI>WRF field name - must match netcdf name exactly</LI>
         <LI>Minimum -- specified as a string but must be a numeric value
             (e.g. '0.1')  Can be 'NULL' to allow any minimum value.</LI>
         <LI>Maximum -- specified as a string but must be a numeric value
             (e.g. '0.1')  Can be 'NULL' to allow any maximum value.</LI>
         <LI>Action -- valid strings are 'CLAMP', 'FAIL'.  'FAIL' means if
             a value is found outside the range, the code fails with an error.
             'CLAMP' simply sets the out of range values to the given minimum
             or maximum without error.</LI>
   </OL>
    No defaults.  All fields must be listed explicitly.</TD></TR>

<TR><!--contents--><TD valign=top>output_state_vector          </TD>
    <!--  type  --><TD valign=top>logical                      </TD>
    <!--descript--><TD>Controls the output to netCDF files. If .true., 
    output the raw dart state vector. Otherwise, output the prognostic 
    flavor (gridded data) for easier plotting (recommended).
    Defaults to false</TD></TR>

<TR><!--contents--><TD valign=top>num_domains                  </TD>
    <!--  type  --><TD valign=top>integer                      </TD>
    <!--descript--><TD>Total number of WRF domains, including the
    nest. Defaults to 1</TD></TR>

<TR><!--contents--><TD valign=top>calendar_type                </TD>
    <!--  type  --><TD valign=top>integer                      </TD>
    <!--descript--><TD>Calendar type. We recommend (GREGORIAN = 3) for
    WRF, which is the default.</TD></TR>

<TR><!--contents--><TD valign=top>assimilation_period_seconds  </TD>
    <!--  type  --><TD valign=top>integer                      </TD>
    <!--descript--><TD>The time (in seconds) between assimilations. 
                       This is modified if necessary to be an integer 
		       multiple of the underlying model timestep.
                       Default is 21600 (6 hours)</TD></TR>
    
<TR><!--contents--><TD valign=top>periodic_x                 </TD>
    <!--  type  --><TD valign=top>logical                    </TD>
    <!--descript--><TD>If .true., the grid is periodic in
    longitude, and points above the last grid cell and points
    below the first grid cell are wrapped.  Note this is not
    the same as a grid which crosses the prime meridian.  WRF
    handles that with an offset in longitude and points beyond
    the last grid index are outside the domain.  The default
    is .false.</TD></TR>

<TR><!--contents--><TD valign=top>periodic_y                 </TD>
    <!--  type  --><TD valign=top>logical                    </TD>
    <!--descript--><TD>Used for the Single Column Model to make
    the grid wrap in Y (see scm below).  This is NOT the same as 
    wrapping in latitude (see polar below).  The default is .false.</TD></TR>

<TR><!--contents--><TD valign=top>polar                      </TD>
    <!--  type  --><TD valign=top>logical                    </TD>
    <!--descript--><TD>If .true., points at the poles are 
    wrapped across the grid. It is not clear this is a good idea
    since the grid is degnerate here. The default is .false.</TD></TR>

<TR><!--contents--><TD valign=top>scm                        </TD>
    <!--  type  --><TD valign=top>logical                    </TD>
    <!--descript--><TD>If .true., the Single Column Model is
    assumed.  The grid is a single vertical column, and there
    are 9 cells arranged in a 3x3 grid.  See the WRF documentation
    for more information on this configuration.  periodic_x
    and periodic_y should also be .true. in this case.
    The default is .false.</TD></TR>

<TR><!--contents--><TD valign=top>sfc_elev_max_diff           </TD>
    <!--  type  --><TD valign=top>real(r8)                    </TD>
    <!--descript--><TD>If > 0, the maximum difference, in meters,
    between an observation marked as a 'surface obs' as the vertical
    type (with the surface elevation, in meters, as the numerical
    vertical location), and the surface elevation as defined by the
    model.  Observations further away from the surface than this
    threshold are rejected and not assimilated.   If the value is
    negative, this test is skipped.  The default value is -1.0.
    The default is .false.</TD></TR>

<TR><!--contents--><TD valign=top>allow_obs_below_vol          </TD>
    <!--  type  --><TD valign=top>logical                      </TD>
    <!--descript--><TD>If an observation with a vertical coordinate of
            pressure or height (e.g. not one marked as a surface observation)
            is below the lowest 3d sigma level, it is outside the
            volume and the interpolation routine marks it as invalid.
            If this is set to .true. and the observation is above the surface
            elevation but below the lowest volume level, the code will
            extrapolate downward from data values at levels 1 and 2.  
	    Defaults to .false.</TD></TR>

<TR><!--contents--><TD valign=top>center_search_half_length    </TD>
    <!--  type  --><TD valign=top>real(r8)                     </TD>
    <!--descript--><TD>The model_mod now contains two schemes for
          searching for a vortex center location.  If the old scheme
          is compiled in, then this and the center_spline_grid_scale
          namelist items are used. (Search code for 'use_old_vortex'.)
          Half length (in meters) of a square box for searching 
          the vortex center.  Default is 500000.0</TD></TR>
    
<TR><!--contents--><TD valign=top>center_spline_grid_scale  </TD>
    <!--  type  --><TD valign=top>integer                   </TD>
    <!--descript--><TD>The model_mod now contains two schemes for
          searching for a vortex center location.  If the old scheme
          is compiled in, then this and the center_search_half_length
          namelist items are used.  (Search code for 'use_old_vortex'.)
          Ratio of refining grid for spline-interpolation in 
          determining the vortex center.  Default is 10</TD></TR>
    
<TR><!--contents--><TD valign=top>circulation_pres_level  </TD>
    <!--  type  --><TD valign=top>real(r8)                </TD>
    <!--descript--><TD>The model_mod now contains two schemes for
          searching for a vortex center location.  If the new scheme
          is compiled in, then this and the circulation_radius
          namelist items are used.   (Search code for 'use_old_vortex'.)
          Pressure, in pascals, of the level at which the circulation
          is computed when searching for the vortex center.  
          Default is 80000.0</TD></TR>
    
<TR><!--contents--><TD valign=top>circulation_radius  </TD>
    <!--  type  --><TD valign=top>real(r8)                </TD>
    <!--descript--><TD>The model_mod now contains two schemes for
          searching for a vortex center location.  If the new scheme
          is compiled in, then this and the circulation_pres_level
          namelist items are used.    (Search code for 'use_old_vortex'.)
          Radius, in meters, of the circle over which the circulation
          calculation is done when searching for the vortex center.
          Default is 108000.0</TD></TR>
    
<TR><!--contents--><TD valign=top>vert_localization_coord  </TD>
    <!--  type  --><TD valign=top>integer                   </TD>
    <!--descript--><TD>Vertical coordinate for vertical localization [1...3]
                       1 = model level,  2 = pressure,  3 = height.  
                       Default is 3</TD></TR>
    
<TR><!--contents--><TD valign=top>surf_obs                     </TD>
    <!--  type  --><TD valign=top>logical                      </TD>
    <!--descript--><TD>DEPRECATED -- has no effect on the code
    and will be removed soon.</TD></TR>

<TR><!--contents--><TD valign=top>soil_data                    </TD>
    <!--  type  --><TD valign=top>logical                      </TD>
    <!--descript--><TD>DEPRECATED -- has no effect on the code 
    and will be removed soon.</TD></TR>

<TR><!--contents--><TD valign=top>h_diab                     </TD>
    <!--  type  --><TD valign=top>logical                      </TD>
    <!--descript--><TD>DEPRECATED -- has no effect on the code 
    and will be removed soon.</TD></TR>

<TR><!--contents--><TD valign=top>num_moist_vars               </TD>
    <!--  type  --><TD valign=top>integer                      </TD>
    <!--descript--><TD>DEPRECATED -- has no effect on the code 
    and will be removed soon.</TD></TR>

<TR><!--contents--><TD valign=top>adv_mod_command              </TD>
    <!--  type  --><TD valign=top>character(len=32)            </TD>
    <!--descript--><TD>DEPRECATED -- A variable with the same name
    has moved to the 
    <a href=WRF_DART_utilities/dart_to_wrf.html#Namelist>&amp;dart_to_wrf</a>
    namelist and does the same function from there.  
    This one has no effect on the code and will be 
    removed soon. (Old description: For single-threaded, set to 'wrf.exe'. 
    For MPI, supports nesting, set to something like, for example, 
    'mpirun -np number-of-prcessors wrf.exe'.)  </TD></TR>

</TABLE>

</div>
<br>

<!--==================================================================-->

<A NAME="Interface"></A>
<HR>
<H2>OTHER MODULES USED</H2>
<PRE>
types_mod
time_manager_mod
threed_sphere/location_mod
utilities_mod
obs_kind_mod
map_utils
netcdf
typesizes
</PRE>

<!--==================================================================-->
<!-- Declare all public entities ...                                  -->
<!-- duplicate public routines template as many times as necessary    -->
<!-- make sure you replace all yyyroutine?? strings                   -->
<!--==================================================================-->
<!--Note to authors. The first row of the table is different.         -->
<!--==================================================================-->

<HR>
<H2>PUBLIC INTERFACES</H2>

<TABLE>
<TR><TD><em class=call>use model_mod, only : </em></TD>
                   <TD><A HREF="#get_model_size">get_model_size</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_state_meta_data">get_state_meta_data</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#model_interpolate">model_interpolate</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_model_time_step">get_model_time_step</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#static_init_model">static_init_model</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#nc_write_model_atts">nc_write_model_atts</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#nc_write_model_vars">nc_write_model_vars</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#pert_model_state">pert_model_state</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_close_maxdist_init">get_close_maxdist_init</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_close_obs_init">get_close_obs_init</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_close_obs">get_close_obs</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#ens_mean_for_model">ens_mean_for_model</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#adv_1step">adv_1step</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#end_model">end_model</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#init_time">init_time</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#init_conditions">init_conditions</A></TD></TR>
</TABLE>

<P>
The last 4 interfaces are only required for low-order models where advancing
the model can be done by a call to a subroutine. The WRF model only advances by
executing the program wrf.exe. Thus the last 4 interfaces only appear as stubs
in the wrf module.
<br><br>
The interface pert_model_state is presently not provided for WRF. The initial
ensemble has to be generated off-line. If coherent structures are not required,
the filter can generate an ensemble with uncorrelated random Gaussian noise of
0.002. This is of course not appropriate for a model like WRF which has
variables expressed in a wide range of scales. It is thus recommended to
generate the initial ensemble off-line, perhaps with the tools provided in
models/wrf/PERTURB/3DVAR-COVAR.
</P>

<P>
Optional namelist interface
<a href="#Namelist"><em class=code>&amp;model_nml</em></a>
may be read from file <em class=file>input.nml</em>.
</P>

<P>
   A note about documentation style.
   Optional arguments are enclosed in brackets
   <em class=optionalcode>[like this]</em>.
</P>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="get_model_size"></A>
<br>
<div class=routine>
<em class=call>model_size = get_model_size( )</em>
<pre>
integer :: <em class=code>get_model_size</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Returns the length of the model state vector as an integer.
This includes all nested domains.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>model_size</em></TD>
    <TD>The length of the model state vector.</TD></TR>

</TABLE>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="get_state_meta_data"></A>
<br>
<div class=routine>
<em class=call>call get_state_meta_data (index_in, location 
                          <em class=optionalcode>[,&nbsp;var_type_out,&nbsp;id_out]</em> )</em>
<pre>
integer,             intent(in)  :: <em class=code>index_in</em>
type(location_type), intent(out) :: <em class=code>location</em>
integer, optional,   intent(out) :: <em class=optionalcode>var_type_out</em>
integer, optional,   intent(out) :: <em class=optionalcode>id_out</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Returns metadata about a given element, indexed by index_in, in the model 
state vector. The location defines where the state variable is located 
while the type of the variable (for instance temperature, 
or u wind component) is returned by var_type. The integer values used to 
indicate different variable types in var_type are themselves defined as 
public interfaces to model_mod if required.
The last optional argument is the wrf domain identification number - 
obviously this is unique to the WRF version of this <em>required</em> 
routine.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>index_in&nbsp;&nbsp;&nbsp;</em></TD>
    <TD>Index of state vector element about which information is requested.</TD></TR>

<TR><TD valign=top><em class=code>location</em></TD>
    <TD>Returns location of indexed state variable. The location should 
use a location_mod that is appropriate for the model domain. For 
realistic atmospheric models, for instance, a three-dimensional 
spherical location module that can represent height in a variety  
of ways is provided. </TD></TR>

<TR><TD valign=top><em class=optionalcode>var_type_out</em></TD>
    <TD>Returns the type of the indexed state variable as an optional
    argument.</TD></TR>

<TR><TD valign=top><em class=optionalcode>id_out</em></TD>
    <TD>Returns the wrf domain identification number of the indexed state
    variable as an optional argument.</TD></TR>

</TABLE>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="model_interpolate"></A>
<br>
<div class=routine>
<em class=call> call model_interpolate(x, location, obs_kind, obs_val,
istatus)</em>
<pre>
real(r8), dimension(:), intent(in)  :: <em class=code>x</em>
type(location_type),    intent(in)  :: <em class=code>location</em>
integer,                intent(in)  :: <em class=code>obs_kind</em>
real(r8),               intent(out) :: <em class=code>obs_val</em>
integer,                intent(out) :: <em class=code>istatus</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Given model state, returns the value of observation type interpolated to a given 
location by a method of the model's choosing. All observation kinds defined in
obs_kind_mod are supported. In the case where the observational operator is not
defined at the given location (e.g. the observation is below the model surface
or outside the domain), obs_val is returned as -888888.0 and istatus =
1. Otherwise, istatus = 0. The interpolation is performed in the domain with
the highest resolution containing the observation.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>x</em></TD>
    <TD>A model state vector.</TD></TR>

<TR><TD valign=top><em class=code>location&nbsp;&nbsp;&nbsp;</em></TD>
    <TD>Location to which to interpolate.</TD></TR>

<TR><TD valign=top><em class=code>obs_kind</em></TD>
    <TD>Integer indexing which type of observation is to be
    interpolated.</TD></TR>

<TR><TD valign=top><em class=code>obs_val</em></TD>
    <TD> The interpolated value from the model.</TD></TR>

<TR><TD valign=top><em class=code>istatus</em></TD>
    <TD>Integer flag indicating the result of the interpolation.</TD></TR>

</TABLE>

<P>
As of September 9, 2004 the reflectivity observational operator is still not
available (obs_kind = KIND_REF in obs_kind_mod).
</P>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="get_model_time_step"></A>
<br>
<div class=routine>
<em class=call>var = get_model_time_step()</em>
<pre>
type(time_type) :: <em class=code>get_model_time_step</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Returns the model base time step as a time_type. For the model wrf, it returns
the time step used for domain 1 (usually the largest time step among all
domains because domain 1 is the coarser grid). The time step is read from
the wrfinput_d01 file (used to be namelist.input). In the long run, 
a more general extended interface may be required that specifies the models 
range of time stepping possibilities.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>var&nbsp;&nbsp;&nbsp;</em></TD>
    <TD>Smallest time step of model.</TD></TR>

</TABLE>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="static_init_model"></A>
<br>
<div class=routine>
<em class=call>call static_init_model()</em>
</div>

<div class=indent1>
<!-- Description -->

<P>
Used for runtime initialization of the model. This is the first call 
made to the model by any DART compliant assimilation routine. It reads the
model
namelist parameters, set the calendar type (the GREGORIAN calendar is used with
the WRF model), and determine the dart vector length. This subroutine requires
that wrfinput_d01, wrfinput_d02, ... (one file for each domain) be present in
the
working directory to retrieve model information (grid dimensions and spacing,
time step, pressure at the top of the model, map projection parameters, etc).
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>
</TABLE>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="nc_write_model_atts"></A>
<br>
<div class=routine>
<em class=call>ierr = nc_write_model_atts(ncFileID)</em>
<pre>
integer             :: <em class=code>nc_write_model_atts</em>
integer, intent(in) :: <em class=code>ncFileID</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Function to write model specific attributes to a netCDF file. At present, DART 
is using the NetCDF format to output diagnostic information. This is not a 
requirement, and models could choose to provide output in other formats. 
This function writes the metadata associated with the model to a NetCDF file 
opened to a file identified by ncFileID.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>ncFileID&nbsp;&nbsp;&nbsp;</em></TD>
    <TD>Integer file descriptor to previously-opened netCDF file.</TD></TR>

<TR><TD valign=top><em class=code>ierr</em></TD>
    <TD>Returns a 0 for successful completion.</TD></TR>

</TABLE>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="nc_write_model_vars"></A>
<br>
<div class=routine>
<em class=call>ierr = nc_write_model_vars(ncFileID, statevec, copyindex, timeindex)</em>
<pre>
integer                            :: <em class=code>nc_write_model_vars</em>
integer,                intent(in) :: <em class=code>ncFileID</em>
real(r8), dimension(:), intent(in) :: <em class=code>statevec</em>
integer,                intent(in) :: <em class=code>copyindex</em>
integer,                intent(in) :: <em class=code>timeindex</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Writes a copy of the state variables to a netCDF file. Multiple copies
of the state for a given time are supported, allowing, for instance,
a single file to include multiple ensemble estimates of the state.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>ncFileID</em></TD>
    <TD>file descriptor to previously-opened netCDF file.</TD></TR>

<TR><TD valign=top><em class=code>statevec</em></TD>
    <TD>A model state vector.</TD></TR>

<TR><TD valign=top><em class=code>copyindex&nbsp;&nbsp;&nbsp;</em></TD>
    <TD> Integer index of copy to be written.</TD></TR>

<TR><TD valign=top><em class=code>timeindex</em></TD>
    <TD>The timestep counter for the given state.</TD></TR>

<TR><TD valign=top><em class=code>ierr</em></TD>
    <TD>Returns 0 for normal completion.</TD></TR>

</TABLE>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="pert_model_state"></A>
<br>
<div class=routine>
<em class=call>call pert_model_state(state, pert_state, interf_provided)</em>
<pre>
real(r8), dimension(:), intent(in)  :: <em class=code>state</em>
real(r8), dimension(:), intent(out) :: <em class=code>pert_state</em>
logical,                intent(out) :: <em class=code>interf_provided</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Given a model state, produces a perturbed model state. This is used to
generate initial ensemble conditions perturbed around some control
trajectory state when one is preparing to spin-up ensembles. A DART
compliant model can choose not to provide an implementation of this
algorithm and use the default mechanism in DART by simply returning .false.
as a returned value for the interf_provided argument. In this case, DART
perturbs the state to generate ensemble members by adding a random sample
from a N(0.0, 0.002) distribution independently to each state variable.
Models should override this if some structure is required for perturbations
or if the magnitude of perturbations in DART is too large. It is thus
recommended to generate the initial ensemble off-line, perhaps with the
tools provided in models/wrf/PERTURB/3DVAR-COVAR.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>state</em></TD>
    <TD>State vector to be perturbed.</TD></TR>

<TR><TD valign=top><em class=code>pert_state</em></TD>
    <TD>Perturbed state vector is returned. </TD></TR>

<TR><TD valign=top><em class=code>interf_provided&nbsp;&nbsp;&nbsp;</em></TD>
    <TD>Return false to have DART perturb state .</TD></TR>

</TABLE>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="get_close_maxdist_init"></A>
<br>
<div class=routine>
<em class=call>call get_close_maxdist_init(gc, maxdist)</em>
<pre>
type(get_close_type), intent(inout) :: <em class=code>gc</em>
real(r8),             intent(in)    :: <em class=code>maxdist</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Pass-through to the 3-D sphere locations module. See
<A HREF="../../location/threed-sphere/location_mod.html#get_close_maxdist_init">
get_close_maxdist_init()</A> for the documentation of this subroutine.
</P>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="get_close_obs_init"></A>
<br>
<div class=routine>
<em class=call>call get_close_obs_init(gc, num, obs)</em>
<pre>
type(get_close_type), intent(inout) :: <em class=code>gc</em>
integer,              intent(in)    :: <em class=code>num</em>
type(location_type),  intent(in)    :: <em class=code>obs(num)</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Pass-through to the 3-D sphere locations module. See
<A HREF="../../location/threed-sphere/location_mod.html#get_close_obs_init">
get_close_obs_init()</A> for the documentation of this subroutine.
</P>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="get_close_obs"></A>
<br>
<div class=routine>
<em class=call>call get_close_obs(gc, base_obs_loc, base_obs_kind,
  obs, obs_kind, num_close, close_ind
  <em class=optionalcode>[,&nbsp;dist]</em>) </em>
<pre>
type(get_close_type), intent(in)  :: <em class=code>gc</em>
type(location_type),  intent(in)  :: <em class=code>base_obs_loc</em>
integer,              intent(in)  :: <em class=code>base_obs_kind</em>
type(location_type),  intent(in)  :: <em class=code>obs(:)</em>
integer,              intent(in)  :: <em class=code>obs_kind(:)</em>
integer,              intent(out) :: <em class=code>num_close</em>
integer,              intent(out) :: <em class=code>close_ind(:)</em>
real(r8), optional,   intent(out) :: <em class=optionalcode>dist(:)</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Pass-through to the 3-D sphere locations module. See
<A HREF="../../location/threed-sphere/location_mod.html#get_close_obs">
get_close_obs()</A> for the documentation of this subroutine.
</P>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="ens_mean_for_model"></A>
<br>
<div class=routine>
<em class=call>call ens_mean_for_model(ens_mean)</em>
<pre>
real(r8), dimension(:), intent(in) :: <em class=code>ens_mean</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
A local copy is kept and used during other computations in the 
model_mod code.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>ens_mean&nbsp;&nbsp;&nbsp;</em></TD>
    <TD>Ensemble mean state vector</TD></TR>

</TABLE>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="adv_1step"></A>
<br>
<div class=routine>
<em class=call>call adv_1step(x, time)</em>
<pre>
real(r8), dimension(:),   intent(inout) :: <em class=code> x </em>
type(time_type),          intent(in)    :: <em class=code> time </em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
This operation is not defined for the WRF model. 
This interface is only required if `synchronous' model state advance 
is supported (the model is called directly as a Fortran90 subroutine 
from the assimilation programs). This is generally not the preferred 
method for large models and a stub for this interface is provided for the WRF
model.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>x</em></TD>
    <TD>State vector of length model_size.</TD></TR>

<TR><TD valign=top><em class=code>time</em></TD>
    <TD>Gives time of the initial model state. Needed for models that 
have real time state requirements, for instance the computation of 
radiational parameters. Note that DART provides a time_manager_mod 
module that is used to support time computations throughout the
    facility. </TD></TR>

</TABLE>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="end_model"></A>
<br>
<div class=routine>
<em class=call>call end_model( )</em>
</div>

<div class=indent1>
<!-- Description -->

<P>
Called when use of a model is completed to clean up storage, etc. 
A stub is provided for the WRF model.
</P>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="init_time"></A>
<br>
<div class=routine>
<em class=call>call init_time(i_time) </em>
<pre>
type(time_type),        intent(in)  :: <em class=code> i_time </em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Returns the time at which the model will start if 
no input initial conditions are to be used. 
This is frequently used to spin-up models from rest, 
but is not meaningfully supported for the WRF model. 
</P>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="init_conditions"></A>
<br>
<div class=routine>
<em class=call>call init_conditions( x )</em>
<pre>
real(r8), dimension(:), intent(out) :: <em class=code> x </em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Returns default initial conditions for model; generally used for spinning up 
initial model states. For the WRF model just return 0's since initial 
state is always to be provided from input files.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>x</em></TD>
    <TD>Model state vector.</TD></TR>

</TABLE>

</div>
<br>

<!--==================================================================-->
<!-- Describe the Files Used by this module.                          -->
<!--==================================================================-->

<A NAME="FilesUsed"></A>
<HR>
<H2>FILES</H2>
<UL> <LI>model_nml in input.nml
     <LI>wrfinput_d01, wrfinput_d02, ... (one file for each domain)
     <LI>netCDF output state diagnostics files
</UL>

<!--==================================================================-->
<!-- Cite references, if need be.                                     -->
<!--==================================================================-->

<A NAME="References"></A>
<HR>
<H2>REFERENCES</H2>
<a href="http://www.mmm.ucar.edu/wrf/users/docs/user_guide/contents.html">
http://www.mmm.ucar.edu/wrf/users/docs/user_guide/contents.html</a>

<!--==================================================================-->
<!-- Describe all the error conditions and codes.                     -->
<!--==================================================================-->

<A NAME="Errors"></A>
<HR>
<H2>ERROR CODES and CONDITIONS</H2>
<div class=errors>
<TABLE border=1 cellspacing=1 cellpadding=10 width=100%>
<TR><TH>Routine</TH><TH>Message</TH><TH>Comment</TH></TR>
<TR><!-- routine --><TD VALIGN=top>static_init_model <BR>
                                   nc_write_model_vars</TD>
    <!-- message --><TD VALIGN=top>num_moist_vars is too large</TD>
    <!-- comment --><TD VALIGN=top>The maximum number of moist variable in
    WRFV2.1 is 7</TD>
</TR>
<TR><!-- routine --><TD VALIGN=top>static_init_model</TD>
    <!-- message --><TD VALIGN=top>'Please put wrfinput_d0'//idom//' in the
    work directory.'</TD>
    <!-- comment --><TD VALIGN=top>One of the wrfinput_d0# is missing in the
    work directory</TD>
</TR>
<TR><!-- routine --><TD VALIGN=top>static_init_model </TD>
    <!-- message --><TD VALIGN=top>Map projection no supported</TD>
    <!-- comment --><TD VALIGN=top>Try PROJ_LATLON(0), PROJ_LC(1), PROJ_PS(2),
    PROJ_MERC(3)</TD>
</TR>
<TR><!-- routine --><TD VALIGN=top>static_init_model <BR>
                                   nc_write_model_atts <BR>
                                   nc_write_model_vars <BR></TD>
    <!-- message --><TD VALIGN=top>Various NetCDF-f90 interface error
    messages</TD>
    <!-- comment --><TD VALIGN=top>From one of the NetCDF calls in the named
    routine</TD>
</TR>
<TR><!-- routine --><TD VALIGN=top>get_state_meta_data </TD>
    <!-- message --><TD VALIGN=top>dart index out of range</TD>
    <!-- comment --><TD VALIGN=top>Unlikely. Would indicate a serious bug in
    the code</TD>
</TR>
<TR><!-- routine --><TD VALIGN=top>model_interpolate <BR> get_dist_wrf </TD>
    <!-- message --><TD VALIGN=top>wrong option for which_vert</TD>
    <!-- comment --><TD VALIGN=top>See which_vert description in
    location/threed_sphere/location_mod.html </TD>
</TR>
<TR><!-- routine --><TD VALIGN=top>model_interpolate </TD>
    <!-- message --><TD VALIGN=top>'do not recognize obs kind ',obs_kind</TD>
    <!-- comment --><TD VALIGN=top>See list in 'use obs_kind_mod' statement in
    model_mod.f90</TD>
</TR>
<TR><!-- routine --><TD VALIGN=top>get_wrf_index </TD>
    <!-- message --><TD VALIGN=top>'Indices ',i,j,k,' exceed grid dimensions:
    ',#1,#2,#3 </TD>
    <!-- comment --><TD VALIGN=top>One of the grid indices exceeds the
    corresponding dimension for the var_type input. Unlikely to happen but
    would indicate a serious bug in the code</TD>
</TR>
<TR><!-- routine --><TD VALIGN=top>get_dist_wrf </TD>
    <!-- message --><TD VALIGN=top>Unable to define vloc</TD>
    <!-- comment --><TD VALIGN=top>The vertical location is below the model
    surface or above the model lid</TD>
</TR>
<TR><!-- routine --><TD VALIGN=top>nc_write_model_atts</TD>
    <!-- message --><TD VALIGN=top>Time dimension ID # must match Unlimited
    Dimension ID #</TD>
    <!-- comment --><TD VALIGN=top>NetCDF file writing error</TD>
</TR>
<TR><!-- routine --><TD VALIGN=top>read_dt_from_wrf_nml</TD>
    <!-- message --><TD VALIGN=top>Please put namelist.input in the work
    directory</TD>
    <!-- comment --><TD VALIGN=top>The file namelist.input is missing in the
    work directory</TD>
</TR>
<TR><!-- routine --><TD VALIGN=top>read_dt_from_wrf_nml</TD>
    <!-- message --><TD VALIGN=top>'max_dom in namelist.input =
    ',max_dom'num_domains in input.nml  = ',num_domains'Make them
    consistent.'</TD>
    <!-- comment --><TD VALIGN=top>The number of WRF domains in namelist.input
    and in input.nml do not match</TD>
</TR>

</TABLE>
</div>

<H2>KNOWN BUGS</H2>
<P>
Only the Lambert projection (MAP_PROJ = 1) is working. Other map projections
(0=none, 2=polar, 3=Mercator) are likely to break the code.
</P>

<!--==================================================================-->
<!-- Describe Future Plans.                                           -->
<!--==================================================================-->

<A NAME="FuturePlans"></A>
<HR>
<H2>FUTURE PLANS</H2>
<P>
none at this time
</P>

<!--==================================================================-->
<!-- PrivateComponents                                                -->
<!--==================================================================-->

<A NAME="PrivateComponents"></A>
<HR>
<H2>PRIVATE COMPONENTS</H2>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<br>
<div class=routine>
<em class=call> ind = get_wrf_index(i,j,k,var_type,id)</em>
<pre>
integer                               :: <em class=code>get_wrf_index </em>
integer,                  intent(in)  :: <em class=code>i,j,k,var_type,id
</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Given grid indices, variable type, and domain identification number, returns
the index in the model state vector as an integer.
</P>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<br>
<div class=routine>
<em class=call> dist = get_dist_wrf( i, j, k, var_type, o_loc, id, x )</em>
<pre>
real(r8)                              :: <em class=code>get_dist_wrf </em>
integer,                  intent(in)  :: <em class=code>i,j,k,var_type,id
</em>
type(location_type),      intent(in)  :: <em class=code>o_loc </em>
real(r8), dimension(:),   intent(in)  :: <em class=code>x </em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Given grid indices, variable type, and domain identification number, computes
the distance to the observation at location o_loc.
</P>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<br>
<div class=routine>
<em class=call> call get_wrf_horizontal_location( i, j, var_type, id, long, lat
)</em>
<pre>
integer,                  intent(in)  :: <em class=code>i,j,var_type,id </em>
real(r8),                 intent(out) :: <em class=code>long, lat </em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Given horizontal grid indices, variable type, and domain identification number,
returns the longitude and latitude in degrees.
</P>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<br>
<div class=routine>
<em class=call> call toGrid (x, j, dx, dxm)</em>
<pre>
real(r8),                 intent(in)  :: <em class=code>x </em>
real(r8),                 intent(out) :: <em class=code>dx, dxm </em>
integer ,                 intent(out) :: <em class=code>j </em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Given position x, find nearest grid point j (but smaller than or equal to x)
and calculate its distance to grid j and j+1.
</P>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<br>
<div class=routine>
<em class=call> call pres_to_zk(pres, mdl_v, n3, zk)</em>
<pre>
real(r8),                  intent(in)  :: <em class=code>pres </em>
integer                    intent(in)  :: <em class=code>n3 </em>
real(r8), dimension(0:n3), intent(in)  :: <em class=code>mdl_v </em>
real(r8),                  intent(out) :: <em class=code>zk </em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Calculate the position zk on half (mass) levels in the profile mdl_v
corresponding to pressure location pres.
</P>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<br>
<div class=routine>
<em class=call> call height_to_zk(obs_v, mdl_v, n3, zk)</em>
<pre>
real(r8),                  intent(in)  :: <em class=code>obs_v </em>
integer                    intent(in)  :: <em class=code>n3 </em>
real(r8), dimension(0:n3), intent(in)  :: <em class=code>mdl_v </em>
real(r8),                  intent(out) :: <em class=code>zk </em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Calculate the position zk on half (mass) levels in the profile mdl_v
corresponding to height location obs_v.
</P>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<br>
<div class=routine>
<em class=call> call
get_model_pressure_profile(i,j,dx,dy,dxm,dym,n,x,id,v_p)</em>
<pre>
integer                   intent(in)  :: <em class=code>i,j,n,id </em>
real(r8),                 intent(in)  :: <em class=code>dx,dy,dxm,dym </em>
real(r8), dimension(:),   intent(in)  :: <em class=code>x </em>
real(r8), dimension(0:n), intent(out) :: <em class=code>v_p </em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Extract the pressure profile at position (i+dx, j+dy) on the
non-staggered vertical grid (half (mass) levels).
</P>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<br>
<div class=routine>
<em class=call> vloc = model_pressure(i,j,k,id,var_type,x)</em>
<pre>
real(r8),                             :: <em class=code>model_pressure </em>
integer                   intent(in)  :: <em class=code>i,j,k,id,var_type
</em>
real(r8), dimension(:),   intent(in)  :: <em class=code>x </em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Calculate the pressure at grid point (i,j,k), domain id. The grid is defined
according to var_type.
</P>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<br>
<div class=routine>
<em class=call> pres = model_pressure_t(i,j,k,id,x)</em>
<pre>
real(r8)                              :: <em class=code>model_pressure_t </em>
integer                   intent(in)  :: <em class=code>i,j,k,id </em>
real(r8), dimension(:),   intent(in)  :: <em class=code>x </em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Calculate the pressure at grid point (i,j,k), domain id, on mass point (half
(mass) levels, T-point).
</P>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<br>
<div class=routine>
<em class=call> rho = model_rho_t(i,j,k,id,x)</em>
<pre>
real(r8)                              :: <em class=code>model_rho_t </em>
integer                   intent(in)  :: <em class=code>i,j,k,id </em>
real(r8), dimension(:),   intent(in)  :: <em class=code>x </em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Calculate the total density at grid point (i,j,k), domain id, on mass point
(half (mass) levels, T-point).
</P>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<br>
<div class=routine>
<em class=call> call
get_model_height_profile(i,j,dx,dy,dxm,dym,n,x,id,fld)</em>
<pre>
integer                   intent(in)  :: <em class=code>i,j,n,id </em>
real(r8),                 intent(in)  :: <em class=code>dx,dy,dxm,dym </em>
real(r8), dimension(:),   intent(in)  :: <em class=code>x </em>
real(r8), dimension(n),   intent(out) :: <em class=code>fld </em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Extract the height profile at position (i+dx, j+dy) on the
non-staggered vertical grid.
</P>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<br>
<div class=routine>
<em class=call> vloc = model_height(i,j,k,id,var_type,x)</em>
<pre>
real(r8)                              :: <em class=code>model_height</em>
integer                   intent(in)  :: <em class=code>i,j,k,id,var_type</em>
real(r8), dimension(:),   intent(in)  :: <em class=code>x</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Calculate the height at grid point (i,j,k), domain id. The grid is defined
according to var_type.
</P>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<br>
<div class=routine>
<em class=call> call read_dt_from_wrf_nml( )</em>
</div>

<div class=indent1>
<!-- Description -->

<P>
Read the wrf model time step from namelist.input for all domains.
</P>

</div>
<br>

<!--==================================================================-->
<!-- Legalese & Metadata                                              -->
<!--==================================================================-->

<A NAME="Legalese"></A>
<HR>
<H2>Terms of Use</H2>

<P>
DART software - Copyright &#169; 2004 - 2010 UCAR.<br>
This open source software is provided by UCAR, "as is",<br>
without charge, subject to all terms of use at<br>
<a href="http://www.image.ucar.edu/DAReS/DART/DART_download">
http://www.image.ucar.edu/DAReS/DART/DART_download</a>
</P>

<TABLE border=0 cellpadding=0 width=100% summary="">
<TR><TD>Contact:       </TD><TD> Hui Liu, Glen Romine, Chris Synder, David Dowell </TD></TR>
<TR><TD>Revision:      </TD><TD> $Revision$ </TD></TR>
<TR><TD>Source:        </TD><TD> $URL$ </TD></TR>
<TR><TD>Change Date:   </TD><TD> $Date$ </TD></TR>
<TR><TD valign=top>Change&nbsp;history:&nbsp;</TD><TD> try "svn&nbsp;log" or "svn&nbsp;diff" </TD></TR>
</TABLE>

<!--==================================================================-->

</BODY>
</HTML>
