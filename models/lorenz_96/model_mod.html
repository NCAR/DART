<!--
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!                                                                       !!
!!                   GNU General Public License                          !!
!!                                                                       !!
!! This file is part of the Data Assimilation Research Testbed (DART).   !!
!!                                                                       !!
!! DART is free software; you can redistribute it and/or modify          !!
!! it and are expected to follow the terms of the GNU General Public     !!
!! License as published by the Free Software Foundation.                 !!
!!                                                                       !!
!! DART is distributed in the hope that it will be useful,               !!
!! but WITHOUT ANY WARRANTY; without even the implied warranty of        !!
!! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         !!
!! GNU General Public License for more details.                          !!
!!                                                                       !!
!! You should have received a copy of the GNU General Public License     !!
!! along with DART; if not, write to:                                    !!
!!          Free Software Foundation, Inc.                               !!
!!          59 Temple Place, Suite 330                                   !!
!!          Boston, MA  02111-1307  USA                                  !!
!! or see:                                                               !!
!!          http://www.gnu.org/licenses/gpl.txt                          !!
!!                                                                       !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-->

<HTML>
<TITLE>module model_mod (Lorenz_96)</TITLE>
<link rel=stylesheet type=text/css href=../../doc/html/doc.css>
<BODY>

<DIV ALIGN=CENTER>
<A HREF="#Interface">INTERFACE</A> / 
<A HREF="#PublicEntities">PUBLIC COMPONENTS</A> / 
<A HREF="#Namelist">NAMELIST</A> / 
<A HREF="#FilesUsed">FILES</A> /
<A HREF="#References">REFERENCES</A> /
<A HREF="#Errors">ERRORS</A> /
<A HREF="#KnownBugs">BUGS</A> /
<A HREF="#FuturePlans">PLANS</A>
</DIV>

<!--==================================================================-->

<H1>MODULE model_mod (Lorenz_96)</H1>
<A NAME="HEADER"></A>
<TABLE summary="">
   <TR><TD>Contact:       </TD><TD> Jeff Anderson                </TD></TR>
   <TR><TD>Reviewers:     </TD><TD> &nbsp;                       </TD></TR>
   <TR><TD>Revision:      </TD><TD> $Revision$             </TD></TR>
   <TR><TD>Release Name:  </TD><TD> $Name$                       </TD></TR>
   <TR><TD>Change Date:   </TD><TD> $Date$ </TD></TR>
   <TR><TD>Change history:</TD><TD> see CVS log                  </TD></TR>
</TABLE>

<!--==================================================================-->

<A NAME="OVERVIEW"></A>
<HR>
<H2>OVERVIEW</H2>

<P>
DART interface module for the Lorenz-96 model. The 17 public interfaces
are standardized for all DART compliant models. These interfaces allow
DART to advance the model, get the model state and metadata describing 
this state, find state variables that are close to a given location, 
and do spatial interpolation for model state variables.
</P>
<P>
Quoting from the <A HREF="#References"> Lorenz 1998 </A> paper:
<blockquote>
... the authors introduce a model consisting of 40 ordinary differential
equations, with the dependent variables representing values of some
atmospheric quantity at 40 sites spaced equally about a latitude circle. The
equations contain quadratic, linear, and constant terms representing
advection, dissipation, and external forcing. Numerical integration
indicates that small errors (differences between solutions) tend to double
in about 2 days. Localized errors tend to spread eastward as they grow,
encircling the globe after about 14 days.
</blockquote>
</P>
<blockquote>
...
</blockquote>
<P>
<blockquote>
We have chosen a model with J variables, denoted by X<sub>1</sub>, ..., X<sub>J</sub>; 
in most of our experiments we have let J = 40. The governing equations are: <br>
<pre>
dX<sub>j</sub>/dt = (X<sub>j+1</sub> - X<sub>j-2</sub>)X<sub>j-1</sub> - X<sub>j</sub> + F         (1)
</pre>
for <i>j</i> = 1, ..., J. To make Eq. (1) meaningful for all
values of <i>j</i> we define X<sub>-1</sub> = X<sub>J-1</sub>, 
X<sub>0</sub> = X<sub>J</sub>, and X<sub>J+1</sub> = X<sub>1</sub>, so that the
variables form a cyclic chain, and may be looked at as values of some
unspecified scalar meteorological quantity, perhaps vorticity or
temperature, at J equally spaced sites extending around a latitude circle.
Nothing will simulate the atmosphere's latitudinal or vertical extent.
</blockquote>
</P>
<P>
See the <A HREF="#References"> references </A> section for more details.
</P>

<!--==================================================================-->

<A NAME="OTHER MODULES USED"></A>
<BR><HR><BR>
<H2>OTHER MODULES USED</H2>
<PRE>
types_mod
time_manager_mod
oned/location_mod
utilities_mod
</PRE>

<!--==================================================================-->
<!--Note to authors. The first row of the table is different.         -->

<A NAME="Interface"></A>
<BR><HR><BR>
<H2>PUBLIC INTERFACE</H2>

<TABLE>
<TR><TD><em class=call>use model_mod, only : </em></TD>
                   <TD><A HREF="#yyyroutine1">get_model_size</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine2">adv_1step</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine3">get_state_meta_data</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine4">model_interpolate</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine5">get_model_time_step</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine6">end_model</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine7">static_init_model</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine8">init_time</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine9">init_conditions</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine11">nc_write_model_atts</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine12">nc_write_model_vars</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine13">pert_model_state</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_close_maxdist_init">get_close_maxdist_init</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_close_obs_init">get_close_obs_init</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_close_obs">get_close_obs</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#ens_mean_for_model">ens_mean_for_model</A></TD></TR>
</TABLE>

<H3 class=indent1>NOTES</H3>
<P>
Optional namelist interface
<A HREF="#Namelist"> <em class=code>&#38;model_nml</em> </A>
may be read from file <em class=file>input.nml</em>.
</P>


<!--==================================================================-->
<!-- Declare all public entities ...                                  -->
<!-- duplicate public routines template as many times as necessary    -->
<!-- make sure you replace all yyyroutine?? strings                   -->
<!--==================================================================-->

<A NAME="PublicEntities"></A>
<BR><HR><BR>
<H2>PUBLIC COMPONENTS</H2>
<P>
The following routines are public:
</P>

<!--===================== DESCRIPTION OF FUNCTION =====================-->

<A NAME="yyyroutine1"></A>
<P></P><HR><P></P>
<div class=routine>
<em class=call> var = get_model_size( )</em>
<pre>
integer                               :: <em class=code> get_model_size </em>
</pre></div>

<H3 class=indent1>Description</H3>

<P>
Returns the length of the model state vector, which is 
settable by namelist and defaults to 40.
</P>


<!--===================== DESCRIPTION OF SUBROUTINE =====================-->

<A NAME="yyyroutine2"></A>
<P></P><HR><P></P>
<div class=routine>
<em class=call>call adv_1step(x, time)</em>
<pre>
real(r8), dimension(:),   intent(inout) :: <em class=code> x </em>
type(time_type),          intent(in)    :: <em class=code> time </em>
</pre></div>

<H3 class=indent1>Description</H3>

<P>
Advances a model for a single time step.
The time associated with the initial model state is also
input although is it not used in this model.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>x</em></TD>
    <TD>State vector of length model_size</TD></TR>

<TR><TD valign=top><em class=code>time</em></TD>
    <TD>Gives time of the initial model state</TD></TR>

</TABLE>


<!--===================== DESCRIPTION OF SUBROUTINE =====================-->

<A NAME="yyyroutine3"></A>
<P></P><HR><P></P>
<div class=routine>
<em class=call>call get_state_meta_data (index_in, location, 
                          <em class=optionalcode>[,var_type]</em> )</em>
<pre>
integer,                  intent(in)    :: <em class=code> index_in </em>
type(location_type),      intent(out)   :: <em class=code> location </em>
integer, optional,        intent(out)   :: <em class=optionalcode> var_type </em>
</pre></div>

<H3 class=indent1>Description</H3>

<P>
 Returns metadata about a given element, indexed by index_in, in the model 
state vector. The location defines where the state variable is located 
For lorenz-96, variable 1 is at 0.0, variable 2 is at 1/40., variable 3
is at 2/40., etc. on a cyclic [0, 1] domain.  
The variable type is always returned as 1.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>index_in</em></TD>
    <TD>Index into the long state vector.</TD></TR>

<TR><TD valign=top><em class=code>location</em></TD>
    <TD>Returns location of indexed state variable.</TD></TR>

<TR><TD valign=top><em class=optionalcode>var_type</em></TD>
    <TD>If present, always returns 1 as the type</TD></TR>

</TABLE>

<H3 class=indent1>Notes</H3>

<!--===================== DESCRIPTION OF FUNCTION =====================-->

<A NAME="yyyroutine4"></A>
<P></P><HR><P></P>
<div class=routine>
<em class=call>call model_interpolate(x, location, itype, obs_val, istatus)</em>
<pre>
real(r8), dimension(:),   intent(in)  :: <em class=code> x </em>
type(location_type),      intent(in)  :: <em class=code> location </em>
integer,                  intent(in)  :: <em class=code> itype </em>
real(r8)                              :: <em class=code> var </em>
real(r8),                 intent(out) :: <em class=code> obs_val </em>
integer,                  intent(out) :: <em class=code> istatus </em>
</pre></div>

<H3 class=indent1>Description</H3>

<P>
Given model state, returns the value interpolated to a given location 
in [0, 1] by linear interpolation.
The type variable is not used here and istatus is always returned 
as 0 (successful interpolation).
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>x &nbsp; &nbsp; </em></TD>
    <TD>Model state vector. </TD></TR>

<TR><TD valign=top><em class=code>location</em></TD>
    <TD>Location to which to interpolate.</TD></TR>

<TR><TD valign=top><em class=code>itype</em></TD>
    <TD>Not used</TD></TR>

<TR><TD valign=top><em class=code>obs_val</em></TD>
    <TD> The interpolated value from the model.</TD></TR>

<TR><TD valign=top><em class=code>istatus</em></TD>
    <TD>Quality control information, always returned 0 (OK)</TD></TR>

</TABLE>

<H3 class=indent1>Notes</H3>


<!--===================== DESCRIPTION OF FUNCTION =====================-->

<A NAME="yyyroutine5"></A>
<P></P><HR><P></P>
<div class=routine>
<em class=call> var = get_model_time_step( )</em>
<pre>
type(time_type)                       :: <em class=code> get_model_time_step </em>
</pre></div>

<H3 class=indent1>Description</H3>

<P>
Returns the models base time step, or forecast length, as a time_type. 
This is settable via namelist and defaults to 1 hour.
</P>

<H3 class=indent1>Notes</H3>


<!--===================== DESCRIPTION OF SUBROUTINE =====================-->

<A NAME="yyyroutine6"></A>
<P></P><HR><P></P>
<div class=routine>
<em class=call>call end_model( )</em>
<pre>
</pre></div>

<H3 class=indent1>Description</H3>

<P>
A stub since lorenz 96 requires no cleanup.
</P>

<H3 class=indent1>Notes</H3>


<!--===================== DESCRIPTION OF SUBROUTINE =====================-->

<A NAME="yyyroutine7"></A>
<P></P><HR><P></P>
<div class=routine>
<em class=call>call static_init_model( )</em>
<pre>
</pre></div>

<H3 class=indent1>Description</H3>

<P>
Used for runtime initialization of a model, for instance calculating storage 
requirements, initializing model parameters, etc. This is the first call 
made to a model by any DART compliant assimilation routine.
</P>

<H3 class=indent1>Notes</H3>


<!--===================== DESCRIPTION OF SUBROUTINE =====================-->

<A NAME="yyyroutine8"></A>
<P></P><HR><P></P>
<div class=routine>
<em class=call>call init_time(time) </em>
<pre>
type(time_type),          intent(out)    :: <em class=code> time </em>
</pre></div>

<H3 class=indent1>Description</H3>

<P>
Returns the time at which the model will start if no input initial conditions are 
to be used.  This model sets the time to 0.
</P>

<H3 class=indent1>Notes</H3>


<!--===================== DESCRIPTION OF SUBROUTINE =====================-->

<A NAME="yyyroutine9"></A>
<P></P><HR><P></P>
<div class=routine>
<em class=call>call init_conditions( x )</em>
<pre>
real(r8), dimension(:),   intent(out)   :: <em class=code> x </em>
</pre></div>

<H3 class=indent1>Description</H3>

<P>
Returns default initial conditions for model; generally used for spinning up 
initial model states. This model sets all state variables to the forcing value
and then perturbs the first variable slightly.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>x</em></TD>
    <TD>Model state vector.</TD></TR>

</TABLE>

<H3 class=indent1>Notes</H3>


<!--===================== DESCRIPTION OF FUNCTION =====================-->

<A NAME="yyyroutine11"></A>
<P></P><HR><P></P>
<div class=routine>
<em class=call> ierr = nc_write_model_atts(ncFileId) </em>
<pre>
integer,                              :: <em class=code> nc_write_model_atts </em>
integer,                  intent(in)  :: <em class=code> ncFileId </em>
</pre></div>

<H3 class=indent1>Description</H3>

<P>
 Function to write model specific attributes to a netCDF file. This function
writes the metadata associated with the model to a NetCDF file opened to a file 
identified by ncFileID.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>ncFileId &nbsp; &nbsp; </em></TD>
    <TD>Integer file descriptor opened to NetCDF file.</TD></TR>

<TR><TD valign=top><em class=code>ierr</em></TD>
    <TD>Returned error code.</TD></TR>

</TABLE>

<H3 class=indent1>Notes</H3>



<!--===================== DESCRIPTION OF FUNCTION =====================-->

<A NAME="yyyroutine12"></A>
<P></P><HR><P></P>
<div class=routine>
<em class=call> ierr = nc_write_model_vars(ncFileID, statevec, copyindex, timeindex)</em>
<pre>
integer                               :: <em class=code> nc_write_model_vars </em>
integer,                  intent(in)  :: <em class=code> ncFileID </em>
real(r8), dimension(:),   intent(in)  :: <em class=code> statevec </em>
integer,                  intent(in)  :: <em class=code> copyindex</em>
integer,                  intent(in)  :: <em class=code> timeindex </em>
</pre></div>

<H3 class=indent1>Description</H3>

<P>
Writes a copy of the state variables to a NetCDF file. Multiple copies of the 
state for a given time are supported, allowing, for instance, a single file to 
include multiple ensemble estimates of the state.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>ncFileID &nbsp; &nbsp; </em></TD>
    <TD>Integer file descriptor opened to NetCDF file.</TD></TR>

<TR><TD valign=top><em class=code>statevec</em></TD>
    <TD>State vector.</TD></TR>

<TR><TD valign=top><em class=code>copyindex</em></TD>
    <TD> Integer index to which copy is to be written. </TD></TR>

<TR><TD valign=top><em class=code>timeindex</em></TD>
    <TD>Integer index of which time in the file is being written.</TD></TR>

<TR><TD valign=top><em class=code>ierr</em></TD>
    <TD>Returned error code.</TD></TR>

</TABLE>

<H3 class=indent1>Notes</H3>


<!--===================== DESCRIPTION OF SUBROUTINE =====================-->

<A NAME="yyyroutine13"></A>
<P></P><HR><P></P>
<div class=routine>
<em class=call>call pert_model_state(state, pert_state, interf_provided)</em>
<pre>
real(r8), dimension(:),   intent(in)    :: <em class=code> state </em>
real(r8), dimension(:),   intent(out)   :: <em class=code> pert_state </em>
logical,                  intent(out)   :: <em class=code> interf_provided </em>
</pre></div>

<H3 class=indent1>Description</H3>

<P>
Given a model state, produces a perturbed model state.
Lorenz-96 does not implement an interface for this and 
returns .false. for interf_provided.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>state</em></TD>
    <TD>State vector to be perturbed</TD></TR>

<TR><TD valign=top><em class=code>pert_state</em></TD>
    <TD>Perturbed state vector is NOT returned</TD></TR>

<TR><TD valign=top><em class=code>interf_provided</em></TD>
    <TD>Return false to have DART perturb state</TD></TR>

</TABLE>

<H3 class=indent1>Notes</H3>

<!--=================================================================-->
<!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="get_close_maxdist_init"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call get_close_maxdist_init(gc, maxdist) </em>
 <pre>
 type(get_close_type), intent(inout) :: <em class=code>gc</em>
 real(r8),             intent(in)    :: <em class=code>maxdist</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Pass-through to the 1-D locations module. See
<A HREF="../../location/oned/location_mod.html#get_close_maxdist_init">
get_close_maxdist_init()</A> for the documentation of this subroutine.

<!--=================================================================-->
<!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="get_close_obs_init"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call get_close_obs_init(gc, num, obs) </em>
 <pre>
 type(get_close_type), intent(inout) :: <em class=code>gc</em>
 integer,              intent(in)    :: <em class=code>num</em>
 type(location_type),  intent(in)    :: <em class=code>obs(num)</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Pass-through to the 1-D locations module. See
<A HREF="../../location/oned/location_mod.html#get_close_obs_init">
get_close_obs_init()</A> for the documentation of this subroutine.

<!--=================================================================-->
<!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="get_close_obs"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call get_close_obs(gc, base_obs_loc, base_obs_kind, 
   obs, obs_kind, num_close, close_ind
   <em class=code>[, dist]</em>) </em>
 <pre>
 type(get_close_type), intent(in)  :: <em class=code>gc</em>
 type(location_type),  intent(in)  :: <em class=code>base_obs_loc</em>
 integer,              intent(in)  :: <em class=code>base_obs_kind</em>
 type(location_type),  intent(in)  :: <em class=code>obs(:)</em>
 integer,              intent(in)  :: <em class=code>obs_kind(:)</em>
 integer,              intent(out) :: <em class=code>num_close</em>
 integer,              intent(out) :: <em class=code>close_ind(:)</em>
 real(r8), optional,   intent(out) :: <em class=optionalcode>dist(:)</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Pass-through to the 1-D locations module. See
<A HREF="../../location/oned/location_mod.html#get_close_obs">
get_close_obs()</A> for the documentation of this subroutine.

<!--=================================================================-->
<!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="ens_mean_for_model"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call ens_mean_for_model(ens_mean) </em>
 <pre>
 real(r8), dimension(:), intent(in)  :: <em class=code>ens_mean</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
A NULL INTERFACE in this model.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>ens_mean&nbsp; &nbsp; </em></TD>
     <TD>Ensemble mean state vector</TD></TR>
 </TABLE>
 <BR>


<!--==================================================================-->
<!--=================== DESCRIPTION OF A NAMELIST  ===================-->

<A NAME="Namelist"></A>
<BR><HR><BR>
<H2>NAMELIST</H2>
<P>We adhere to the F90 standard of starting a namelist with an ampersand 
'&#38;' and terminating with a slash '/'.
<div class=namelist>
<pre>
<em class=call>namelist / model_nml / </em> &#38
    model_size, forcing, delta_t, time_step_days, time_step_seconds
</pre>
</div>
</P>

<H3 class=indent1>Discussion</H3>

<P>This namelist is read in a file called <em class=file>input.nml</em>
</P>

<TABLE border=0 cellpadding=3 width=100%>
<TR><TH align=left>Contents    </TH>
    <TH align=left>Type        </TH>
    <TH align=left>Description </TH></TR>
<TR><!--contents--><TD valign=top>model_size      </TD>
    <!--  type  --><TD valign=top>integer         </TD>
    <!--descript--><TD>Number of variables in model, default is 40. </TD></TR>
<TR><!--contents--><TD valign=top>forcing         </TD>
    <!--  type  --><TD valign=top>real(r8)        </TD>
    <!--descript--><TD>Forcing, F, for model, default 8.0 </TD></TR>
<TR><!--contents--><TD valign=top>delta_t              </TD>
    <!--  type  --><TD>real(r8)                        </TD>
    <!--descript--><TD>Non-dimensional timestep, default 0.05
                This is mapped to the dimensional timestep specified
                 by time_step_days and time_step_seconds.</TD></TR>
<TR><!--contents--><TD valign=top>time_step_days       </TD>
    <!--  type  --><TD>real(r8)                        </TD>
    <!--descript--><TD>Number of days for dimensional timestep,
                       mapped to delta_t. default 0</TD></TR>
<TR><!--contents--><TD valign=top>time_step_seconds    </TD>
    <!--  type  --><TD>real(r8)                        </TD>
    <!--descript--><TD>Number of seconds for dimensional timestep,
                       mapped to delta_t. default 3600</TD></TR>
</TABLE>

<!--==================================================================-->
<!-- Describe the Files Used by this module.                          -->
<!--==================================================================-->

<A NAME="FilesUsed"></A>
<BR><HR><BR>
<H2>FILES</H2>
<UL> 
    <LI>model_mod.nml in input.nml
    <LI>netCDF output state diagnostics files
</UL>

<!--==================================================================-->
<!-- Cite references, if need be.                                     -->
<!--==================================================================-->

<A NAME="References"></A>
<BR><HR><BR>
<H2>REFERENCES</H2>

<P>
Lorenz, E. N., 1995: Predictability: A Problem Partly Solved. 
&nbsp;<i>Proc. Seminar on Predictability.</i>
<b>1</b>, ECMWF, Reading, Berkshire, UK, 1-18. 
</P>
<P>
Lorenz, E. N., and K. A. Emanuel, 1998: Optimal sites for 
supplementary weather observations: Simulations with a small model. 
&nbsp;<i>J.  Atmos. Sci.</i>, <b>55</b>, 399-414.
</P>

<!--==================================================================-->
<!-- Describe all the error conditions and codes.                     -->
<!-- Putting a <BR> after the synopsis creates a nice effect.         -->
<!--==================================================================-->

<A NAME="Errors"></A>
<HR>
<H2>ERROR CODES and CONDITIONS</H2>
<div class="errors">

</TABLE>
<TABLE border=1 cellspacing=1 cellpadding=10 width=100%>
<TR><TH>Routine</TH><TH>Message</TH><TH>Comment</TH></TR>
<TR><!-- routine --><TD VALIGN=top>
                                   nc_write_model_atts <BR>
                                   nc_write_model_vars <BR>
    </TD>
    <!-- message --><TD VALIGN=top>Various NetCDF-f90 interface error messages</TD>
    <!-- comment --><TD VALIGN=top>From one of the NetCDF calls in the named routine</TD>
</TR>
</TABLE>
</div>

<!--==================================================================-->
<!-- Describe the bugs.                                               -->
<!--==================================================================-->

<A NAME="KnownBugs"></A>
<BR><HR><BR>
<H2>KNOWN BUGS</H2>
<P>
</P>

<!--==================================================================-->
<!-- Descibe Future Plans.                                            -->
<!--==================================================================-->

<A NAME="FuturePlans"></A>
<BR><HR><BR>
<H2>FUTURE PLANS</H2>
<P>
</P>

<!--==================================================================-->
<!-- Have not fleshed out this part yet ... ha ha ha                  -->
<!--==================================================================-->

<!--==================================================================-->

<HR>
</BODY>
</HTML>
