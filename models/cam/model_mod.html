<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
          "http://www.w3.org/TR/html4/strict.dtd">
<HTML>
<HEAD>
<TITLE>module model_mod (CAM)</TITLE>
<link rel="stylesheet" type="text/css" href="../../doc/html/doc.css" />
<link href="../../doc/images/dart.ico" rel="shortcut icon" />
</HEAD>
<BODY>
<A NAME="TOP"></A>

<H1>MODULE model_mod (CAM)</H1>

<table border=0 summary="" cellpadding=5>
<tr>
    <td valign=middle>
    <img src="../../doc/images/Dartboard7.png" alt="DART project logo" height=70 />
    </td>
    <td>
       <P>Jump to <a href="../../index.html">DART Documentation Main Index</a><br />
          <small><small>version information for this file: <br />
          <!-- version tag follows, do not edit -->
          $Id$</small></small>
       </P></td>
</tr>
</table>


<A HREF="#Namelist">NAMELIST</A> / 
<A HREF="#Interface">INTERFACES</A> / 
<A HREF="#PrivateComponents">PRIVATE COMPONENTS</A> /
<A HREF="#FilesUsed">FILES</A> /
<A HREF="#References">REFERENCES</A> /
<A HREF="#Errors">ERRORS</A> /
<A HREF="#KnownBugs">BUGS</A> /
<A HREF="#FuturePlans">PLANS</A> /
<A HREF="#Legalese">TERMS OF USE</A>



<A NAME="OVERVIEW"></A>
<H2>Overview</H2>

<P>
The DART system supports data assimilation into CAM -- The Community Atmosphere Model.
It is being actively used by graduate students,
post-graduates, and scientists at universities and research labs. Others are
using analyses for their time period and resolution of interest,
produced here at NCAR using DART-CAM. In addition to the standard DART
features described elsewhere, current capabilities include the ability to:
</P>

<UL>
<LI>Use either the Eulerian or finite-volume core.</LI>
<LI>Use any resolution of CAM without recompiling DART. The standard resolutions of 
T21, T42, T85, FV 2x2.5 and 4x5 have been tested.</LI>
<LI>Assimilate a variety of observations; to date the observations 
successfully assimilated include the NCEP reanalysis BUFR obs (T,U,V), 
Global Positioning System radio occultation obs, and MOPITT carbon monoxide 
(when a chemistry model is incorporated into FV CAM). Research is under way to 
assimilate surface observations, specific humidity, cloud liquid water, and aerosols.</LI>
<LI>Specify, via namelist entries, the CAM (initial file) variables which will be 
directly affected by the observations. This allows users to change the model state 
without recompiling.</LI>
<LI>Generate analyses on the CAM grid which are of comparable quality to those 
produced by operational centers, but which have only CAM model error in them, 
rather than the model error of the models used at the centers.</LI>
<LI>Generate such analyses with as few as 20 ensemble members.</LI>
</UL>

<P>
In addition to the standard DART package there is a collection of initial
condition files at the large file website
<a href="http://www.image.ucar.edu/pub/DART/CAM/">
http://www.image.ucar.edu/pub/DART/CAM/</a>
that are helpful for interfacing CAM with DART.
</P>

<P>
Sample sets of observations, which can be used with DART-CAM assimilations,
can be found at 
<a href="http://www.image.ucar.edu/pub/DART/Obs_sets/">
http://www.image.ucar.edu/pub/DART/Obs_sets/</a>
of which the NCEP BUFR observations are the most widely used.
</P>

<P>
Experience on a variety of machines has shown that it is a very good idea to
make sure your run-time environment has the following:
</P>
<pre>
limit stacksize unlimited
limit datasize unlimited
</pre>
<P>
This page contains the documentation for 
the DART interface module for the CAM model,
using the either the Eulerian and Finite Volume dynamical core,
soon the HOMME core on the cubed sphere,
and possibly the Semi-Lagrangian core. 
It is designed to work for versions of CAM from 2.0.1 
through the currently released version(s)
by specifying the version number in the model_mod namelist.
This implementation of DART-CAM uses the CAM initial files for 
transferring the model state to/from the filter/CAM.  
The DART interface model was designed to facilitate using any CAM
version with minimal changes to the model_mod code and accompanying scripts.
</P>
<P>
The DART interfaces to CAM and the rest of the CESM components
have been integrated with the CESM run scripts.  Unlike previous versions
of DART-CAM, CESM runs using its normal scripts, then stops and calls
a DART script which runs a single assimilation step, then
returns to the CESM run script to continue the model advances.
See the <a href="../models/CESM/model_mod.html">CESM interface
documentation</a> for more information on running DART with CESM.
</P>

<P>
The DART state vector should include any variable in the CAM initial
files which is a fundamental quantity and required to reconstruct any
other variable that is carried along in the model files.  In practice
the state vector sometimes contains derived quantities to enable DART
to compute forward operators (expected observation values) efficiently.
The derived quantities are often overwritten when the model runs the
next timestep, so the work DART does to update them is waster work.
</P>

<P>
Expected observation values on pressure, height or model levels can be requested
from model_interpolate.  Surface observations can not yet be interpolated,
due to the difference between the model surface and the earth's surface
where the observations are made.  Model_interpolate can be queried for any
(non-surface) variable in the state vector (which are variables native to
CAM) plus pressure on height levels.  The default state vector is PS, T,
U, V, Q, CLDLIQ, CLDICE.  
Variables which are not in the initial file 
<A HREF="doc/cam_guidelines.html">can be added</A>, 
but minor modifications to model_mod.f90 (and perhaps CAM) may be necessary.  
</P>

<P>
The 16 public interfaces in model_mod
are standardized for all DART compliant models. These interfaces allow
DART to get the model state and metadata describing 
this state, find state variables that are close to a given location, 
and do spatial interpolation for a variety of variables required by
observational operators.
</P>

<P>
Help with several aspects of
<A HREF="doc/cam_guidelines.html">setting up assimilation experiments</A> 
using CAM and parallel architecture computers is available:
</P>
<UL>
    <LI> <A HREF="doc/cam_guidelines.html#SETUP">experiment set-up</A> </LI>
    <LI> <A HREF="doc/cam_guidelines.html#INITIALFILES">creating initial ensembles</A> </LI>
    <LI> <A HREF="doc/cam_guidelines.html#CALLINGTREE">script and executable calling tree</A> </LI>
    <LI> <A HREF="doc/cam_guidelines.html#OUTPUTDIRECTORY">output directory structure for use by obs_diag</A> </LI>
    <LI> <A HREF="doc/cam_guidelines.html#FILECONTENTS">file contents and purposes</A> </LI>
    <LI> <A HREF="doc/cam_guidelines.html#HINTS">helpful hints</A> </LI>
    <LI> <A HREF="doc/cam_guidelines.html#SPACE">space requirements of various CAM resolutions</A> </LI>
</UL> 

<!--==================================================================-->
<!--=================== DESCRIPTION OF A NAMELIST  ===================-->

<A NAME="Namelist"></A>
<div class="top">[<a href="#">top</a>]</div><hr />
<H2>NAMELIST</H2>
<P>
This namelist is read from the file <em class=file>input.nml</em>.
Namelists start with an ampersand
'&amp;' and terminate with a slash '/'.
Character strings that contain a '/' must be
enclosed in quotes to prevent them from 
prematurely terminating the namelist.
</P>

<div class=namelist>
<pre>
&amp;model_nml
   output_state_vector = .false.,
   model_version       = '3.0',
   model_config_file   = 'caminput.nc',
   cam_phis            = 'cam_phis.nc',
   state_num_0d        = 0,
   state_num_1d        = 0,
   state_num_2d        = 1,
   state_num_3d        = 4,
   state_names_0d      = '',
   state_names_1d      = '',
   state_names_2d      = 'PS'
   state_names_3d      = 'T', 'U', 'V', 'Q',
   which_vert_1d       = -2 ,
   which_vert_2d       = -1 , 
   which_vert_3d       = 1  ,
   pert_names          = '',
   pert_sd             = -888888.0,
   pert_base_vals      = -888888.0,
   highest_obs_pressure_mb   = 150.0,
   highest_state_pressure_mb = 150.0,
   max_obs_lat_degree  = 90.0,
   Time_step_seconds   = 21600,
   Time_step_days      = 0,
   impact_only_same_kind = '',
   print_details       = .false.
   /
</pre>
</div>

<br />
<br />

<P>
The specification of lists of names and numbers for the various dimensions 
enables the very flexible definition of the state vector.  It can be
done via the namelist, instead of recompiling DART for each different set.
One hurdle that still remains is that distinct filter initial condition files are
necessary for each distinct set of fields which compose the state vector.
</P>

<P>
The dimension of these lists is currently hardwired to size 100. 
If more fields need to be assimilated (e.g. many chemical species),
look for the integer parameter MAX_STATE_NAMES in the source code
and change it to a long enough value and recompile DART.
Longer term we intend to investigate using 2 different namelists
inside model_mod; one for setting the length of the lists and another
to actually read in the data which fills the lists.
</P>

<P>
The values for which_vert_#d is described in 
DART/location/threed_sphere/location_mod.html.
</P>

<P>
The names of the fields to put into the state vector come from the CAM initial
file field names.
</P>

<div>
<TABLE border=0 cellpadding=10 width=100% summary='namelist description'>
<THEAD align=left>
<TR><TH> Item </TH>
    <TH> Type </TH>
    <TH> Description </TH> </TR>
</THEAD>

<TBODY valign=top>

<TR><TD> output_state_vector </TD>
    <TD> logical </TD>
    <TD>Controls the output to netCDF files. 
If .true., output the raw dart state vector. If .false., output the
prognostic flavor (gridded data) for easier plotting (recommended).
</TD></TR>

<TR><TD> model_version </TD>
    <TD> character(len=128) </TD>
    <TD>The number of the CAM version being used, i.e. '3.0.7'.  
(no letters allowed, so rename cam3_0_p1)
</TD></TR>

<TR><TD> model_config_file </TD>
    <TD> character(len=128) </TD>
    <TD>CAM initial file used to provide configuration information.
</TD></TR>

<TR><TD>state_num_#d,<br /> #=0,1,2,3   </TD>
    <TD> integer </TD>
    <TD>Numbers of fields of various dimensions to put into the state vector.
</TD></TR>

<TR><TD>state_names_#d,<br /> #=0,1,2,3 </TD>
    <TD>character(len=8), dimension(100)  </TD>
    <TD>Names of fields of various dimensions to put into the state vector.  
</TD></TR>

<TR><TD>which_vert_#d,<br /> #=1,2,3 </TD>
    <TD>integer, dimension(100)  </TD>
    <TD>Vertical location types of fields in state_names_#d.
See the <a href="../../location/sphere_threed/location_mod.html">3D sphere location</a>
documentation for the mapping of integer values to vertical location types.
</TD></TR>

<TR><TD> pert_names </TD>
    <TD>character(len=8), dimension(100)    </TD>
    <TD>To make filter generate an ensemble from a single model state by
randomly perturbing it, list the field(s) to be perturbed here.  To make
trans_pv_sv_pert0 reset a single field to a constant value, list that field
here.  Trans_pv_sv_pert0 would be run as many times as there are ensemble
members (see pert_base_vals), in order to provide spread to that variable.
</TD></TR>

<TR><TD> pert_sd </TD>
    <TD>real(r8), dimension(100)    </TD>
    <TD>If positive, it's the standard deviation of the perturbation for each
field in the pert_names list (filter).  If negative, then pert_names can
contain only one entry, and that field will be set to a different constant
value for each ensemble member (trans_pv_sv_pert0).  Those values come from
pert_base_vals.  Defaults to a MISSING real value and unused unless
pert_names is set.
</TD></TR>

<TR><TD> pert_base_vals </TD>
    <TD>real(r8), dimension(100)    </TD>
    <TD>If pert_sd is negative, this is the list of values to use for
each ensemble member when perturbing the single field named in pert_names.
Otherwise, it's the list of values to which the field(s) listed in pert_names
will be reset if filter is told to create an ensemble from a single state
vector.  Defaults to a MISSING real value and unused unless pert_names is set
and pert_base_vals is /= this missing value (-888888.0d0).
</TD></TR>

<TR><TD> max_obs_lat_degree </TD>
    <TD> real(r8) </TD>
    <TD>Observations closer to the poles than this latitude will be ignored.
</TD></TR>

<TR><TD> highest_obs_pressure_mb </TD>
    <TD> real(r8) </TD>
    <TD>Observations higher than this pressure are ignored.
</TD></TR>

<TR><TD> highest_state_pressure_mb </TD>
    <TD> real(r8) </TD>
    <TD>Influence of all obs on model points higher than this is reduced.
</TD></TR>

<TR><TD> Time_step_seconds </TD>
    <TD> real(r8) </TD>
    <TD>Minimum forecast duration (the part &lt; 1 day)
</TD></TR>

<TR><TD> Time_step_days </TD>
    <TD> real(r8) </TD>
    <TD>Minimum forecast duration (the part &gt; 24*3600 sec)
</TD></TR>

<TR><TD> impact_only_same_kind </TD>
    <TD> character(len=32) </TD>
    <TD>Name of one observation kind which can only affect 
state variables of the same kind.
</TD></TR>

<TR><TD> print_details </TD>
    <TD> logical </TD>
    <TD>If true, print out detailed information about the sizes, shapes, offsets,
etc of items in the CAM state vector.  If false, just print out the names of
the fields as they are read into the state vector.
</TD></TR>

</TBODY> 
</TABLE>
</div>

<br />
<br />

<!--==================================================================-->

<A NAME="OTHERMODULESUSED"></A>
<div class="top">[<a href="#">top</a>]</div><hr />
<H2>OTHER MODULES USED</H2>
<PRE>
obs_kind_mod
random_nr_mod
random_seq_mod
threed_sphere/location_mod
time_manager_mod
types_mod
utilities_mod
mpi_utilities
</PRE>

<!--==================================================================-->

<A NAME="PublicEntities"></A>

<A NAME="Interface"></A>
<div class="top">[<a href="#">top</a>]</div><hr />
<H2>PUBLIC INTERFACES</H2>

<H4>FILTER INTERFACE</H4>
<P>
Here they are listed alphabetically, except for the last 4 interfaces,
which are only required for low-order models where advancing
the model can be done by a call to a subroutine. 
The last 4 interfaces only appear as stubs in the CAM module.
Following this list they are listed in 
the order in which they appear in model_mod.f90, which is separated into sections
corresponding to the main functions of model_mod.f90: static_init_model,
I/O, model_interpolate, vector<->field translations, get_close_obs, and
utility routines.
</P>

<TABLE>
<TR><TD><em class=call>use model_mod, only : </em></TD>
                   <TD><A HREF="#ens_mean_for_model">ens_mean_for_model</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_close_maxdist_init">get_close_maxdist_init</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_close_obs_init">get_close_obs_init</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_close_obs">get_close_obs</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_model_time_step">get_model_time_step</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_model_size">get_model_size</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_state_meta_data">get_state_meta_data</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#model_interpolate">model_interpolate</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#nc_write_model_atts">nc_write_model_atts</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#nc_write_model_vars">nc_write_model_vars</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#pert_model_state">pert_model_state</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#static_init_model">static_init_model</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#adv_1step">adv_1step</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#end_model">end_model</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#init_time">init_time</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#init_conditions">init_conditions</A></TD></TR>
</TABLE>


<P>
The interface pert_model_state is provided for CAM, and it allows each
field of the state vector to be randomly perturbed using a separate
standard deviation.   Even this may not be flexible enough to handle
variables such as specific humidity, which can vary by orders of magnitude
from the surface to the top of the model.
</P>

<H4>OTHER PUBLIC INTERFACES</H4>
<P>
The list of interfaces above is part of the list of public routines in this module.
The rest of the public list are used by programs other than filter;
dart_to_cam, cam_to_dart, etc.
</P>

<TABLE>
<TR><TD><em class=call>use model_mod, only : </em></TD>
                   <TD><A HREF="#prog_var_to_vector">prog_var_to_vector</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#read_cam_init">read_cam_init</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#vector_to_prog_var">vector_to_prog_var</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#write_cam_init">write_cam_init</A></TD></TR>
</TABLE>

<P>
Namelist interface
<A HREF="#Namelist"> <em class=code>&amp;model_nml</em> </A>
is read from file <em class=file>input.nml</em>.
</P>

<br><br>
<!--==================================================================-->
<!-- Declare all public entities ...                                  -->
<!-- duplicate public routines template as many times as necessary    -->
<!--==================================================================-->


<!--================================================================-->
<!--=================== DESCRIPTION OF SUBROUTINE ====================-->

<A NAME="static_init_model"></A>
<div class=routine>
<em class=call>call static_init_model( )</em>
</div>

<div class=indent1>
<P>
Used for runtime initialization of the model. This is the first call made
to the model by any DART compliant assimilation routine. It reads the
model_mod namelist parameters, sets the calendar type (the GREGORIAN
calendar is used with the CAM model), and determines the dart vector
length, among other things.  This subroutine requires that caminput.nc 
(or the name in namelist variable model_config_file) be present in the working
directory to retrieve model information (grid dimensions and spacing
including the vertical hybrid coordinate coefficients, time step, and
Gaussian weights, etc).  
</P>
</div>


<!--================================================================-->
<!--=================== DESCRIPTION OF SUBROUTINE ====================-->

<A NAME="get_state_meta_data"></A>
<div class=routine>
<em class=call>call get_state_meta_data (index_in, location, 
                          <em class=optionalcode>[, var_type]</em> )</em>
<pre>
integer,                  intent(in)    :: <em class=code> index_in </em>
type(location_type),      intent(out)   :: <em class=code> location </em>
integer, optional,        intent(out)   :: <em class=code> var_type </em>
</pre></div>


<div class=indent1>
<P>
 Returns metadata about a given element, indexed by index_in, in the model 
state vector. The location defines where the state variable is located 
while the type of the variable (for instance temperature, 
or u wind component) is returned by var_type. The integer values used to 
indicate different variable types in var_type are themselves defined as 
public interfaces to model_mod if required. 
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>
<TR><TD valign=top><em class=code>index_in</em></TD>
    <TD>Index into the long state vector.</TD></TR>
<TR><TD valign=top><em class=code>location</em></TD>
    <TD>Returns location of indexed state variable. The location should 
use a location_mod that is appropriate for the model domain. For 
realistic atmospheric models, for instance, a three-dimensional 
spherical location module that can represent height in a variety  
of ways is provided. </TD></TR>
<TR><TD valign=top><em class=optionalcode>var_type</em></TD>
    <TD>Returns the type of the indexed state variable as an optional argument.</TD></TR>
</TABLE>
<br>
</div>

<!--=================================================================-->
<!--============= DESCRIPTION OF A SUBROUTINE =======================-->

 <A NAME="ens_mean_for_model"></A>
 <div class=routine>
 <em class=call> call ens_mean_for_model(ens_mean) </em>
 <pre>
 real(r8), dimension(:), intent(in)  :: <em class=code>ens_mean</em>
 </pre></div>

<div class=indent1>
 <P>
saves a local copy of the ensemble means which can be used for 
computing vertical heights, for example.
 </P>
 <TABLE width=100% border=0 summary="" cellpadding=3>
 <TR><TD valign=top><em class=code>ens_mean&nbsp; &nbsp; </em></TD>
     <TD>Ensemble mean state vector</TD></TR>
 </TABLE>
<br>
</div>

<!--================================================================-->
<!--===================== DESCRIPTION OF FUNCTION ====================-->

<A NAME="get_model_size"></A>
<div class=routine>
<em class=call> model_size = get_model_size( )</em>
<pre>
integer                               :: <em class=code> get_model_size </em>
</pre></div>

<div class=indent1>
<P>
Returns the length of the model state vector as an integer. This includes all
nested domains.
</P>
</div>

<!--================================================================-->
<!--==================== DESCRIPTION OF FUNCTION =====================-->

<A NAME="get_model_time_step"></A>
<div class=routine>
<em class=call> var = get_model_time_step( )</em>
<pre>
type(time_type)                       :: <em class=code> get_model_time_step </em>
</pre></div>

<div class=indent1>
<P>
Returns the forecast length to be used as the "model base time step" in the filter. 
The choice of initial files instead of restart files restricts the 
assimilation from using "time steps" which are too small.  This is because
CAM uses a leapfrog time scheme, but the initial files store only a 
single timestep.  The initial forecast step is a simple forward step, so if 
repeated short forecasts (&lt; ~9 model time steps) are made, the model 
becomes unstable.
In the long run, a more general extended interface may be required that specifies 
the models range of time stepping possibilities.
</P>
</div>

<!--=================================================================-->
<!--==================== DESCRIPTION OF FUNCTION =====================-->

<A NAME="nc_write_model_atts"></A>
<div class=routine>
<em class=call> ierr = nc_write_model_atts(ncFileId) </em>
<pre>
integer,                              :: <em class=code> nc_write_model_atts </em>
integer,                  intent(in)  :: <em class=code> ncFileId </em>
</pre></div>

<div class=indent1>
<P>
 Function to write model specific attributes to a netCDF file. At present, DART 
is using the NetCDF format to output diagnostic information. This is not a 
requirement, and models could choose to provide output in other formats. This function 
writes the metadata associated with the model to a NetCDF file opened to a file 
identified by ncFileID.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>ncFileId &nbsp; &nbsp; </em></TD>
    <TD>Integer file descriptor opened to NetCDF file.</TD></TR>

<TR><TD valign=top><em class=code>ierr</em></TD>
    <TD>Returned error code.</TD></TR>

</TABLE>
<br>
</div>

<!--================================================================-->
<!--==================== DESCRIPTION OF FUNCTION =====================-->

<A NAME="nc_write_model_vars"></A>
<div class=routine>
<em class=call> ierr = nc_write_model_vars(ncFileID, statevec, copyindex, timeindex)</em>
<pre>
integer                               :: <em class=code> nc_write_model_vars </em>
integer,                  intent(in)  :: <em class=code> ncFileID </em>
real(r8), dimension(:),   intent(in)  :: <em class=code> statevec </em>
integer,                  intent(in)  :: <em class=code> copyindex</em>
integer,                  intent(in)  :: <em class=code> timeindex </em>
</pre></div>

<div class=indent1>
<P>
Writes a copy of the state variables to a NetCDF file. Multiple copies of the 
state for a given time are supported, allowing, for instance, a single file to 
include multiple ensemble estimates of the state.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>ncFileID &nbsp; &nbsp; </em></TD>
    <TD>Integer file descriptor to opened NetCDF file.</TD></TR>

<TR><TD valign=top><em class=code>statevec</em></TD>
    <TD>State vector.</TD></TR>

<TR><TD valign=top><em class=code>copyindex</em></TD>
    <TD> Integer index to which copy is to be written. </TD></TR>

<TR><TD valign=top><em class=code>timeindex</em></TD>
    <TD>Integer index of which time in the file is being written.</TD></TR>

<TR><TD valign=top><em class=code>ierr</em></TD>
    <TD>Returned error code. success == 0, failure == -1</TD></TR>

</TABLE>
<br>
</div>

<!--================================================================-->
<!--============= DESCRIPTION OF A SUBROUTINE =======================-->
<A NAME="read_cam_init"></A>
<div class=routine>
<em class=call> call read_cam_init(file_name,var) </em>
<pre>
character(len, intent(in)     :: <em class=code>file_name</em>
type(model_type), intent(out) :: <em class=code>var</em>
</pre></div>

<div class=indent1>
<P>
Reads state vector fields from a CAM initial file.  Fields are specified in model_mod.nml.
</P>
<TABLE width=100% border=0 summary="" cellpadding=3>
<TR><TD valign=top><em class=code>file_name&nbsp; &nbsp; </em></TD>
    <TD>CAM initial file name.</TD></TR>
<TR><TD valign=top><em class=code>var&nbsp; &nbsp; </em></TD>
    <TD>Structure to hold the state vector fields read from file_name.</TD></TR>
</TABLE>
<br>
</div>
 
 <!--================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="write_cam_init"></A>
 <div class=routine>
 <em class=call> call write_cam_init(file_name,var) </em>
 <pre>
 character, intent(in)                     :: <em class=code>file_name</em>
 type(model_type), allocatable, intent(in) :: <em class=code>var</em>
 </pre></div>

 <div class=indent1>
 <P>
 Write fields that have been updated by assimilation to the CAM 'initial' file.
 </P>
 <TABLE width=100% border=0 summary="" cellpadding=3>
 <TR><TD valign=top><em class=code>file_name&nbsp; &nbsp; </em></TD>
     <TD>Name of CAM initial file to which var will be written.</TD></TR>
 <TR><TD valign=top><em class=code>var&nbsp; &nbsp; </em></TD>
     <TD>Structure containing all the fields of the state vector.</TD></TR>
 </TABLE>
<br>
</div>

<!--================================================================-->
<!--=================== DESCRIPTION OF SUBROUTINE ====================-->

<A NAME="model_interpolate"></A>
<div class=routine>
<em class=call> call model_interpolate(x, location, obs_type, interp_val, istatus)</em>
<pre>
real(r8), dimension(:),   intent(in)  :: <em class=code> x </em>
type(location_type),      intent(in)  :: <em class=code> location </em>
integer,                  intent(in)  :: <em class=code> obs_type </em>
real(r8),                 intent(out) :: <em class=code> interp_val </em>
integer,                  intent(out) :: <em class=code> istatus </em>
</pre></div>

<div class=indent1>
<P>
Given model state, returns the value of observation type interpolated to a
given location by a method of the model's choosing.  Currently observation
types: KIND_U_WIND_COMPONENT, KIND_V_WIND_COMPONENT, KIND_SURFACE_PRESSURE,
KIND_TEMPERATURE, KIND_SPECIFIC_HUMIDITY, KIND_PRESSURE are supported, but
others can be added.  KIND_PRESSURE does not have a corresponding field on
CAM initial files, but is routinely calculated in CAM using its own
subroutines.  Interpolation of this field has been incorporated in order to
facilitate assimilations of observations which require it, such as GPS
radio occultation.  If the interpolation is valid, istatus = 0.  In the
case where the observational operator is not defined at the given location
(e.g. the observation is below the lowest model level or above the top
level), interp_val is returned as 0.0 and istatus = 1.  CAM is highly
damped in the upper levels of the model, which has required the exclusion
of otherwise valid observations above a certain level, which can be
specified in the model_mod namelist variable highest_obs_pressure_mb.  Such
cases return istatus = 2, and also do the interpolation and return the
value, which is NOT used by filter.  Eventually such quality control may be
moved to another module, but for now is performed in subroutine
get_val_pressure.  
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>x &nbsp; &nbsp; </em></TD>
    <TD>Model state vector. </TD></TR>

<TR><TD valign=top><em class=code>location</em></TD>
    <TD>Location to which to interpolate.</TD></TR>

<TR><TD valign=top><em class=code>obs_type</em></TD>
    <TD>Integer indexing which type of observation is to be interpolated.</TD></TR>

<TR><TD valign=top><em class=code>interp_val</em></TD>
    <TD>Value interpolated to location.</TD></TR>

<TR><TD valign=top><em class=code>istatus</em></TD>
    <TD>Integer flag indicating the success of the interpolation.</TD></TR>

</TABLE>
<br>
</div>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="prog_var_to_vector"></A>
 <div class=routine>
 <em class=call> call prog_var_to_vector(var,x) </em>
 <pre>
 type(model_type), allocatable, intent(in)        :: <em class=code>var</em>
 real(r8), allocatable, dimension(:), intent(out) :: <em class=code>x</em>
 </pre></div>

 <div class=indent1>
 <P>
 Insert CAM fields (N-D) into DART state vector array (1-D)
 </P>
 <TABLE width=100% border=0 summary="" cellpadding=3>
 <TR><TD valign=top><em class=code>var&nbsp; &nbsp; </em></TD>
     <TD>Structure containing all the fields of the state vector.</TD></TR>
 <TR><TD valign=top><em class=code>x&nbsp; &nbsp; </em></TD>
     <TD>DART state vector.</TD></TR>
 </TABLE>
<br>
</div>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="vector_to_prog_var"></A>
 <div class=routine>
 <em class=call> call vector_to_prog_var(x,var) </em>
 <pre>
 real(r8), allocatable, dimension(:), intent(in) :: <em class=code>x</em>
 type(model_type), allocatable, intent(out)      :: <em class=code>var</em>
 </pre></div>

 <div class=indent1>
 <P>
 Extract CAM fields (N-D) from state vector (1-D).
 </P>
 <TABLE width=100% border=0 summary="" cellpadding=3>
 <TR><TD valign=top><em class=code>x&nbsp; &nbsp; </em></TD>
     <TD>DART state vector.</TD></TR>
 <TR><TD valign=top><em class=code>var&nbsp; &nbsp; </em></TD>
     <TD>Structure containing all the fields of the state vector.</TD></TR>
 </TABLE>
<br>
</div>

<!--=================================================================-->
<!--============= DESCRIPTION OF A SUBROUTINE =======================-->
<A NAME="get_close_obs"></A>
<div class=routine>
<em class=call> call get_close_obs(gc, base_obs_loc, base_obs_kind, 
   obs, obs_kind, num_close, close_ind
  <em class=optionalcode>[, dist]</em>) </em>
<pre>
type(get_close_type), intent(in)  :: <em class=code>gc</em>
type(location_type),  intent(in)  :: <em class=code>base_obs_loc</em>
integer,              intent(in)  :: <em class=code>base_obs_kind</em>
type(location_type),  intent(in)  :: <em class=code>obs(:)</em>
integer,              intent(in)  :: <em class=code>obs_kind(:)</em>
integer,              intent(out) :: <em class=code>num_close</em>
integer,              intent(out) :: <em class=code>close_ind(:)</em>
real(r8), optional,   intent(out) :: <em class=optionalcode>dist(:)</em>
</pre></div>

<div class=indent1>
<P>
First calls the location module code and then updates
the distances to accomodate damping CAM's highest levels.
Pass-through to the 3-D sphere locations module. See
<A HREF="../../location/threed_sphere/location_mod.html#get_close_obs">
get_close_obs()</A> for the documentation of this subroutine.

<P>
CAM uses a hybrid vertical coordinate, which requires the surface pressure
beneath a point in order to determine the point's vertical coordinate.
When the model state vector is divided up among several regions during
parallelization, surface pressure points from other regions become unavailable.
The ensemble mean state is available to provide complete columns of data for
these calculations.
<br><br>
Due to the damping at high levels (see <a href="#model_interpolate">model_interpolate</a>)
there is also code 
which reduces the influence of observations on model points above some altitude.
Currently namelist variables <em class="code">highest_obs_pressure_mb</em> and
<em class="code">highest_state_pressure_mb</em> control this.
All observations on height and level are handled automatically, using the 
ensemble mean for calculations. For CAM with 26 vertical levels, the influence declines 
to 0 above model level 6 for <em class="code">highest_obs_pressure_mb = 150</em>
( ~&nbsp;model level 12).
</P>
</div>

<!--=================================================================-->
<!--============= DESCRIPTION OF A SUBROUTINE =======================-->
<A NAME="get_close_maxdist_init"></A>
<div class=routine>
<em class=call> call get_close_maxdist_init(gc, maxdist) </em>
<pre>
type(get_close_type), intent(inout) :: <em class=code>gc</em>
real(r8),             intent(in)    :: <em class=code>maxdist</em>
</pre></div>

<div class=indent1>
<P>
Pass-through to the 3-D sphere locations module routine of the same name. See 
<A HREF="../../location/threed_sphere/location_mod.html#get_close_maxdist_init">
location_mod:get_close_maxdist_init()</A> for the documentation of this subroutine.
</P>
</div>

<!--=================================================================-->
<!--============= DESCRIPTION OF A SUBROUTINE =======================-->
<A NAME="get_close_obs_init"></A>
<div class=routine>
<em class=call> call get_close_obs_init(gc, num, obs) </em>
<pre>
type(get_close_type), intent(inout) :: <em class=code>gc</em>
integer,              intent(in)    :: <em class=code>num</em>
type(location_type),  intent(in)    :: <em class=code>obs(num)</em>
</pre></div>

<div class=indent1>
<P>
Pass-through to the 3-D sphere locations module. See
<A HREF="../../location/threed_sphere/location_mod.html#get_close_obs_init">
get_close_obs_init()</A> for the documentation of this subroutine.
</P>
</div>

<!--================================================================-->
<!--=================== DESCRIPTION OF SUBROUTINE ====================-->

<A NAME="pert_model_state"></A>
<div class=routine>
<em class=call>call pert_model_state(state, pert_state, interf_provided)</em>
<pre>
real(r8), dimension(:),   intent(in)    :: <em class=code> state </em>
real(r8), dimension(:),   intent(out)   :: <em class=code> pert_state </em>
logical,                  intent(out)   :: <em class=code> interf_provided </em>
</pre></div>

<div class=indent1>
<P>
Given a model state, produces a perturbed model state. This is used to
generate ensemble initial conditions perturbed around some control
trajectory state when one is preparing to spin-up ensembles. A DART
compliant model can choose not to provide an implementation of this
algorithm and use the default mechanism in DART by simply returning .false.
as a returned value for the interf_provided argument. In this case, DART
perturbs the state to generate ensemble members by adding a random sample
from a N(0.0, 0.002) distribution independently to each state variable.
Models should override this if some structure is required for perturbations
or if the magnitude of perturbations in DART is wrong.
</P>

<P>
This implementation allows each field in the state vector to be randomly
perturbed with a separate standard deviation.  The fields to be perturbed,
and the associated standard deviations are specified in the model_mod
namelist using state_names_pert and state_names_sd.  The entries in
state_names_pert should be in the same order as those in state_names_#d (#
= 0,1,2,3 in that order).  As in the default, the perturbations sd*N[0,1]
are added onto the basic state field, so sd should not be a percentage of
the basic state field, but an actual physical size.
</P>

<P>
This subroutine is also used by trans_pv_sv_pert0 for the off-line
perturbation of fields the model considers to be parameters.  In this use a
new random sequence seed must be provided via an input file ("ens_member")
for each ensemble member, since trans_pv_sv_pert0 is executed once for each
member and can't keep a series of different seeds intact.  
</P>


<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>state</em></TD>
    <TD>State vector to be perturbed.</TD></TR>

<TR><TD valign=top><em class=code>pert_state</em></TD>
    <TD>Perturbed state vector is returned. </TD></TR>

<TR><TD valign=top><em class=code>interf_provided</em></TD>
    <TD>Return false to have DART perturb state .</TD></TR>

</TABLE>
<br>
</div>

<!--================================================================-->
<!--=================== DESCRIPTION OF SUBROUTINE ====================-->

<A NAME="adv_1step"></A>
<div class=routine>
<em class=call>call adv_1step(x, time)</em>
<pre>
real(r8), dimension(:),   intent(inout) :: <em class=code> x </em>
type(time_type),          intent(in)    :: <em class=code> time </em>
</pre></div>

<div class=indent1>
<P>
This operation is not defined for the CAM model. 
This interface is only required if `synchronous' model state advance 
is supported (the model is called directly as a Fortran90 subroutine 
from the assimilation programs). This is generally not the preferred 
method for large models and a stub for this interface is provided for the CAM model.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>x</em></TD>
    <TD>State vector of length model_size.</TD></TR>

<TR><TD valign=top><em class=code>time</em></TD>
    <TD>Gives time of the initial model state. Needed for models that 
have real time state requirements, for instance the computation of 
radiational parameters. Note that DART provides a time_manager_mod 
module that is used to support time computations throughout the facility. </TD></TR>

</TABLE>
<br>
</div>


<!--================================================================-->
<!--=================== DESCRIPTION OF SUBROUTINE ====================-->

<A NAME="end_model"></A>
<div class=routine>
<em class=call>call end_model( )</em>
</div>

<div class=indent1>
<P>
Called when use of a model is completed to clean up storage, etc. 
A stub is provided for the CAM model.
</P>
</div>


<!--================================================================-->
<!--=================== DESCRIPTION OF SUBROUTINE ====================-->

<A NAME="init_time"></A>
<div class=routine>
<em class=call>call init_time(time) </em>
<pre>
type(time_type),          intent(<em class="changed">out</em>)    :: <em class=code> time </em>
</pre></div>

<div class=indent1>
<P>
Returns the time at which the model will start if no input initial conditions are 
to be used. This is frequently used to spin-up models from rest, but is not 
meaningfully supported for the CAM model. 
</P>
</div>


<!--================================================================-->
<!--=================== DESCRIPTION OF SUBROUTINE ====================-->

<A NAME="init_conditions"></A>
<div class=routine>
<em class=call>call init_conditions( x )</em>
<pre>
real(r8), dimension(:),   intent(out)   :: <em class=code> x </em>
</pre></div>

<div class=indent1>
<P>
Returns default initial conditions for model; generally used for spinning up 
initial model states. For the CAM model it's just a stub because initial 
state is always to be provided from input files.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>x</em></TD>
    <TD>Model state vector.</TD></TR>

</TABLE>
<br>
</div>


<!--==================================================================-->
<!-- End of PUBLIC entities.                                    -->
<!--==================================================================-->

<!--==================================================================-->
<!-- Declare all private entities.                                    -->
<!--==================================================================-->

<A NAME="PrivateComponents"></A>
<div class="top">[<a href="#">top</a>]</div><hr />
<H2>PRIVATE COMPONENTS</H2>

<P>
Here they are listed alphabetically.  Following this list they are listed in 
the order in which they appear in model_mod.f90, which is separated into sections
corresponding to the main functions of model_mod.f90: static_init_model,
I/O, model_interpolate, vector<->field translations, get_close_obs, and
utility routines.
</P>

<TABLE>
<TR><TD><em class=call>use model_mod, only : </em></TD>
                   <TD><A HREF="#convert_vert">convert_vert</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#coord_val">coord_val</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#coord_index">coord_index</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#dcz2">dcz2</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#end_grid_1d_instance">end_grid_1d_instance</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#end_model_instance">end_model_instance</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#find_name">find_name</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_interp_prof">get_interp_prof</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_val">get_val</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_val_level">get_val_level</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_val_height">get_val_height</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_val_pressure">get_val_pressure</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#gph2gmh">gph2gmh</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#gravity">gravity</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#index_from_grid">index_from_grid</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#init_grid_1d_instance">init_grid_1d_instance</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#init_model_instance">init_model_instance</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#map_kinds">map_kinds</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#model_heights">model_heights</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#read_cam_coord">read_cam_coord</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#read_cam_horiz">read_cam_horiz</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#read_cam_init_size">read_cam_init_size</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#read_topog_size">read_topog_size</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#order_state_fields">order_state_fields</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#plevs_cam">plevs_cam </A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#set_ps_arrays">set_ps_arrays</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#trans_coord">trans_coord</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#write_cam_coord_def">write_cam_coord</A></TD></TR>

</TABLE>
<br>


 <!--================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="read_cam_init_size"></A>
 <div class=routine>
 <em class=call> call read_cam_init_size(file_name, num_lons, num_lats, num_levs) </em>
 <pre>
 character(len, intent(in) :: <em class=code>file_name</em>
 integer, intent(out)      :: <em class=code>num_lons</em>
 integer, intent(out)      :: <em class=code>num_lats</em>
 integer, intent(out)      :: <em class=code>num_levs</em>
 </pre></div>

 <div class=indent1>
 <P>
 Gets the number of lons, lats and levels from a netcdf CAM initial file
 </P>
 <TABLE width=100% border=0 summary="" cellpadding=3>
 <TR><TD valign=top><em class=code>file_name&nbsp; &nbsp; </em></TD>
     <TD>CAM initial file.</TD></TR>
 <TR><TD valign=top><em class=code>num_lons&nbsp; &nbsp; </em></TD>
     <TD>Number of longitudes in this CAM resolution.</TD></TR>
 <TR><TD valign=top><em class=code>num_lats&nbsp; &nbsp; </em></TD>
     <TD>Number of latitudes.</TD></TR>
 <TR><TD valign=top><em class=code>num_levs&nbsp; &nbsp; </em></TD>
     <TD>Number of data levels.</TD></TR>
 </TABLE>
<br>
</div>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="trans_coord"></A>
 <div class=routine>
 <em class=call> call trans_coord(ncfileid) </em>
 <pre>
 integer, intent(in) :: <em class=code>ncfileid</em>
 </pre></div>

 <div class=indent1>
 <P>
 Rearranges sizes of the coordinates of each variable as found on caminput.nc file 
 (stored in variable f_dim_#d)
 into the order model_mod wants to see them for the state (s_dim_#d); lev, lon, lat.
 # = 1,2,3 for the numbers of dimensions of the variables.
 </P>

 <TABLE width=100% border=0 summary="" cellpadding=3>
 <TR><TD valign=top><em class=code>ncfileid&nbsp; &nbsp; </em></TD>
     <TD>The file ID number of the caminput.nc file.</TD></TR>
 </TABLE>

 <P>
  Uses the model_version from input.nml:model_nml to figure out the order
  of lev, lat, and lon on the caminput.nc file.
  Designed to be flexible enough to handle staggered and unstaggered U and V,
  2D fields which may be (lev,lat) instead of (lon,lat), and unstructured
  grids which may come from HOMME or the CLM.
 </P>
</div>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="read_topog_size"></A>
 <div class=routine>
 <em class=call> call read_topog_size(ncfileid, num_lons, num_lats) </em>
 <pre>
 integer, intent(in)   :: <em class=code>ncfileid</em>
 integer, intent(out)  :: <em class=code>num_nlons</em>
 integer, intent(out)  :: <em class=code>num_nlats</em>
 </pre></div>

 <div class=indent1>
 <P>
 Reads the grid size from the cam_phis.nc file, which contains the surface
 elevation data.
 </P>
 <TABLE width=100% border=0 summary="" cellpadding=3>
 <TR><TD valign=top><em class=code>ncfileid&nbsp; &nbsp; </em></TD>
     <TD>The file ID number of the cam_phis.nc file.</TD></TR>
 <TR><TD valign=top><em class=code>num_nlons&nbsp; &nbsp; </em></TD>
     <TD>Number of model longitudes.</TD></TR>
 <TR><TD valign=top><em class=code>num_nlats&nbsp; &nbsp; </em></TD>
     <TD>Number of model latitudes</TD></TR>
 </TABLE>
<br>
</div>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="read_cam_horiz"></A>
 <div class=routine>
 <em class=call> call read_cam_horiz(ncfileid, var, dim1, dim2, cfield) </em>
 <pre>
 integer, intent(in)                          :: <em class=code>ncfileid</em>
 real(r8), dimension(dim1, dim2), intent(out) :: <em class=code>var</em>
 integer, intent(in)                          :: <em class=code>dim1</em>
 integer, intent(in)                          :: <em class=code>dim2</em>
 character, len=8,  intent(in)                :: <em class=code>cfield</em>
 </pre></div>

 <div class=indent1>
 <P>
 Read a 2-D field from a NetCDF file, so far just surface height (phis)
 from cam_phis.nc.
 </P>
 <TABLE width=100% border=0 summary="" cellpadding=3>
 <TR><TD valign=top><em class=code>ncfileid&nbsp; &nbsp; </em></TD>
     <TD>The file ID number of the caminput.nc file.</TD></TR>
 <TR><TD valign=top><em class=code>var&nbsp; &nbsp; </em></TD>
     <TD>The surface height values returned to the calling routine.</TD></TR>
 <TR><TD valign=top><em class=code>dim1&nbsp; &nbsp; </em></TD>
     <TD>The size of the first dimension of var.</TD></TR>
 <TR><TD valign=top><em class=code>dim2&nbsp; &nbsp; </em></TD>
     <TD>Similarly for 2nd dimension.</TD></TR>
 <TR><TD valign=top><em class=code>cfield&nbsp; &nbsp; </em></TD>
     <TD> Name of the field (on the file) to be read.</TD></TR>
 </TABLE>
<br>
</div>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="nc_read_model_atts"></A>
 <div class=routine>
 <em class=call> call nc_read_model_atts(att,att_vals,nflds) </em>
 <pre>
 character, intent(in)                :: <em class=code>att</em>
 character, dimension(:), intent(out) :: <em class=code>att_vals</em>
 integer, intent(in)                  :: <em class=code>nflds</em>
 </pre></div>

 <div class=indent1>
 <P>
 Reads the value of an attribute for each of the fields in cflds.
 </P>
 <TABLE width=100% border=0 summary="" cellpadding=3>
 <TR><TD valign=top><em class=code>att&nbsp; &nbsp; </em></TD>
     <TD>The name of an attribute of the fields on a CAM initial file.</TD></TR>
 <TR><TD valign=top><em class=code>att_vals&nbsp; &nbsp; </em></TD>
     <TD>The values which that attribute has for each of the nflds fields needed
  for the state vector.</TD></TR>
 <TR><TD valign=top><em class=code>nflds&nbsp; &nbsp; </em></TD>
     <TD>The number of fields in the state vector.</TD></TR>
 </TABLE>
<br>
</div>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="read_cam_coord"></A>
 <div class=routine>
 <em class=call> call read_cam_coord(var,idim,cfield) </em>
 <pre>
 type(grid_1d_type), intent(out) :: <em class=code>var</em>
 integer, intent(in)             :: <em class=code>idim</em>
 character, intent(in)           :: <em class=code>cfield</em>
 </pre></div>

 <div class=indent1>
 <P>
 Reads a coordinate array and metadata from a CAM initial file.
 </P>
 <TABLE width=100% border=0 summary="" cellpadding=3>
 <TR><TD valign=top><em class=code>var&nbsp; &nbsp; </em></TD>
     <TD>A coordinate array from a CAM initial file.</TD></TR>
 <TR><TD valign=top><em class=code>idim&nbsp; &nbsp; </em></TD>
     <TD>Length of var.</TD></TR>
 <TR><TD valign=top><em class=code>cfield&nbsp; &nbsp; </em></TD>
     <TD>Name of var, as found on the CAM initial file.</TD></TR>
 </TABLE>
<br>
</div>
  
 <!--================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="init_grid_1D_instance"></A>
 <div class=routine>
 <em class=call> call init_grid_1d_instance(var, length, num_atts) </em>
 <pre>
 type(grid_1d_type), intent(out) :: <em class=code>var</em>
 integer,            intent(in ) :: <em class=code>length</em>
 integer,            intent(in ) :: <em class=code>num_atts</em>
 </pre></div>

 <div class=indent1>
 <P>
 Allocate space for the variable of defined type grid_1d_type.
 Put vector length and the number of attributes in structure.
 These are coordinate variables read from caminput.nc, and have
 lots of characteristics which are helpful to keep together in
 one structure.  The rest of <em class=code>var</em> is filled 
 in read_cam_coord.
 </P>
 <TABLE width=100% border=0 summary="" cellpadding=3>
 <TR><TD valign=top><em class=code>var&nbsp; &nbsp; </em></TD>
     <TD>The coordinate variable to read from caminput.nc.</TD></TR>
 <TR><TD valign=top><em class=code>length&nbsp; &nbsp; </em></TD>
     <TD>The length of var.  </TD></TR>
 <TR><TD valign=top><em class=code>num_atts&nbsp; &nbsp; </em></TD>
     <TD>The number of attributes of this coordinate, from caminput.nc.</TD></TR>
 </TABLE>

 <pre>
   type grid_1d_type
      private
      character (len=8)            :: label          ! e.g. 'lat     '
      integer                      :: dim_id         ! NetCDF dimension ID from the file
      integer                      :: length         ! number of elements in the coordinate array
      real(r8)                     :: resolution     ! spacing between elements, or 0. for irreg.
      real(r8), pointer            :: vals(:)        ! coordinate values
      integer                      :: num_atts       ! number of NetCDF attributes
      character (len=128), pointer :: atts_names(:)  ! names of those attributes
      character (len=128), pointer :: atts_vals(:)   ! values of those attributes
   end type grid_1d_type
 </pre>
</div>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="end_grid_1d_instance"></A>
 <div class=routine>
 <em class=call> call end_grid_1d_instance(var) </em>
 <pre>
 type(grid_1d_type), intent(in) :: <em class=code>var</em>
 </pre></div>

 <div class=indent1>
 <P>
 Deallocate the array components of the variable of defined type grid_1d_type.
 </P>
 <TABLE width=100% border=0 summary="" cellpadding=3>
 <TR><TD valign=top><em class=code>var&nbsp; &nbsp; </em></TD>
     <TD>Coordinate variable and metadata.</TD></TR>
 </TABLE>
<br>
</div>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="order_state_fields"></A>
 <div class=routine>
 <em class=call> call order_state_fields(cflds,nflds) </em>
 <pre>
 character, dimension(:), intent(out) :: <em class=code>cflds</em>
 integer, intent(in)                  :: <em class=code>nflds</em>
 </pre></div>

 <div class=indent1>
 <P>
 Fills cflds with state_names for use in I/O of caminput.nc
 Also assigns field TYPE_ variables for use by get_state_meta_data,
 and other routines.
 </P>
 <TABLE width=100% border=0 summary="" cellpadding=3>
 <TR><TD valign=top><em class=code>cflds&nbsp; &nbsp; </em></TD>
     <TD>Master list of CAM fields to be incorporated in the DART state vector.</TD></TR>
 <TR><TD valign=top><em class=code>nflds&nbsp; &nbsp; </em></TD>
     <TD>Number of CAM fields in the state vector.</TD></TR>
 </TABLE>
<br>
 </div>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="map_kinds"></A>
 <div class=routine>
 <em class=call> call map_kinds() </em>
 <pre>
 </pre></div>

 <div class=indent1>
 <P>
 Makes an array (dart_to_cam_kinds) of 'locations within the state vector'
 of all the available obs kinds that come from obs_kind_mod.
 Also maps the local model_mod TYPE_s onto the DART KIND_s by the same mechanism.
 </P>

 <P>
  The obs kind that's needed will be the index into this array,
  the corresponding value will be the position of that field (not individual variable)
  within the state vector according to state_name_Xd.
  This subroutine is called from static_init_model, 
  and arrays dart_to_cam_kinds and cam_to_dart_kinds are global,
  so they will not have to be recomputed for every obs.
 </P>
</div>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="write_cam_coord_def"></A>
 <div class=routine>
 <em class=call> call write_cam_coord_def(ncFileID, c_name, coord, dim_id, c_id) </em>
 <pre>
  character (len=8),  intent(in)  :: <em class=code>c_name</em>
  integer,            intent(in)  :: <em class=code>ncFileID</em>
  integer,            intent(in)  :: <em class=code>dim_id</em>
  type(grid_1d_type), intent(in)  :: <em class=code>coord</em>
  integer,            intent(out) :: <em class=code>c_id</em>
 </pre></div>

 <div class=indent1>
 <P>
  Define a coordinate variable on the P[oste]rior_Diag.nc file
  and write some of it's attributes there.
 </P>
 <TABLE width=100% border=0 summary="" cellpadding=3>
 <TR><TD valign=top><em class=code>c_name&nbsp; &nbsp; </em></TD>
     <TD> Coordinate name.</TD></TR>
 <TR><TD valign=top><em class=code>ncFileID&nbsp; &nbsp; </em></TD>
     <TD> Integer ID number of the NetCDF file.</TD></TR>
 <TR><TD valign=top><em class=code>dim_id&nbsp; &nbsp; </em></TD>
     <TD> The dimension ID of the coordinate on the NetCDF file.</TD></TR>
 <TR><TD valign=top><em class=code>coord&nbsp; &nbsp; </em></TD>
     <TD> Coordinate values and metadata.</TD></TR>
 <TR><TD valign=top><em class=code>c_id&nbsp; &nbsp; </em></TD>
     <TD> Coordinate variable ID number on the NetCDF file.</TD></TR>
 </TABLE>
<br>
</div>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="get_val_level"></A>
 <div class=routine>
 <em class=call> call get_val_level(val,x,lon_index,lat_index,level,
                 obs_kind,istatus) </em>
 <pre>
 real(r8), intent(out)                           :: <em class=code>val</em>
 real(r8), allocatable, dimension(:), intent(in) :: <em class=code>x</em>
 integer, intent(in)                             :: <em class=code>lon_index</em>
 integer, intent(in)                             :: <em class=code>lat_index</em>
 integer, intent(in)                             :: <em class=code>level</em>
 integer, intent(in)                             :: <em class=code>obs_kind</em>
 integer, intent(out)                            :: <em class=code>istatus</em>
 </pre></div>

 <div class=indent1>
 <P>
 Gets the value on the model level for variable obs_kind
 at the lon_index, lat_index horizontal grid point.  Some quality control of
 observations is done here, but may be moved later.  For now, observations
 above the lower of highest_obs_level and the models highest level,
 and below the lowest model level are excluded.  So are PS and Q observations.
 </P>
 <TABLE width=100% border=0 summary="" cellpadding=3>
 <TR><TD valign=top><em class=code>val&nbsp; &nbsp; </em></TD>
     <TD>The value of the obs_kind variable interpolated from state vector x.</TD></TR>
 <TR><TD valign=top><em class=code>x&nbsp; &nbsp; </em></TD>
     <TD>DART state vector.</TD></TR>
 <TR><TD valign=top><em class=code>lon_index&nbsp; &nbsp; </em></TD>
     <TD>Index of longitude of this val.</TD></TR>
 <TR><TD valign=top><em class=code>lat_index&nbsp; &nbsp; </em></TD>
     <TD>Index of latitude of this val.</TD></TR>
 <TR><TD valign=top><em class=code>level&nbsp; &nbsp; </em></TD>
     <TD>The level for which this obs_kind must be retrieved.</TD></TR>
 <TR><TD valign=top><em class=code>obs_kind&nbsp; &nbsp; </em></TD>
     <TD>The kind of variable being interpolated, i.e. T.</TD></TR>
 <TR><TD valign=top><em class=code>istatus&nbsp; &nbsp; </em></TD>
     <TD>Flag containing the status of the interpolation. 0=all good, 1=can't 
 interpolate, 2=can interpolate but don't use the value.</TD></TR>
 </TABLE>
<br>
 </div>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="get_val_pressure"></A>
 <div class=routine>
 <em class=call> call get_val_pressure(val,x,lon_index,lat_index,pressure,
                 obs_kind,istatus) </em>
 <pre>
 real(r8), intent(out)                           :: <em class=code>val</em>
 real(r8), allocatable, dimension(:), intent(in) :: <em class=code>x</em>
 integer, intent(in)                             :: <em class=code>lon_index</em>
 integer, intent(in)                             :: <em class=code>lat_index</em>
 real(r8), intent(in)                            :: <em class=code>pressure</em>
 integer, intent(in)                             :: <em class=code>obs_kind</em>
 integer0, intent(out)                           :: <em class=code>istatus</em>
 </pre></div>

 <div class=indent1>
 <P>
 Gets the vertically interpolated value on pressure for variable obs_kind
 at the lon_index, lat_index horizontal grid point.  Some quality control of
 observations is done here, but may be moved later.  For now, observations
 above the lower of highest_obs_pressure_mb and the model's highest level,
 and below the lowest model level are excluded.  
 </P>
 <TABLE width=100% border=0 summary="" cellpadding=3>
 <TR><TD valign=top><em class=code>val&nbsp; &nbsp; </em></TD>
     <TD>The value of the obs_kind variable interpolated from state vector x.</TD></TR>
 <TR><TD valign=top><em class=code>x&nbsp; &nbsp; </em></TD>
     <TD>DART state vector.</TD></TR>
 <TR><TD valign=top><em class=code>lon_index&nbsp; &nbsp; </em></TD>
     <TD>Index of longitude of this val.</TD></TR>
 <TR><TD valign=top><em class=code>lat_index&nbsp; &nbsp; </em></TD>
     <TD>Index of latitude of this val.</TD></TR>
 <TR><TD valign=top><em class=code>pressure&nbsp; &nbsp; </em></TD>
     <TD>The pressure to which this obs_kind must be interpolated.</TD></TR>
 <TR><TD valign=top><em class=code>obs_kind&nbsp; &nbsp; </em></TD>
     <TD>The kind of variable being interpolated, i.e. T.</TD></TR>
 <TR><TD valign=top><em class=code>istatus&nbsp; &nbsp; </em></TD>
     <TD>Flag containing the status of the interpolation. 0=all good, 1=can't 
 interpolate, 2=can interpolate but don't use the value.</TD></TR>
 </TABLE>
<br>
 </div>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="get_val_height"></A>
 <div class=routine>
 <em class=call> call get_val_height(val,x,lon_index,lat_index,height,
                 obs_kind,istatus) </em>
 <pre>
 real(r8), intent(out)                           :: <em class=code>val</em>
 real(r8), allocatable, dimension(:), intent(in) :: <em class=code>x</em>
 integer, intent(in)                             :: <em class=code>lon_index</em>
 integer, intent(in)                             :: <em class=code>lat_index</em>
 real(r8), intent(in)                            :: <em class=code>height</em>
 integer, intent(in)                             :: <em class=code>obs_kind</em>
 integer, intent(out)                            :: <em class=code>istatus</em>
 </pre></div>

 <div class=indent1>
 <P>
 Gets the vertically interpolated value on height for variable obs_kind
 at the lon_index, lat_index horizontal grid point.  Some quality control of
 observations is done here, but may be moved later.  For now, observations
 above the lower of highest_obs_height_m and the model's highest level,
 and below the lowest model level are excluded.  So are PS and Q observations.
 </P>
 <TABLE width=100% border=0 summary="" cellpadding=3>
 <TR><TD valign=top><em class=code>val&nbsp; &nbsp; </em></TD>
     <TD>The value of the obs_kind variable interpolated from state vector x.</TD></TR>
 <TR><TD valign=top><em class=code>x&nbsp; &nbsp; </em></TD>
     <TD>DART state vector.</TD></TR>
 <TR><TD valign=top><em class=code>lon_index&nbsp; &nbsp; </em></TD>
     <TD>Index of longitude of this val.</TD></TR>
 <TR><TD valign=top><em class=code>lat_index&nbsp; &nbsp; </em></TD>
     <TD>Index of latitude of this val.</TD></TR>
 <TR><TD valign=top><em class=code>height&nbsp; &nbsp; </em></TD>
     <TD>The height to which this obs_kind must be interpolated.</TD></TR>
 <TR><TD valign=top><em class=code>obs_kind&nbsp; &nbsp; </em></TD>
     <TD>The kind of variable being interpolated, i.e. T.</TD></TR>
 <TR><TD valign=top><em class=code>istatus&nbsp; &nbsp; </em></TD>
     <TD>Flag containing the status of the interpolation. 0=all good, 1=can't 
 interpolate, 2=can interpolate but don't use the value.</TD></TR>
 </TABLE>
<br>
 </div>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="get_val"></A>
 <div class=routine>
 <em class=call> call get_val(val,x,lon_index,lat_index,level,obs_kind,istatus) </em>
 <pre>
 real(r8), intent(out)                           :: <em class=code>val</em>
 real(r8), allocatable, dimension(:), intent(in) :: <em class=code>x</em>
 integer, intent(in)                             :: <em class=code>lon_index</em>
 integer, intent(in)                             :: <em class=code>lat_index</em>
 integer, intent(in)                             :: <em class=code>level</em>
 integer, intent(in)                             :: <em class=code>obs_kind</em>
 integer, intent(out)                            :: <em class=code>istatus</em>
 </pre></div>

 <div class=indent1>
 <P>
 Extracts the value of a field at a specified location from the DART state vector.
 </P>
 <TABLE width=100% border=0 summary="" cellpadding=3>
 <TR><TD valign=top><em class=code>val&nbsp; &nbsp; </em></TD>
     <TD>The value of the obs_kind variable at a grid point, from state vector x.</TD></TR>
 <TR><TD valign=top><em class=code>x&nbsp; &nbsp; </em></TD>
     <TD>DART state vector.</TD></TR>
 <TR><TD valign=top><em class=code>lon_index&nbsp; &nbsp; </em></TD>
     <TD>Index of longitude of this val.</TD></TR>
 <TR><TD valign=top><em class=code>lat_index&nbsp; &nbsp; </em></TD>
     <TD>Index of latitude of this val.</TD></TR>
 <TR><TD valign=top><em class=code>level&nbsp; &nbsp; </em></TD>
     <TD>The level of the obs_kind variable desired.</TD></TR>
 <TR><TD valign=top><em class=code>obs_kind&nbsp; &nbsp; </em></TD>
     <TD>The kind of variable being interpolated, i.e. T.</TD></TR>
 <TR><TD valign=top><em class=code>istatus&nbsp; &nbsp; </em></TD>
     <TD>Flag containing the status of the interpolation. 0=all good, 1=can't in
 terpolate, 2=can interpo but don't use the value.</TD></TR>
 </TABLE>
<br>
</div>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="convert_vert"></A>
 <div class=routine>
 <em class=call> call convert_vert(old_array, old_which, new_array, new_which, dart_kind) </em>
 <pre>
  real(r8), dimension(3), intent(in)    :: old_array
  integer,                intent(in)    :: old_which
  real(r8), dimension(3), intent(inout) :: new_array
  integer,                intent(out)   :: new_which
  integer,                intent(in)    :: dart_kind
 </pre></div>

 <div class=indent1>
 <P>
  Uses model information and subroutines to convert the vertical location of an ob
  (prior, model state variable, or actual ob) into the standard vertical coordinate (pressure).
 </P>
 <TABLE width=100% border=0 summary="" cellpadding=3>
 <TR><TD valign=top><em class=code>old_array&nbsp; &nbsp; </em></TD>
     <TD>The location array of the incoming ob.</TD></TR>
 <TR><TD valign=top><em class=code>old_which&nbsp; &nbsp; </em></TD>
     <TD>The vertical coordinate type of the incoming ob.</TD></TR>
 <TR><TD valign=top><em class=code>new_array&nbsp; &nbsp; </em></TD>
     <TD>The location array of the converted ob.</TD></TR>
 <TR><TD valign=top><em class=code>new_which&nbsp; &nbsp; </em></TD>
     <TD>The vertical coordinate type of the converted ob.</TD></TR>
 <TR><TD valign=top><em class=code>dart_kind&nbsp; &nbsp; </em></TD>
     <TD>The location array of the incoming ob.</TD></TR>
 </TABLE>

 <P>
  Called by model_mod:get_close_obs.
  Accommodates staggered grid US and VS of the FV core.
 </P>
</div>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="index_from_grid"></A>
 <div class=routine>
 <em class=call> index = index_from_grid(lev_ind, lon_ind, lat_ind, ifld) </em>
 <pre>
  integer, intent(in) :: <em class=code>lev_ind</em>
  integer, intent(in) :: <em class=code>lon_ind</em>
  integer, intent(in) :: <em class=code>lat_ind</em>
  integer, intent(in) :: <em class=code>ifld</em>
 </pre></div>

 <div class=indent1>
 <P>
  Function to generate the state vector index corresponding to the grid location
  and variable given.
 </P>
 <TABLE width=100% border=0 summary="" cellpadding=3>
 <TR><TD valign=top><em class=code>lev_ind&nbsp; &nbsp; </em></TD>
     <TD>Level of the desired variable.</TD></TR>
 <TR><TD valign=top><em class=code>lon_ind&nbsp; &nbsp; </em></TD>
     <TD>Longitude of the desired variable.</TD></TR>
 <TR><TD valign=top><em class=code>lat_ind&nbsp; &nbsp; </em></TD>
     <TD>Latitude of the desired variable.</TD></TR>
 <TR><TD valign=top><em class=code>ifld&nbsp; &nbsp; </em></TD>
     <TD>TYPE_ (PS or T or ...) index of the variable whose index is needed.</TD></TR>
 </TABLE>

 <P>
  Called by many routines.
 </P>
 </div>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="find_name"></A>
 <div class=routine>
 <em class=call> name = find_name(nam, list) </em>
 <pre>
  character (len=*),              intent(in) :: <em class=code>nam</em>
  character (len=*), dimension(:),intent(in) :: <em class=code>list</em>
 </pre></div>

 <div class=indent1>
 <P>
  Function to return the index of a character string as found within a list
  of character strings, typically variable or dimension names.
 </P>
 <TABLE width=100% border=0 summary="" cellpadding=3>
 <TR><TD valign=top><em class=code>nam&nbsp; &nbsp; </em></TD>
     <TD>The string to be found within <em class=code>list</em>.</TD></TR>
 <TR><TD valign=top><em class=code>list&nbsp; &nbsp; </em></TD>
     <TD>The list which hopefully contains <em class=code>nam</em>.</TD></TR>
 </TABLE>
<br>
 </div>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="coord_val"></A>
 <div class=routine>
 <em class=call> call coord_val(dim_name, indx, lon_val, lat_val, lev_val) </em>
 <pre>
  character (len=8), intent(in)    :: <em class=code>dim_name</em>
  integer,           intent(in)    :: <em class=code>indx</em>
  real(r8),          intent(inout) :: <em class=code>lon_val</em>
  real(r8),          intent(inout) :: <em class=code>lat_val</em>
  real(r8),          intent(inout) :: <em class=code>lev_val</em>
 </pre></div>

 <div class=indent1>
 <P>
  Given the name of the coordinate to be searched and the index into that array,
  returns the coordinate value  in either lon_val, lat_val, or lev_val.
 </P>
 <TABLE width=100% border=0 summary="" cellpadding=3>
 <TR><TD valign=top><em class=code>dim_name&nbsp; &nbsp; </em></TD>
     <TD>The name of the dimension being searched for the value at an index.</TD></TR>
 <TR><TD valign=top><em class=code>indx&nbsp; &nbsp; </em></TD>
     <TD>The index of the variable whose location is needed.</TD></TR>
 <TR><TD valign=top><em class=code>lon_val&nbsp; &nbsp; </em></TD>
     <TD>(Possibly) the location of the grid point in the longitudinal direction.</TD></TR>
 <TR><TD valign=top><em class=code>lat_val&nbsp; &nbsp; </em></TD>
     <TD>(Possibly) the location of the grid point in the latitudinal direction.</TD></TR>
 <TR><TD valign=top><em class=code>lev_val&nbsp; &nbsp; </em></TD>
     <TD>(Possibly) the location of the grid point in the vertical direction.</TD></TR>
 </TABLE>

 <P>
  All 3 _val arguments are present so that this routine can return the value
  in the coordinate that the calling routine wants it to be, and search/placement doesn't
  have to be done there.
  Used by get_state_meta_data and model_interpolate.
 </P>
 </div>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="coord_index"></A>
 <div class=routine>
    <em class=call> call coord_index(dim_name, val, indx 
                    <em class=optionalcode>, other_indx</em>) </em>
 <pre>
  character (len=8), intent(in)  :: <em class=code>dim_name</em>
  real(r8),          intent(in)  :: <em class=code>val</em>
  integer,           intent(out) :: <em class=code>indx</em>
  integer, optional, intent(out) :: <em class=optionalcode>other_indx</em>
 </pre></div>

 <div class=indent1>
 <P>
  Given the name of the coordinate to be searched and the coordinate value,
  Returns the index of the closest coordinate value.
  Optionally returns the next closest index too, which may be < or > the closest.
 </P>
 <TABLE width=100% border=0 summary="" cellpadding=3>
 <TR><TD valign=top><em class=code>dim_name&nbsp; &nbsp; </em></TD>
     <TD>The name of the dimension being searched for the value at an index.</TD></TR>
 <TR><TD valign=top><em class=code>val&nbsp; &nbsp; </em></TD>
     <TD>The coordinate value whose nearest neighbors are needed.</TD></TR>
 <TR><TD valign=top><em class=code>indx&nbsp; &nbsp; </em></TD>
     <TD>The index whose value is closest to <em class=code>val</em>.</TD></TR>
 <TR><TD valign=top><em class=optionalcode>other_indx&nbsp; &nbsp; </em></TD>
     <TD>The index whose value is 2nd closest to <em class=code>val</em>.</TD></TR>
 </TABLE>

 <P>
  Used by get_state_meta_data.
  Uses coordinate metadata to search differently, depending on whether coordinate
  is regularly spaced or not.
 </P>
 </div>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="set_ps_arrays"></A>
 <div class=routine>
 <em class=call> call set_ps_arrays(vec) </em>
 <pre>
  real(r8), intent(in) :: <em class=code>vec(:)</em>
 </pre></div>

 <div class=indent1>
 <P>
  Subroutine to put the ensemble average PS into a globally defined array.
  Also provides PS on the FV staggered grids, if needed.
 </P>
 <TABLE width=100% border=0 summary="" cellpadding=3>
 <TR><TD valign=top><em class=code>vec&nbsp; &nbsp; </em></TD>
     <TD>The ensemble average state vector.</TD></TR>
 </TABLE>
<br>
 </div>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="plevs_cam"></A>
 <div class=routine>
 <em class=call> call plevs_cam(ncol,ncold,ps,pmid) </em>
 <pre>
 integer, intent(in)                 :: <em class=code>ncol</em>
 integer, intent(in)                 :: <em class=code>ncold</em>
 real(r8), dimension(:), intent(in)  :: <em class=code>ps</em>
 real(r8), dimension(:), intent(out) :: <em class=code>pmid</em>
 </pre></div>

 <div class=indent1>
 <P>
 Define the pressures of the CAM data levels (layer midpoints) from the
 coordinate definitions and the surface pressure.
 </P>
 <TABLE width=100% border=0 summary="" cellpadding=3>
 <TR><TD valign=top><em class=code>ncol&nbsp; &nbsp; </em></TD>
     <TD>Number of columns of pressures to calculate (DART-CAM uses 1)</TD></TR>
 <TR><TD valign=top><em class=code>ncold&nbsp; &nbsp; </em></TD>
     <TD>Dimension of ps.</TD></TR>
 <TR><TD valign=top><em class=code>ps&nbsp; &nbsp; </em></TD>
     <TD>Surface pressure at this latitude and longitude (Pa).</TD></TR>
 <TR><TD valign=top><em class=code>pmid&nbsp; &nbsp; </em></TD>
     <TD>Pressures at the CAM "midpoint" levels.</TD></TR>
 </TABLE>
<br>
 </div>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="model_heights"></A>
 <div class=routine>
    <em class=call> call model_heights( x,lon_index,lat_index,model_h,istatus) </em>
 <pre>
 real(r8), dimension(:), intent(in)              :: <em class=code>x</em>
 integer, intent(in)                             :: <em class=code>lon_index</em>
 integer, intent(in)                             :: <em class=code>lat_index</em>
 real(r8), intent(out)                           :: <em class=code>model_h</em>
 integer, intent(out)                            :: <em class=code>istatus</em>
 </pre></div>

 <div class=indent1>
 <P>
 This routine calculates geometrical height (m) at mid-layers of the CAM model
 </P>
 <TABLE width=100% border=0 summary="" cellpadding=3>
 <TR><TD valign=top><em class=code>x&nbsp; &nbsp; </em></TD>
     <TD>DART state vector.</TD></TR>
 <TR><TD valign=top><em class=code>lon_index&nbsp; &nbsp; </em></TD>
     <TD>Index of longitude of this val.</TD></TR>
 <TR><TD valign=top><em class=code>lat_index&nbsp; &nbsp; </em></TD>
     <TD>Index of latitude of this val.</TD></TR>
 <TR><TD valign=top><em class=code>model_h&nbsp; &nbsp; </em></TD>
     <TD>geometrical height at midlayer (m).</TD></TR>
 <TR><TD valign=top><em class=code>istatus&nbsp; &nbsp; </em></TD>
     <TD>Status of the calculation returned to the calling routine.</TD></TR>
 </TABLE>
<br>
 </div>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="get_interp_prof"></A>
 <div class=routine>
 <em class=call> call get_interp_prof(prof, vec, num_levs, lon_index, lat_index,
                                      stagr_lon, stagr_lat, kind_cam, vstatus) </em>
 <pre>
  real(r8), intent(out) :: <em class=code>prof(num_levs)</em>
  real(r8), intent(in)  :: <em class=code>vec(:)</em>
  integer,  intent(in)  :: <em class=code>num_levs</em>
  integer,  intent(in)  :: <em class=code>lon_index</em>
  integer,  intent(in)  :: <em class=code>lat_index</em>
  logical,  intent(in)  :: <em class=code>stagr_lon</em>
  integer,  intent(in)  :: <em class=code>stagr_lat</em>
  integer,  intent(in)  :: <em class=code>kind_cam</em>
  integer,  intent(out) :: <em class=code>vstatus</em>
 </pre></div>

 <div class=indent1>
 <P>
  Interpolate the (4) nearest profiles to the needed location for the desired variable.
 </P>
 <TABLE width=100% border=0 summary="" cellpadding=3>
 <TR><TD valign=top><em class=code>prof&nbsp; &nbsp; </em></TD>
     <TD>The profile which results from the interpolation.</TD></TR>
 <TR><TD valign=top><em class=code>vec&nbsp; &nbsp; </em></TD>
     <TD>The (ensemble average) state vector.</TD></TR>
 <TR><TD valign=top><em class=code>num_levs&nbsp; &nbsp; </em></TD>
     <TD>Vertical size of the profile.</TD></TR>
 <TR><TD valign=top><em class=code>lon_index&nbsp; &nbsp; </em></TD>
     <TD>The longitude index of the point requiring a profile.</TD></TR>
 <TR><TD valign=top><em class=code>lat_index&nbsp; &nbsp; </em></TD>
     <TD>The latitude index of the point requiring a profile.</TD></TR>
 <TR><TD valign=top><em class=code>stagr_lon&nbsp; &nbsp; </em></TD>
     <TD>Flag to say whether kind_cam must be interpolated in the longitudinal direction.</TD></TR>
 <TR><TD valign=top><em class=code>stagr_lat&nbsp; &nbsp; </em></TD>
     <TD>Flag to say whether kind_cam must be interpolated in the latitudinal direction.</TD></TR>
 <TR><TD valign=top><em class=code>kind_cam&nbsp; &nbsp; </em></TD>
     <TD>The variable index whose profile is needed.</TD></TR>
 <TR><TD valign=top><em class=code>vstatus&nbsp; &nbsp; </em></TD>
     <TD>Reports the status of the calculations back to the calling routine.</TD></TR>
 </TABLE>

 <P>
  So far only called by routine model_heights, for getting T and Q profiles.
  Handles staggered variables in either or both directions.
  Pole points should be handled in the calling routine by passing the correct stagr_xx,
  so that this program can count on having values for all the lat and lon indices referenced.
 </P>
 </div>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="dcz2"></A>
 <div class=routine>
    <em class=call> call dcz2(ps,phis0,tv,hprb,hyba,hybb,kmax,idim,imax,pmln, &amp;
                            hypdln,hyalph,pterm,z2) </em>
 <pre>
 real(r8), dimension(idim), intent(in)           :: <em class=code>ps</em>
 real(r8), dimension(idim), intent(in)           :: <em class=code>phis0</em>
 real(r8), dimension(idim,kmax), intent(in)      :: <em class=code>tv</em>
 real(r8), intent(in)                            :: <em class=code>hprb</em>
 real(r8), dimension(2,kmax+1), intent(in)       :: <em class=code>hyba</em>
 real(r8), dimension(2,kmax+1), intent(in)       :: <em class=code>hybb</em>
 integer, intent(in)                             :: <em class=code>kmax</em>
 integer, intent(in)                             :: <em class=code>idim</em>
 integer, intent(in)                             :: <em class=code>imax</em>
 real(r8), dimension(idim,kmax+1), intent(in)    :: <em class=code>pmln</em>
 real(r8), dimension(idim,kmax), intent(in)      :: <em class=code>hypdln</em>
 real(r8), dimension(idim,kmax), intent(in)      :: <em class=code>hyalph</em>
 real(r8), dimension(idim,kmax), intent(in)      :: <em class=code>pterm</em>
 real(r8), dimension(idim,kmax), intent(out)     :: <em class=code>z2</em>
 </pre></div>

 <div class=indent1>
 <P>
 To compute geopotential height for a CCM2 hybrid coordinate
 vertical slice.  Since the vertical integration matrix is a
 function of latitude and longitude, it is not explicitly
 computed as for sigma coordinates.  The integration algorithm
 is derived from Boville's mods in the ibm file hybrid 1mods
 (6/17/88).  All vertical slice arrays are oriented top to
 bottom as in CCM2.  This field is on full model levels (aka
 "midpoints") not half levels.  See code for more history.
 </P>
 <TABLE width=100% border=0 summary="" cellpadding=3>
 <TR><TD valign=top><em class=code>ps&nbsp; &nbsp; </em></TD>
     <TD>Surface pressure (pascals).</TD></TR>
 <TR><TD valign=top><em class=code>phis0&nbsp; &nbsp; </em></TD>
 <TD> Surface geoptential.</TD></TR>
 <TR><TD valign=top><em class=code>tv&nbsp; &nbsp; </em></TD>
     <TD>Virtual temperature, top to bottom.</TD></TR>
 <TR><TD valign=top><em class=code>hprb&nbsp; &nbsp; </em></TD>
     <TD>Hybrid base pressure (pascals).</TD></TR>
 <TR><TD valign=top><em class=code>hyba&nbsp; &nbsp; </em></TD>
     <TD>Hybrid coord coeffs for base pressure.</TD></TR>
 <TR><TD valign=top><em class=code>hybb&nbsp; &nbsp; </em></TD>
     <TD>Hybrid coord coeffs for surf pressure (in same format as hyba).</TD></TR>
 <TR><TD valign=top><em class=code>kmax&nbsp; &nbsp; </em></TD>
     <TD>Number of vertical levels.</TD></TR>
 <TR><TD valign=top><em class=code>idim&nbsp; &nbsp; </em></TD>
     <TD>Longitude dimension.</TD></TR>
 <TR><TD valign=top><em class=code>imax&nbsp; &nbsp; </em></TD>
     <TD>Num of longitude points to compute.</TD></TR>
 <TR><TD valign=top><em class=code>pmln&nbsp; &nbsp; </em></TD>
     <TD>Vertical slice scratch space used to hold logs of midpoint pressures.</TD></TR>
 <TR><TD valign=top><em class=code>hpdln&nbsp; &nbsp; </em></TD>
     <TD>Vertical slice scratch space used to hold log p layer thickness.</TD></TR>
 <TR><TD valign=top><em class=code>hyalph&nbsp; &nbsp; </em></TD>
     <TD>Vertical slice scratch space used to hold distance from interface to level during 
         vertical integration.</TD></TR>
 <TR><TD valign=top><em class=code>pterm&nbsp; &nbsp; </em></TD>
     <TD>Vertical scratch space.</TD></TR>
 <TR><TD valign=top><em class=code>z2&nbsp; &nbsp; </em></TD>
     <TD>Geopotential height, top to bottom.</TD></TR>
 </TABLE>
<br>
 </div>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="gph2gmh"></A>
 <div class=routine>
 <em class=call> gph2gmh = gph2gmh(h, lat) </em>
 <pre>
 real(r8), intent(out)                           :: <em class=code>gph2gmh</em>
 real(r8), intent(in)                            :: <em class=code>h</em>
 real(r8), intent(in)                            :: <em class=code>lat</em>
 </pre></div>

 <div class=indent1>
 <P>
 Convert a geopotential altitude to mean sea level altitude.
 </P>
 <TABLE width=100% border=0 summary="" cellpadding=3>
 <TR><TD valign=top><em class=code>gph2gmh&nbsp; &nbsp; </em></TD>
     <TD>MSL altitude, in km.</TD></TR>
 <TR><TD valign=top><em class=code>h&nbsp; &nbsp; </em></TD>
     <TD>geopotential altitude (in km).</TD></TR>
 <TR><TD valign=top><em class=code>lat&nbsp; &nbsp; </em></TD>
     <TD>latitude in degrees.</TD></TR>
 </TABLE>
<br>
 </div>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="gravity"></A>
 <div class=routine>
 <em class=call> call gravity (xlat,alt,galt) </em>
 <pre>
 real(r8), intent(in)                            :: <em class=code>xlat</em>
 real(r8), intent(in)                            :: <em class=code>alt</em>
 real(r8), intent(out)                           :: <em class=code>galt</em>
 </pre></div>

 <div class=indent1>
 <P>
 This subroutine computes the Earth's gravity at any altitude
 and latitude.  The model assumes the Earth is an oblate 
 spheriod rotating at a the Earth's spin rate.  The model
 was taken from "Geophysical Geodesy, Kurt Lambeck, 1988".
 Compute acceleration due to the Earth's gravity at any latitude/altitude
 author     Bill Schreiner   5/95

 </P>
 <TABLE width=100% border=0 summary="" cellpadding=3>
 <TR><TD valign=top><em class=code>xlat&nbsp; &nbsp; </em></TD>
     <TD>latitude in radians.</TD></TR>
 <TR><TD valign=top><em class=code>alt&nbsp; &nbsp; </em></TD>
     <TD>altitude above the reference ellipsiod, km.</TD></TR>
 <TR><TD valign=top><em class=code>galt&nbsp; &nbsp; </em></TD>
     <TD>gravity at the given lat and alt, cm/sec.</TD></TR>
 </TABLE>
<br>
 </div>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="init_model_instance"></A>
 <div class=routine>
 <em class=call> call init_model_instance(var) </em>
 <pre>
 type(model_type), allocatable, intent(out) :: <em class=code>var</em>
 </pre></div>

 <div class=indent1>
 <P>
 Initializes an instance of a cam model state variable; all the fields
 specified for the state vector.
 </P>
 <TABLE width=100% border=0 summary="" cellpadding=3>
 <TR><TD valign=top><em class=code>var&nbsp; &nbsp; </em></TD>
     <TD>Structure which contains all the fields of various dimensions which are
  in the DART state vector.</TD></TR>
 </TABLE>

 <PRE>
 type model_type
     private
     real(r8), pointer :: vars_0d(:)           ! scalars
     real(r8), pointer :: vars_1d(:, :)        ! vectors
     real(r8), pointer :: vars_2d(:, :, :)     ! 2-D fields
     real(r8), pointer :: vars_3d(:, :, :, :)  ! 3-D fields
 end type model_type
 </PRE>
 </div>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="end_model_instance"></A>
 <div class=routine>
 <em class=call> call end_model_instance(var) </em>
 <pre>
 type(model_type), allocatable, intent(inout) :: <em class=code>var</em>
 </pre></div>

 <div class=indent1>
 <P>
 Ends an instance of a cam model_type state variable
 </P>
 <TABLE width=100% border=0 summary="" cellpadding=3>
 <TR><TD valign=top><em class=code>var&nbsp; &nbsp; </em></TD>
     <TD>Structure which contains all the fields included in the state vector.</TD></TR>
 </TABLE>
<br>
</div>



<!--==================================================================-->
<!-- Describe the Files Used by this module.                          -->
<!--==================================================================-->

<A NAME="FilesUsed"></A>
<div class="top">[<a href="#">top</a>]</div><hr />
<H2>FILES</H2>
<UL> <LI>model_nml in input.nml
     <LI>cam_phis.nc (CAM surface height file)
     <LI>caminput.nc (CAM initial file)
     <LI>clminput.nc (CLM initial file)
     <LI>netCDF output state diagnostics files
</UL>

<!--==================================================================-->
<!-- Cite references, if need be.                                     -->
<!--==================================================================-->

<A NAME="References"></A>
<div class="top">[<a href="#">top</a>]</div><hr />
<H2>REFERENCES</H2>
<UL> 
<LI><A HREF="http://www.ccsm.ucar.edu/models/atm-cam/"> CAM homepage </A>
</UL>

<!--==================================================================-->
<!-- Describe all the error conditions and codes.                     -->
<!-- Putting a <BR> after the synopsis creates a nice effect.         -->
<!--==================================================================-->

<A NAME="Errors"></A>
<div class="top">[<a href="#">top</a>]</div><hr />
<H2>ERROR CODES and CONDITIONS</H2>
<div class="errors">

<TABLE border=1 cellspacing=1 cellpadding=10 width=100%>
<TR><TH>Routine</TH><TH>Message</TH><TH>Comment</TH></TR>
<TR><!-- routine --><TD VALIGN=top>read_cam_init_size <BR>
                                   read_cam_init <BR>
                                   write_cam_init <BR>
                                   nc_read_model_atts <BR>
                                   nc_write_model_atts <BR>
                                   nc_write_model_vars <BR>
                                   read_cam_horiz <BR>
                                   read_cam_coord <BR>
                    </TD>
    <!-- message --><TD VALIGN=top>Various NetCDF-f90 interface error messages</TD>
    <!-- comment --><TD VALIGN=top>From one of the NetCDF calls in the named routine</TD>
</TR>
<TR><!-- routine --><TD VALIGN=top>prog_var_to_vector<BR>
                                   vector_to_prog_var <BR>
                                   get_state_meta_data <BR>
                                   get_val <BR>
                                   model_get_close_states </TD>
    <!-- message --><TD VALIGN=top>scalar and 1-D vector components of state vector are not coded 
                       into this routine</TD>
    <!-- comment --><TD VALIGN=top>Only 2D and 3D fields can be part of state vector so far.</TD>
</TR>
<TR><!-- routine --><TD VALIGN=top>prog_var_to_vector <BR>
                                   vector_to_prog_var</TD>
    <!-- message --><TD VALIGN=top>indx # and model_size # must be equal</TD>
    <!-- comment --><TD VALIGN=top>indx was tallied during insertion of fields into state vector</TD>
</TR>
<TR><!-- routine --><TD VALIGN=top>model_get_close_states</TD>
    <!-- message --><TD VALIGN=top>which_vert = # not handled in model_get_close_states</TD>
    <!-- comment --><TD VALIGN=top>See which_vert description in location/threed_sphere/location_mod.html
                    </TD>
</TR>
<TR><!-- routine --><TD VALIGN=top>nc_write_model_atts</TD>
    <!-- message --><TD VALIGN=top>Time dimension ID # must match Unlimited Dimension ID #</TD>
    <!-- comment --><TD VALIGN=top>NetCDF file writing error</TD>
</TR>
<TR><!-- routine --><TD VALIGN=top>order_state_fields</TD>
    <!-- message --><TD VALIGN=top>nfld = #, nflds = # must be equal</TD>
    <!-- comment --><TD VALIGN=top>Mismatch(es) of state_names_#d and state_num_#d in model_nml</TD>
</TR>

</TABLE>
<br>
</div>

<!--==================================================================-->
<!-- Describe the bugs.                                               -->
<!--==================================================================-->

<A NAME="KnownBugs"></A>
<div class="top">[<a href="#">top</a>]</div><hr />
<H2>KNOWN BUGS</H2>
<P>
See description of dealing with highly damped top layers in CAM
in model_interpolate and model_get_close_states.
</P>
<P>
GPS observations require that highest_obs_pressure_mb be <= 100 mb (hPa).
</P>

<!--==================================================================-->
<!-- Describe Future Plans.                                           -->
<!--==================================================================-->

<A NAME="FuturePlans"></A>
<div class="top">[<a href="#">top</a>]</div><hr />
<H2>FUTURE PLANS</H2>
<UL>
<LI> Implement a strategy for assimilating surface observations. </LI>
<LI> Accomodate future CAMs which may have non-rectangular grids, e.g. HOMME. 
(Development currently underway.) </LI>
</UL>

<!--==================================================================-->
<!-- Legalese & Metadata                                              -->
<!--==================================================================-->

<A NAME="Legalese"></A>
<div class="top">[<a href="#">top</a>]</div><hr />
<H2>Terms of Use</H2>

<P>
DART software - Copyright 2004 - 2013 UCAR.<br>
This open source software is provided by UCAR, "as is",<br>
without charge, subject to all terms of use at<br>
<a href="http://www.image.ucar.edu/DAReS/DART/DART_download">
http://www.image.ucar.edu/DAReS/DART/DART_download</a>
</P>

<TABLE border=0 cellpadding=0 width=100% summary="">
<TR><TD valign=top>Contact:       </TD><TD> Kevin Raeder </TD></TR>
<TR><TD valign=top>Revision:      </TD><TD> $Revision$ </TD></TR>
<TR><TD valign=top>Source:        </TD><TD> $URL$ </TD></TR>
<TR><TD valign=top>Change Date:   </TD><TD> $Date$ </TD></TR>
<TR><TD valign=top>Change&nbsp;history:&nbsp;</TD><TD> try "svn&nbsp;log" or "svn&nbsp;diff" </TD></TR>
</TABLE>
<br>

<!--==================================================================-->

</BODY>
</HTML>
