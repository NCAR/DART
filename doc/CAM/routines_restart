# DART software - Copyright © 2004 - 2010 UCAR. This open source software is
# provided by UCAR, "as is", without charge, subject to all terms of use at
# http://www.image.ucar.edu/DAReS/DART/DART_download
#
# DART $Id$

Jeff, I've included the following files here:

/home/raeder/DAI/cam2.0.1/models/atm/cam/src/:
control/restart.F90 
   dynamics/eul/restart_dynamics.F90
      dynamics/eul/prognostics.F90  
   physics/cam1/restart_physics.F90 
      physics/cam1/comsrf.F90  

there are other modules, that are used by these modules, 
which I used in compiling the table, but they only provided bits
of information.  Let me know if you want me to list more of
those modules for you.

!======================================================================

#include <misc.h>
#include <params.h>

module restart
!----------------------------------------------------------------------- 
! 
! module to handle reading and writing of the master restart files.
!
!----------------------------------------------------------------------- 
! $Id$
!----------------------------------------------------------------------- 
   use shr_kind_mod, only: r8 => shr_kind_r8
   use pmgrid,       only: masterproc, plev, plevp, plond, plat
   use rgrid,        only: nlon, wnummax
   use ioFileMod,    only: putfil, getfil, opnfil
   use filenames,    only: get_archivedir

#ifdef SPMD
   use mpishorthand, only: mpicom, mpir8, mpiint, mpilog
#endif

   implicit none
!
! Public interfaces
!
   public write_restart          ! Write the master restart file out
   public read_restart           ! Read the master restart file in
   public set_restart_filepath   ! Set the full filepath to the master restart file
!
! Everything else is private
!
   private

   integer, parameter :: nlen = 256 ! Length of character strings
   character(len=nlen) :: pname     ! Full restart pathname
!
! Filename specifiers for master restart filename
! (%c = caseid, $y = year, $m = month, $d = day, $s = seconds in day, %t = number)
!
   character(len=256) :: rfilename_spec = '%c.cam2.r.%y-%m-%d-%s'
!
! Common blocks
!
!-----------------------------------------------------------------------
#include <comctl.h>
!-----------------------------------------------------------------------
#include <comlun.h>
!-----------------------------------------------------------------------
#include <comhyb.h>
!-----------------------------------------------------------------------
#include <comtfc.h>
!-----------------------------------------------------------------------

CONTAINS

   subroutine write_restart
!----------------------------------------------------------------------- 
! 
! Purpose: 
! Write the primary, secondary, and history buffer regeneration files.
! 
! Method: 
! The cpp SPMD definition provides for the funnelling of all program i/o
! through the master processor. Processor 0 either reads restart/history
! data from the disk and distributes it to all processors, or collects
! data from all processors and writes it to disk.
! 
! Author: 
! 
!----------------------------------------------------------------------- 
      use history,          only: write_restart_history
      use restart_physics,  only: write_restart_physics
      use restart_dynamics, only: write_restart_dynamics
      use time_manager,     only: timemgr_write_restart
      use filenames,        only: caseid, mss_wpass, mss_irt, get_archivedir, &
                                  interpret_filename_spec
!
! Local workspace
!
      integer ioerr             ! write error status
      character(len=256) fname  ! Restart filename
!-----------------------------------------------------------------------
! Write the primary restart datasets
!-----------------------------------------------------------------------
!
#ifdef DEBUG
      write(6,*)'Entered WRITE_RESTART: writing nstep+1=',nstep+1, ' data to restart file'
#endif
!
! Everything inside the following "if" is from the obsolete RGNFLS
!
      if (masterproc) then
!     
! Open master restart file.
!
         fname = interpret_filename_spec( rfilename_spec )
         call opnfil (fname, nrg, 'u')
!
!-----------------------------------------------------------------------
! Write the master restart dataset
!-----------------------------------------------------------------------

         call timemgr_write_restart(nrg)

         write (nrg, iostat=ioerr) eps, caseid, hyai, hybi, hyam,  &
                                   hybm, aeres
         if (ioerr /= 0 ) then
            write (6,*) 'WRITE ioerror ',ioerr,' on i/o unit = ',nrg
            call endrun
         end if
!
! Reduced grid stuff
!
         write (nrg, iostat=ioerr) nlon, wnummax
         if (ioerr /= 0 ) then
            write (6,*) 'WRITE ioerror ',ioerr,' on i/o unit = ',nrg
            call endrun
         end if

      end if
!
!-----------------------------------------------------------------------
! Dynamics, physics, History
!-----------------------------------------------------------------------
!
      call write_restart_dynamics (nrg)
      call write_restart_physics (nrg, nrg2)
      call write_restart_history (nrg, luhrest)

      if (masterproc) then
         close(nrg)
         pname = trim(get_archivedir( 'rest' )) // fname
         call putfil (fname, pname, mss_wpass, mss_irt, (.not. nlend) )
         call write_rest_pfile
      end if

      return
   end subroutine write_restart

!#######################################################################

   subroutine read_restart
!----------------------------------------------------------------------- 
! 
! Purpose: 
! Acquire and position the restart, master, primary and secondary
! datasets for a continuation run
! 
! Method: 
! 
! Author: 
! 
!-----------------------------------------------------------------------
      use phys_grid,        only: phys_grid_init
      use history,          only: read_restart_history
      use filenames,        only: caseid
      use restart_physics,  only: read_restart_physics
      use restart_dynamics, only: read_restart_dynamics
      use time_manager,     only: timemgr_read_restart, timemgr_restart
!-----------------------------------------------------------------------
!
! Local workspace
!
      integer i                     ! Indices
      integer ioerr                 ! read error status
      integer decomp                ! decomposition type

      character*256 locfn           ! Local filename
      character*33  tcase           ! Read in previous case name
!
!-----------------------------------------------------------------------
! Determine full restart pathname
!------------------------------------------------------------------------
!
! Test for existence of a restart pointer dataset (nsrest=1 only).
! If restart pinter dataset exists, obtain it and read it.
!
      if (masterproc) then
         if (.not.nlhst) then
            call read_rest_pfile
         endif
!
!------------------------------------------------------------------------
! Obtain and read the master restart dataset 
!------------------------------------------------------------------------
!
#ifdef DEBUG
         write(6,*)'READ_RESTART: Reading master resart dataset'
#endif

!
! Obtain master restart dataset
!
         call getfil (pname, locfn)
         call opnfil (locfn, nrg, 'u')
!     
! Read comtim, comtfc, comhst, comhed and history buffer variables 
!     
         call timemgr_read_restart(nrg)

         read (nrg, iostat=ioerr) eps, tcase, hyai, hybi, hyam,  &
                                  hybm, aeres
         if (ioerr /= 0 ) then
            write (6,*) 'READ ioerror ',ioerr,' on i/o unit = ',nrg
            call endrun
         end if

         if (lbrnch .and. tcase == caseid) then
            write(6,*) 'READ_RESTART: Must change case name on branch run'
            write(6,*) 'Prev case = ',tcase,' current case = ',caseid
            call endrun
         end if
!
! Reduced grid stuff
!
         read (nrg, iostat=ioerr) nlon, wnummax
         if (ioerr /= 0 ) then
            write (6,*) 'READ ioerror ',ioerr,' on i/o unit = ',nrg
            call endrun
         end if

         write(6,*) 'MASTER RESTART DATASET READ. EPS= ',eps
         write(6,*) 'Files for restart:'

      endif  ! end of if-masterproc

#if ( defined SPMD ) 
      call mpibcast (eps    ,1        ,mpir8  ,0,mpicom)
      call mpibcast (hyai   ,plev+1   ,mpir8  ,0,mpicom) 
      call mpibcast (hybi   ,plev+1   ,mpir8  ,0,mpicom) 
      call mpibcast (hyam   ,plev     ,mpir8  ,0,mpicom)   
      call mpibcast (hybm   ,plev     ,mpir8  ,0,mpicom)   
      call mpibcast (aeres  ,1        ,mpilog ,0,mpicom)
      call mpibcast (nlon,   plat,     mpiint, 0,mpicom)
      call mpibcast (wnummax,plat,     mpiint, 0,mpicom)
#endif

! Restart the time manager.

      call timemgr_restart()

!-----------------------------------------------------------------------
! Dynamics, physics, history
!-----------------------------------------------------------------------

      call read_restart_dynamics (nrg)
      call initcom ()
      call phys_grid_init
      call read_restart_physics (nrg, nrg2, aeres )
      if (nsrest == 1) then
         call read_restart_history (nrg, luhrest)
      end if
      if (masterproc) close(nrg)      ! Done reading restart info

      return
   end subroutine read_restart

   subroutine write_rest_pfile
!----------------------------------------------------------------------- 
! 
! Purpose: 
!
! Write out the restart pointer file
!
!----------------------------------------------------------------------- 
   use filenames,       only: rest_pfile
   use restart_physics, only: get_abs_restart_filepath
   use history,         only: get_mtapes, get_hist_restart_filepath, &
                              hstwr, get_hfilepath, nfils, mfilt
!-----------------------------------------------------------------------
! for nsds
#include <comlun.h>
!-----------------------------------------------------------------------
! for aeres
#include <comctl.h>
!-----------------------------------------------------------------------
   integer t      ! Tape number
   integer mtapes ! Number of tapes that are active

   call opnfil(rest_pfile, nsds, 'f')
   rewind nsds
   write (nsds,'(a)') trim(pname)
   write (nsds,'(//a,a)') '# The following lists the other files needed for restarts', &
                        ' (cam only reads the first line of this file).'
   write (nsds,'(a,a)') '# The files below refer to the files needed for the master restart file:', &
                       trim(pname)
   if ( aeres )then
      write (nsds,'(a,a)') '# ', trim(get_abs_restart_filepath())
   end if
!
! History files: Need restart history files when not a time-step to write history info
! Need: history files if they are not full
!
   mtapes = get_mtapes( )
   do t=1,mtapes
      if ( .not. hstwr(t) ) then
         write (nsds,'(a,a)') '# ', trim(get_hist_restart_filepath( t ))
      end if
      if ( nfils(t) > 0 .and. nfils(t) < mfilt(t) ) then
         write (nsds,'(a,a)') '# ', trim(get_hfilepath( t ))
      end if
   end do
   close (nsds)
   write(6,*)'(WRITE_REST_PFILE): successfully wrote local restart pointer file ',trim(rest_pfile)
   write(6,'("---------------------------------------")')
   end subroutine write_rest_pfile

   subroutine read_rest_pfile
!----------------------------------------------------------------------- 
! 
! Purpose: 
!
! Read the master restart file from the restart pointer file
!
!----------------------------------------------------------------------- 
   use filenames, only: rest_pfile
!-----------------------------------------------------------------------
! for nsds
#include <comlun.h>
   character(len=256) :: locfn    ! Local pathname for restart pointer file

   call opnfil (rest_pfile, nsds, 'f', status="old")
   read (nsds,'(a)') pname
   close(nsds)

   end subroutine read_rest_pfile

!-----------------------------------------------------------------------
! BOP
!
! !ROUTINE: set_restart_filepath
!
! !DESCRIPTION: Set the filepath of the specific type of restart file.
!
!-----------------------------------------------------------------------
! !INTERFACE:
subroutine set_restart_filepath( rgpath )
!
! !PARAMETERS:
!
  character(len=*), intent(in)  :: rgpath ! Full pathname to restart file
!
! EOP
!
  if ( trim(rgpath) == '' )then
     write(6,*) 'SET_RESTART_FILEPATH: rgpath sent into subroutine is empty'
     call endrun
  end if
  if ( rgpath(1:1) /= '/' )then
     write(6,*) 'SET_RESTART_FILEPATH: rgpath sent into subroutine is not an absolute pathname'
     call endrun
  end if
  if ( len_trim(rgpath) > nlen )then
     write(6,*) 'SET_RESTART_FILEPATH: rgpath is too long :', rgpath
     call endrun
  end if
  pname = trim(rgpath)
end subroutine set_restart_filepath

end module restart

!======================================================================

#include <misc.h>
#include <params.h>

module restart_dynamics

   use shr_kind_mod, only: r8 => shr_kind_r8
   use pmgrid
   use prognostics
! kdr find prognostics in cam2.0.1/models/atm/cam/src/dynamics/eul/prognostics.F90
! = the prognostic variables, some of them labelled
   use ppgrid, only: pcols, pver
   use comslt
   use binary_io

   implicit none

CONTAINS

   subroutine write_restart_dynamics (nrg)

#include <comqfl.h>

!
! Input arguments
!
      integer :: nrg     ! Unit number
!
! Local workspace
!
      integer :: begj    ! starting latitude
      integer :: ioerr   ! error status
!
      call wrtout_r8 (nrg,vort(1,1,beglat,n3m1), plndlv)
      call wrtout_r8 (nrg,vort(1,1,beglat,n3m2), plndlv)

      call wrtout_r8 (nrg,div(1,1,beglat,n3m1) , plndlv)
      call wrtout_r8 (nrg,div(1,1,beglat,n3m2) , plndlv)

      call wrtout_r8 (nrg,dpsl  ,plond )
      call wrtout_r8 (nrg,dpsm  ,plond )
      call wrtout_r8 (nrg,dps   ,plond )
      call wrtout_r8 (nrg,phis  ,plond )
      call wrtout_r8 (nrg,omga  ,plndlv)
!
! Write fields u3,v3,t3,q3,ps at time indices n3 and n3m1
!
      begj = beglatex + numbnd

      call wrtout_r8 (nrg,u3(1,1,begj,n3m1)  ,plndlv)
      call wrtout_r8 (nrg,v3(1,1,begj,n3m1)  ,plndlv)
      call wrtout_r8 (nrg,t3(1,1,begj,n3m1)  ,plndlv)
      call wrtout_r8 (nrg,ps(1,beglat,n3m1)  ,plond)

      call wrtout_r8 (nrg,u3(1,1,begj,n3m2)  ,plndlv)
      call wrtout_r8 (nrg,v3(1,1,begj,n3m2)  ,plndlv)
      call wrtout_r8 (nrg,t3(1,1,begj,n3m2)  ,plndlv)
      call wrtout_r8 (nrg,ps(1,beglat,n3m2)  ,plond)
      
      call wrtout_r8 (nrg,q3(1,1,1,begj,n3m1),plndlv*(pcnst+pnats))
      call wrtout_r8 (nrg,q3(1,1,1,begj,n3m2),plndlv*(pcnst+pnats))
!
! Write slt arrays (trajectory mid-point coordinates and 
! slt forcast of moisture and constituents
!
      call wrtout_r8 (nrg,lammp,plnlv)
      call wrtout_r8 (nrg,phimp,plnlv)
      call wrtout_r8 (nrg,sigmp,plnlv)
      call wrtout_r8 (nrg,qfcst,plndlv*pcnst)
!
! Write global integrals
!
      if (masterproc) then
         write(nrg, iostat=ioerr) tmass0, fixmas, hw1,    hw2,  &
                                  hw3, alpha
         if (ioerr /= 0 ) then
            write (6,*) 'WRITE ioerror ',ioerr,' on i/o unit = ',nrg
            call endrun
         end if
      end if

      return
   end subroutine write_restart_dynamics

!#######################################################################

   subroutine read_restart_dynamics (nrg)

#if ( defined SPMD )
      use mpishorthand
#endif

#include <comqfl.h>
!
! Input arguments
!
      integer :: nrg     ! Unit number
!
! Local workspace
!
      integer :: begj    ! starting latitude
      integer :: ioerr   ! error status
!
      call initialize_prognostics
      call readin_r8 (nrg,vort(1,1,beglat,n3m1), plndlv)
      call readin_r8 (nrg,vort(1,1,beglat,n3m2), plndlv)

      call readin_r8 (nrg,div(1,1,beglat,n3m1) , plndlv)
      call readin_r8 (nrg,div(1,1,beglat,n3m2) , plndlv)

      call readin_r8 (nrg,dpsl  ,plond )
      call readin_r8 (nrg,dpsm  ,plond )
      call readin_r8 (nrg,dps   ,plond )
      call readin_r8 (nrg,phis  ,plond )
      call readin_r8 (nrg,omga  ,plndlv)
!
! Write fields u3,v3,t3,q3,ps at time indices n3 and n3m1
!
      begj = beglatex + numbnd

      call readin_r8 (nrg,u3(1,1,begj,n3m1)  ,plndlv)
      call readin_r8 (nrg,v3(1,1,begj,n3m1)  ,plndlv)
      call readin_r8 (nrg,t3(1,1,begj,n3m1)  ,plndlv)
      call readin_r8 (nrg,ps(1,beglat,n3m1)  ,plond)

      call readin_r8 (nrg,u3(1,1,begj,n3m2)  ,plndlv)
      call readin_r8 (nrg,v3(1,1,begj,n3m2)  ,plndlv)
      call readin_r8 (nrg,t3(1,1,begj,n3m2)  ,plndlv)
      call readin_r8 (nrg,ps(1,beglat,n3m2)  ,plond)
      
      call readin_r8 (nrg,q3(1,1,1,begj,n3m1),plndlv*(pcnst+pnats))
      call readin_r8 (nrg,q3(1,1,1,begj,n3m2),plndlv*(pcnst+pnats))
!
! Write slt arrays (trajectory mid-point coordinates and 
! slt forcast of moisture and constituents
!
      call initialize_comslt
      call readin_r8 (nrg,lammp,plnlv)
      call readin_r8 (nrg,phimp,plnlv)
      call readin_r8 (nrg,sigmp,plnlv)
      call readin_r8 (nrg,qfcst,plndlv*pcnst)
!
! Read global integrals
!
      if (masterproc) then
         read (nrg, iostat=ioerr) tmass0, fixmas, hw1,    hw2,  &
                                  hw3, alpha
         if (ioerr /= 0 ) then
            write (6,*) 'WRITE ioerror ',ioerr,' on i/o unit = ',nrg
            call endrun
         end if
      end if

#if ( defined SPMD )
   call mpibcast (tmass0,1         ,mpir8  ,0,mpicom)      
   call mpibcast (fixmas,1         ,mpir8  ,0,mpicom)
   call mpibcast (hw1   ,pcnst     ,mpir8  ,0,mpicom)
   call mpibcast (hw2   ,pcnst     ,mpir8  ,0,mpicom)
   call mpibcast (hw3   ,pcnst     ,mpir8  ,0,mpicom)   
   call mpibcast (alpha ,pcnst     ,mpir8  ,0,mpicom)
#endif

      return

   end subroutine read_restart_dynamics

end module restart_dynamics

!======================================================================

#include <misc.h>
#include <params.h>

module prognostics

!----------------------------------------------------------------------- 
! 
! Purpose: 
! Prognostic variables held in-core for convenient access.
! q3 is specific humidity (water vapor) and other constituents.
! pcnst is advected constituents, pnats is non-advected.
! 
! Author: G. Grant
! 
!-----------------------------------------------------------------------

   use shr_kind_mod, only: r8 => shr_kind_r8
   use pmgrid 
   use infnan
   use constituents, only: pcnst, pnats

   implicit none

   integer, parameter :: ptimelevels = 3  ! number of time levels in the dycore
   integer :: n3   = 3
   integer :: n3m1 = 2
   integer :: n3m2 = 1

   real(r8), allocatable :: ps(:,:,:)
   real(r8), allocatable :: u3(:,:,:,:)
   real(r8), allocatable :: v3(:,:,:,:)
   real(r8), allocatable :: t3(:,:,:,:)
   real(r8), allocatable :: q3(:,:,:,:,:)
   real(r8), allocatable :: qminus(:,:,:,:)

   real(r8), allocatable :: vort(:,:,:,:)   ! vorticity
   real(r8), allocatable :: div(:,:,:,:)    ! divergence

   real(r8), allocatable :: dpsl(:,:)       ! longitudinal pressure gradient
   real(r8), allocatable :: dpsm(:,:)       ! meridional pressure gradient
   real(r8), allocatable :: dps(:,:)        ! pressure gradient
   real(r8), allocatable :: phis(:,:)       ! surface geopotential
   real(r8), allocatable :: omga(:,:,:)     ! vertical velocity

CONTAINS

   subroutine initialize_prognostics
!
! Purpose:  Allocate and initialize the prognostic arrays.
!
      allocate (ps    (plond                 ,beglat:endlat    ,ptimelevels))
      allocate (u3    (plond,plev            ,beglatex:endlatex,ptimelevels))
      allocate (v3    (plond,plev            ,beglatex:endlatex,ptimelevels))
      allocate (t3    (plond,plev            ,beglatex:endlatex,ptimelevels))
      allocate (q3    (plond,plev,pcnst+pnats,beglatex:endlatex,ptimelevels))
      allocate (qminus(plond,plev,pcnst      ,beglatex:endlatex  ))

      allocate (vort  (plond,plev,beglat:endlat,ptimelevels))   
      allocate (div   (plond,plev,beglat:endlat,ptimelevels))    

      allocate (dpsl  (plond,beglat:endlat))        
      allocate (dpsm  (plond,beglat:endlat))        
      allocate (dps   (plond,beglat:endlat))         
      allocate (phis  (plond,beglat:endlat))        
      allocate (omga  (plond,plev,beglat:endlat))    

      ps(:,:,:)       = inf
      u3(:,:,:,:)     = inf
      v3(:,:,:,:)     = inf
      t3(:,:,:,:)     = inf
      q3(:,:,:,:,:)   = inf
      qminus(:,:,:,:) = inf

      vort(:,:,:,:)   = inf
      div (:,:,:,:)   = inf

      dpsl  (:,:) = inf
      dpsm  (:,:) = inf
      dps   (:,:) = inf
      phis  (:,:) = inf
      omga  (:,:,:) = inf

      return
   end subroutine initialize_prognostics

   subroutine shift_time_indices
!
! Purpose: 
! Shift the indices that keep track of which index stores
! the relative times (current time, previous, time before previous etc).
!
      integer :: itmp

      itmp = n3m2

      n3m2 = n3m1
      n3m1 = n3
      n3   = itmp
   end subroutine shift_time_indices

end module prognostics

!======================================================================

#include <misc.h>
#include <params.h>

module restart_physics

   use shr_kind_mod, only: r8 => shr_kind_r8
   use ppgrid
   use phys_grid,   only: read_chunk_from_field, write_field_from_chunk, get_ncols_p
   use pmgrid,      only: masterproc
   use prognostics, only: ptimelevels, n3
   use buffer
   use radae,       only: abstot_3d, absnxt_3d, emstot_3d, initialize_radbuffer
   use comsrf
   use ioFileMod
#if ( defined COUP_CSM )
   use ccsm_msg, only: initialize_ccsm_msg, write_restart_ccsm, read_restart_ccsm
#endif

   implicit none

   private
!
! Public interfaces
!
   public write_restart_physics  ! Write the physics restart info out
   public read_restart_physics   ! Read the physics restart info in
   public get_abs_restart_filepath ! Get the name of the restart filepath

!
! Private data
!
   character(len=256) :: pname  ! Full abs-ems restart filepath
!
! Filename specifier for restart abs-ems file
! (%c = caseid, $y = year, $m = month, $d = day, $s = seconds in day, %t = tape number)
!
   character(len=256) :: rafilename_spec = '%c.cam2.ra.%y-%m-%d-%s'   ! abs-ems restart


CONTAINS

   subroutine write_restart_physics (nrg, nrg2)
   use filenames, only: mss_irt, mss_wpass, get_archivedir, interpret_filename_spec
! for nlend and aeres
#include <comctl.h>
!
! Input arguments
!
      integer :: nrg
      integer :: nrg2
!
! Local workspace
!
      real(r8) tmpfield(pcols,begchunk:endchunk)
      real(r8) tmpfield3d(pcols,plevmx,begchunk:endchunk)
      integer i                 ! loop index
      integer n3tmp             ! timestep index
      character(len=256) fname  ! abs-ems restart filename
      integer ioerr             ! I/O status
      integer  :: ncol          ! number of vertical columns
!
! Buffer module variables
!
      call write_field_from_chunk(nrg,1,1,1,pblht)
      call write_field_from_chunk(nrg,1,1,1,tpert)
      call write_field_from_chunk(nrg,1,pver,1,qrs)
      call write_field_from_chunk(nrg,1,pver,1,qrl)
      call write_field_from_chunk(nrg,1,pcnst+pnats,1,qpert)
!
! cld, qcwat, and tcwat are physics things, but have dynamics time levels
!
      n3tmp = n3
      do i=1,ptimelevels
         call write_field_from_chunk(nrg,1,pver,1,cld(1,1,begchunk,n3tmp))
         n3tmp = mod(n3tmp,ptimelevels) + 1
      enddo

      n3tmp = n3
      do i=1,ptimelevels
         call write_field_from_chunk(nrg,1,pver,1,qcwat(1,1,begchunk,n3tmp))
         n3tmp = mod(n3tmp,ptimelevels) + 1
      enddo
 
      n3tmp = n3
      do i=1,ptimelevels
         call write_field_from_chunk (nrg,1,pver,1,tcwat(1,1,begchunk,n3tmp))
         call write_field_from_chunk (nrg,1,pver,1,lcwat(1,1,begchunk,n3tmp))
         n3tmp = mod(n3tmp,ptimelevels) + 1
      enddo
!
! Comsrf module variables
!
#if (! defined COUP_CSM)
      call write_field_from_chunk(nrg,1,1,1,fsnt)
#endif
      call write_field_from_chunk(nrg,1,1,1,fsns)
#if (! defined COUP_CSM)
      call write_field_from_chunk(nrg,1,1,1,flnt)
      call write_field_from_chunk(nrg,1,1,1,flns)
#endif
      do i=begchunk,endchunk
	tmpfield(:,i) = srfflx_state2d(i)%asdir(:)
      end do
      call write_field_from_chunk(nrg,1,1,1,tmpfield)
      do i=begchunk,endchunk
	tmpfield(:,i) = srfflx_state2d(i)%asdif(:)
      end do
      call write_field_from_chunk(nrg,1,1,1,tmpfield)
      do i=begchunk,endchunk
	tmpfield(:,i) = srfflx_state2d(i)%aldir(:)
      end do
      call write_field_from_chunk(nrg,1,1,1,tmpfield)
      do i=begchunk,endchunk
	tmpfield(:,i) = srfflx_state2d(i)%aldif(:)
      end do
      call write_field_from_chunk(nrg,1,1,1,tmpfield)

#if (! defined COUP_CSM)
      call write_field_from_chunk(nrg,1,1,1,asdirice)
      call write_field_from_chunk(nrg,1,1,1,asdifice)
      call write_field_from_chunk(nrg,1,1,1,aldirice)
      call write_field_from_chunk(nrg,1,1,1,aldifice)
      call write_field_from_chunk(nrg,1,1,1,tsice)
#endif

      do i=begchunk,endchunk
	tmpfield(:,i) = srfflx_state2d(i)%lwup(:)
      end do
      call write_field_from_chunk(nrg,1,1,1,tmpfield)
      call write_field_from_chunk(nrg,1,1,1,landfrac)
      call write_field_from_chunk(nrg,1,1,1,landm)
      call write_field_from_chunk(nrg,1,1,1,sgh)
      do i=begchunk,endchunk
	tmpfield(:,i) = srfflx_state2d(i)%ts(:)
      end do
      call write_field_from_chunk(nrg,1,1,1,tmpfield)
      do i=begchunk,endchunk
	tmpfield3d(:,:,i) = surface_state2d(i)%tssub(:,:)
      end do
      call write_field_from_chunk(nrg,1,plevmx,1,tmpfield3d)
      call write_field_from_chunk(nrg,1,1,1,sicthk)
      call write_field_from_chunk(nrg,1,1,1,snowhland)
#if (! defined COUP_CSM)
      call write_field_from_chunk(nrg,1,1,1,snowhice)
#else
      snowhice = 0.
#endif
      do i=begchunk,endchunk
       ncol = get_ncols_p(i)
	tmpfield(:ncol,i) = surface_state2d(i)%flwds(:ncol)
      end do
      call write_field_from_chunk(nrg,1,1,1,tmpfield)
      do i=begchunk,endchunk
       ncol = get_ncols_p(i)
	tmpfield(:ncol,i) = surface_state2d(i)%sols(:ncol)
      end do
      call write_field_from_chunk(nrg,1,1,1,tmpfield)
      do i=begchunk,endchunk
       ncol = get_ncols_p(i)
	tmpfield(:ncol,i) = surface_state2d(i)%soll(:ncol)
      end do
      call write_field_from_chunk(nrg,1,1,1,tmpfield)
      do i=begchunk,endchunk
       ncol = get_ncols_p(i)
	tmpfield(:ncol,i) = surface_state2d(i)%solsd(:ncol)
      end do
      call write_field_from_chunk(nrg,1,1,1,tmpfield)
      do i=begchunk,endchunk
       ncol = get_ncols_p(i)
	tmpfield(:ncol,i) = surface_state2d(i)%solld(:ncol)
      end do
      call write_field_from_chunk(nrg,1,1,1,tmpfield)
      call write_field_from_chunk(nrg,1,1,1,trefmxav)
      call write_field_from_chunk(nrg,1,1,1,trefmnav)
      call write_field_from_chunk(nrg,1,1,1,icefrac)

#if ( defined COUP_CSM )
      call write_restart_ccsm ()
#endif
!
!-----------------------------------------------------------------------
! Write the abs/ems restart dataset if necessary    
!-----------------------------------------------------------------------
!
      if (aeres) then
         if (masterproc) then
            fname = interpret_filename_spec( rafilename_spec )
            pname = trim(get_archivedir('rest'))//fname
            call opnfil(fname, nrg2, 'u')
            write(nrg,iostat=ioerr) pname
            if (ioerr /= 0 ) then
               write (6,*) 'WRITE ioerror ',ioerr,' on i/o unit = ',nrg
               call endrun
            end if
         endif

         call write_field_from_chunk(nrg2, 1, pverp*pverp,1, abstot_3d(1,1,1,begchunk))
         call write_field_from_chunk(nrg2, 1, pver*4,     1, absnxt_3d(1,1,1,begchunk))
         call write_field_from_chunk(nrg2, 1, pverp,      1, emstot_3d(1,1,begchunk))

         if (masterproc) then
            close(nrg2)
            call putfil (fname, pname, mss_wpass, mss_irt, (.not. nlend) )
         end if
      end if
      
      return
   end subroutine write_restart_physics

!#######################################################################

   subroutine read_restart_physics (nrg, nrg2, aeres )
!
! Arguments
!
      integer, intent(in) :: nrg
      integer, intent(in) :: nrg2

      logical, intent(in) :: aeres
!
! Local workspace
!
      real(r8) tmpfield(pcols,begchunk:endchunk)
      real(r8) tmpfield3d(pcols,plevmx,begchunk:endchunk)
      integer i                 ! loop index
      integer n3tmp             ! timestep index
      character*80  locfn       ! Local filename
      integer ioerr             ! I/O status
!
! Buffer module variables
!
      call initialize_buffer ()

      call read_chunk_from_field(nrg,1,1,1,pblht)
      call read_chunk_from_field(nrg,1,1,1,tpert)
      call read_chunk_from_field(nrg,1,pver,1,qrs)
      call read_chunk_from_field(nrg,1,pver,1,qrl)
      call read_chunk_from_field(nrg,1,pcnst+pnats,1,qpert)
!
! cld, qcwat, and tcwat are physics things, but have dynamics time levels
!
      n3tmp = n3
      do i=1,ptimelevels
         call read_chunk_from_field(nrg,1,pver,1,cld(1,1,begchunk,n3tmp))
         n3tmp = mod(n3tmp,ptimelevels) + 1
      enddo

      n3tmp = n3
      do i=1,ptimelevels
         call read_chunk_from_field(nrg,1,pver,1,qcwat(1,1,begchunk,n3tmp))
         n3tmp = mod(n3tmp,ptimelevels) + 1
      enddo

      n3tmp = n3
      do i=1,ptimelevels
         call read_chunk_from_field(nrg,1,pver,1,tcwat(1,1,begchunk,n3tmp))
         call read_chunk_from_field(nrg,1,pver,1,lcwat(1,1,begchunk,n3tmp))
         n3tmp = mod(n3tmp,ptimelevels) + 1
      enddo
!
! Comsrf module variables
!
      call initialize_comsrf
#if (! defined COUP_CSM)
      call read_chunk_from_field(nrg,1,1,1,fsnt)
#endif
      call read_chunk_from_field(nrg,1,1,1,fsns)
#if (! defined COUP_CSM)
      call read_chunk_from_field(nrg,1,1,1,flnt)
      call read_chunk_from_field(nrg,1,1,1,flns)
#endif
      call read_chunk_from_field(nrg,1,1,1,tmpfield)
      do i=begchunk,endchunk
	srfflx_state2d(i)%asdir(:) = tmpfield(:,i)
      end do
      call read_chunk_from_field(nrg,1,1,1,tmpfield)
      do i=begchunk,endchunk
	srfflx_state2d(i)%asdif(:) = tmpfield(:,i)
      end do
      call read_chunk_from_field(nrg,1,1,1,tmpfield)
      do i=begchunk,endchunk
	srfflx_state2d(i)%aldir(:) = tmpfield(:,i)
      end do
      call read_chunk_from_field(nrg,1,1,1,tmpfield)
      do i=begchunk,endchunk
	srfflx_state2d(i)%aldif(:) = tmpfield(:,i)
      end do

#if (! defined COUP_CSM)
      call read_chunk_from_field(nrg,1,1,1,asdirice)
      call read_chunk_from_field(nrg,1,1,1,asdifice)
      call read_chunk_from_field(nrg,1,1,1,aldirice)
      call read_chunk_from_field(nrg,1,1,1,aldifice)
      call read_chunk_from_field(nrg,1,1,1,tsice)
#endif

      call read_chunk_from_field(nrg,1,1,1,tmpfield)
      do i=begchunk,endchunk
	srfflx_state2d(i)%lwup(:) = tmpfield(:,i)
      end do
      call read_chunk_from_field(nrg,1,1,1,landfrac)
      call read_chunk_from_field(nrg,1,1,1,landm)
      call read_chunk_from_field(nrg,1,1,1,sgh)
      call read_chunk_from_field(nrg,1,1,1,tmpfield)
      do i=begchunk,endchunk
	srfflx_state2d(i)%ts(:) = tmpfield(:,i)
      end do
      call read_chunk_from_field(nrg,1,plevmx,1,tmpfield3d)
      do i=begchunk,endchunk
	surface_state2d(i)%tssub(:,:) = tmpfield3d(:,:,i)
      end do
      call read_chunk_from_field(nrg,1,1,1,sicthk)
#if (! defined COUP_CSM)
      call read_chunk_from_field(nrg,1,1,1,snowhland)
#endif
      call read_chunk_from_field(nrg,1,1,1,snowhice)
      call read_chunk_from_field(nrg,1,1,1,tmpfield)
      do i=begchunk,endchunk
	surface_state2d(i)%flwds(:) = tmpfield(:,i)
      end do
      call read_chunk_from_field(nrg,1,1,1,tmpfield)
      do i=begchunk,endchunk
	surface_state2d(i)%sols(:) = tmpfield(:,i)
      end do
      call read_chunk_from_field(nrg,1,1,1,tmpfield)
      do i=begchunk,endchunk
	surface_state2d(i)%soll(:) = tmpfield(:,i)
      end do
      call read_chunk_from_field(nrg,1,1,1,tmpfield)
      do i=begchunk,endchunk
	surface_state2d(i)%solsd(:) = tmpfield(:,i)
      end do
      call read_chunk_from_field(nrg,1,1,1,tmpfield)
      do i=begchunk,endchunk
	surface_state2d(i)%solld(:) = tmpfield(:,i)
      end do
      call read_chunk_from_field(nrg,1,1,1,trefmxav)
      call read_chunk_from_field(nrg,1,1,1,trefmnav)
      call read_chunk_from_field(nrg,1,1,1,icefrac)

#if ( defined COUP_CSM )
      call initialize_ccsm_msg ()
      call read_restart_ccsm ()
#endif
!
!-----------------------------------------------------------------------
! Read the abs/ems restart dataset if necessary    
!-----------------------------------------------------------------------
!
      call initialize_radbuffer ()
      if (aeres) then
         if (masterproc) then
            read(nrg,iostat=ioerr) pname
            if (ioerr /= 0 ) then
               write (6,*) 'READ ioerror ',ioerr,' on i/o unit = ',nrg
               call endrun
            end if
            call getfil (pname, locfn)
            call opnfil (locfn, nrg2, 'u')
         endif

         call read_chunk_from_field(nrg2, 1, pverp*pverp,1,abstot_3d(1,1,1,begchunk))
         call read_chunk_from_field(nrg2, 1, pver*4,     1,absnxt_3d(1,1,1,begchunk))
         call read_chunk_from_field(nrg2, 1, pverp,      1,emstot_3d(1,1,begchunk))

         if (masterproc) close(nrg2)
      end if
      
      return
   end subroutine read_restart_physics

   character(len=256) function get_abs_restart_filepath ( )
!
! Return the full filepath to the abs-ems restart file
!
     get_abs_restart_filepath = pname
   end function get_abs_restart_filepath

end module restart_physics

!===================================================================

#include <misc.h>
#include <params.h>

!-----------------------------------------------------------------------
!
! !MODULE: comsrf
!
! !DESCRIPTION:	Module to handle surface fluxes for the subcomponents of cam/csm
!
! Public interfaces:
!
!	update       
!	init           
!	zero           
!
!-----------------------------------------------------------------------
module comsrf
!
! USES:
!
  use shr_kind_mod, only: r8 => shr_kind_r8
  use tracers, only: pcnst, pnats
  use ppgrid, only: pcols, begchunk, endchunk, pvermx
  use phys_grid, only: get_ncols_p
  use infnan

  implicit none

!----------------------------------------------------------------------- 
! PUBLIC: Make default data and interfaces private
!----------------------------------------------------------------------- 
!
! ! PUBLIC MEMBER FUNCTIONS:
!
  public initialize_comsrf          ! Set the surface temperature and sea-ice fraction

  public   ! By default all data is public to this module

  public surface_state
  public srfflx_state
  public srfflx_parm

! Public interfaces

  public srfflx_parm_reset
  public srfflx_state_reset
  public update_srf_fractions
  public update_srf_fluxes

  integer, parameter :: plevmx = 4       ! number of subsurface levels

  character*8 tsnam(plevmx)              ! names of sub-surface temperature fields

  real(r8), allocatable:: landm(:,:)     ! land/ocean/sea ice flag
  real(r8), allocatable:: sgh(:,:)       ! land/ocean/sea ice flag
  real(r8), allocatable:: sicthk(:,:)    ! cam sea-ice thickness (m)
  real(r8), allocatable:: snowhice(:,:)  ! snow depth (liquid water) ovr ice
  real(r8), allocatable:: snowhland(:,:) !snow depth (liquid water) ovr lnd
  real(r8), allocatable:: fsns(:,:)      ! surface absorbed solar flux
  real(r8), allocatable:: fsnt(:,:)      ! Net column abs solar flux at model top
  real(r8), allocatable:: flns(:,:)      ! Srf longwave cooling (up-down) flux
  real(r8), allocatable:: flnt(:,:)      ! Net outgoing lw flux at model top
  real(r8), allocatable:: srfrpdel(:,:)  ! 1./(pint(k+1)-pint(k))
  real(r8), allocatable:: psm1(:,:)      ! surface pressure
  real(r8), allocatable:: absorb(:,:)    ! cam surf absorbed solar flux (W/m2)
  real(r8), allocatable:: prcsnw(:,:)    ! cam tot snow precip
  real(r8), allocatable:: landfrac(:,:)  ! fraction of sfc area covered by land
  real(r8), allocatable:: ocnfrac(:,:)   ! frac of sfc area covered by open ocean
  real(r8), allocatable:: icefrac(:,:)   ! fraction of sfc area covered by seaice
  real(r8), allocatable:: previcefrac(:,:) ! fraction of sfc area covered by seaice
  real(r8), allocatable:: trefmxav(:,:)  ! diagnostic: tref max over the day
  real(r8), allocatable:: trefmnav(:,:)  ! diagnostic: tref min over the day

  real(r8), allocatable:: asdirice(:,:)
  real(r8), allocatable:: aldirice(:,:)
  real(r8), allocatable:: asdifice(:,:)
  real(r8), allocatable:: aldifice(:,:)
  real(r8), allocatable:: tsice(:,:)

!---------------------------------------------------------------------------
  type surface_state
     real(r8) :: tbot(pcols)         ! bot level temperature
     real(r8) :: zbot(pcols)         ! bot level height above surface
     real(r8) :: ubot(pcols)         ! bot level u wind
     real(r8) :: vbot(pcols)         ! bot level v wind
     real(r8) :: qbot(pcols)         ! bot level specific humidity
     real(r8) :: pbot(pcols)         ! bot level pressure
     real(r8) :: flwds(pcols)        ! 
     real(r8) :: precsc(pcols)       !
     real(r8) :: precsl(pcols)       !
     real(r8) :: precc(pcols)        ! 
     real(r8) :: precl(pcols)        ! 
     real(r8) :: soll(pcols)         ! 
     real(r8) :: sols(pcols)         ! 
     real(r8) :: solld(pcols)        !
     real(r8) :: solsd(pcols)        !
     real(r8) :: srfrad(pcols)       !
     real(r8) :: thbot(pcols)        ! 
     real(r8) :: tssub(pcols,plevmx) ! cam surface/subsurface temperatures
  end type surface_state

  type srfflx_state
     integer :: lchnk     ! chunk index
     integer :: ncol      ! number of active columns

     real(r8) :: asdir(pcols)            ! albedo: shortwave, direct
     real(r8) :: asdif(pcols)            ! albedo: shortwave, diffuse
     real(r8) :: aldir(pcols)            ! albedo: longwave, direct
     real(r8) :: aldif(pcols)            ! albedo: longwave, diffuse
     real(r8) :: lwup(pcols)             ! longwave up radiative flux
     real(r8) :: lhf(pcols)              ! latent heat flux
     real(r8) :: shf(pcols)              ! sensible heat flux
     real(r8) :: wsx(pcols)              ! surface u-stress (N)
     real(r8) :: wsy(pcols)              ! surface v-stress (N)
     real(r8) :: tref(pcols)             ! ref height surface air temp
     real(r8) :: ts(pcols)               ! sfc temp (merged w/ocean if coupled)
     real(r8) :: cflx(pcols,pcnst+pnats) ! constituent flux (evap)
  end type srfflx_state

!---------------------------------------------------------------------------
! This is for surface fluxes returned from individual parameterizations
!---------------------------------------------------------------------------

  type srfflx_parm
     character(len=24) :: name    ! name of parameterization which produced tendencies

     real(r8) :: asdir(pcols)     ! albedo: shortwave, direct
     real(r8) :: asdif(pcols)     ! albedo: shortwave, diffuse
     real(r8) :: aldir(pcols)     ! albedo: longwave, direct
     real(r8) :: aldif(pcols)     ! albedo: longwave, diffuse
     real(r8) :: lwup(pcols)      ! longwave up radiative flux
     real(r8) :: lhf(pcols)       ! latent heat flux
     real(r8) :: shf(pcols)       ! sensible heat flux
     real(r8) :: wsx(pcols)       ! surface u-stress (N)
     real(r8) :: wsy(pcols)       ! surface v-stress (N)
     real(r8) :: tref(pcols)      ! ref height surface air temp
     real(r8) :: ts(pcols)        ! sfc temp (merged w/ocean if coupled)
     real(r8) :: cflx(pcols,pcnst+pnats)     ! pcnst+pnats constituent flux (evap)
  end type srfflx_parm

  type (surface_state), allocatable :: surface_state2d(:)
  type (srfflx_state), allocatable :: srfflx_state2d(:)
  type (srfflx_parm), allocatable :: srfflx_parm2d(:)

!===============================================================================
CONTAINS
!===============================================================================

!======================================================================
! PUBLIC ROUTINES: Following routines are publically accessable
!======================================================================
!----------------------------------------------------------------------- 
! 
! BOP
!
! !IROUTINE: initialize_comsrf
!
! !DESCRIPTION:
!
! Initialize the procedure for specifying sea surface temperatures
! Do initial read of time-varying ice boundary dataset, reading two
! consecutive months on either side of the current model date.
!
! Method: 
! 
! Author: 
! 
!-----------------------------------------------------------------------
!
! !INTERFACE
!
  subroutine initialize_comsrf
!-----------------------------------------------------------------------
!
! Purpose:
! Initialize surface data
!
! Method:
!
! Author: Mariana Vertenstein
!
!-----------------------------------------------------------------------
    implicit none

    integer k,c      ! level, constituent indices

    allocate (landm   (pcols,begchunk:endchunk))
    allocate (sgh     (pcols,begchunk:endchunk))
    allocate (sicthk  (pcols,begchunk:endchunk))
    allocate (snowhice(pcols,begchunk:endchunk))
    allocate (snowhland(pcols,begchunk:endchunk))
    allocate (fsns    (pcols,begchunk:endchunk))         
    allocate (fsnt    (pcols,begchunk:endchunk))         
    allocate (flns    (pcols,begchunk:endchunk))         
    allocate (flnt    (pcols,begchunk:endchunk))         
    allocate (srfrpdel(pcols,begchunk:endchunk))
    allocate (psm1    (pcols,begchunk:endchunk))
    allocate (absorb  (pcols,begchunk:endchunk))
    allocate (prcsnw  (pcols,begchunk:endchunk))
    allocate (landfrac(pcols,begchunk:endchunk))
    allocate (ocnfrac (pcols,begchunk:endchunk))
    allocate (icefrac (pcols,begchunk:endchunk))
    allocate (previcefrac (pcols,begchunk:endchunk))
    allocate (trefmxav(pcols,begchunk:endchunk))
    allocate (trefmnav(pcols,begchunk:endchunk))

    allocate (tsice(pcols,begchunk:endchunk))
    allocate (asdirice(pcols,begchunk:endchunk))
    allocate (aldirice(pcols,begchunk:endchunk))
    allocate (asdifice(pcols,begchunk:endchunk))
    allocate (aldifice(pcols,begchunk:endchunk))

    allocate (srfflx_state2d(begchunk:endchunk))
    allocate (srfflx_parm2d(begchunk:endchunk))
    allocate (surface_state2d(begchunk:endchunk))
!
! Initialize to NaN or Inf
!
    landm    (:,:) = inf
    sgh      (:,:) = inf
    sicthk   (:,:) = inf
!
! snowhice and snowhland are only defined for a single surface type
! elements of the array outside valid surface points must be set to
! zero if these fields are to be written to netcdf history files.
!
    snowhice (:,:) = 0.
    snowhland(:,:) = 0.
    fsns     (:,:) = inf
    fsnt     (:,:) = inf
    flns     (:,:) = inf
    flnt     (:,:) = inf
    srfrpdel (:,:) = inf
    psm1     (:,:) = inf
    absorb   (:,:) = inf
    prcsnw   (:,:) = inf
    landfrac (:,:) = inf
    ocnfrac  (:,:) = inf
    icefrac  (:,:) = inf
    previcefrac  (:,:) = inf
    trefmxav (:,:) = inf
    trefmnav (:,:) = inf

    asdirice (:,:) = inf
    aldirice (:,:) = inf
    asdifice (:,:) = inf
    aldifice (:,:) = inf
    tsice (:,:) = inf
!
! Sub-surface temperatures
!
    if (plevmx > 9) then
       write(6,*)'INITIALIZE_COMSRF: Cannot handle more than 9 subsurface levels'
       call endrun ()
    endif
    do k=1,plevmx
       write(unit=tsnam(k),fmt='(''TS'',i1,''     '')') k
    end do

    do c = begchunk,endchunk
       srfflx_state2d(c)%asdir  (:) = 0.
       srfflx_state2d(c)%asdif  (:) = 0.
       srfflx_state2d(c)%aldir  (:) = 0.
       srfflx_state2d(c)%aldif  (:) = 0.
       srfflx_state2d(c)%lwup   (:) = 0.
       srfflx_state2d(c)%lhf    (:) = 0.
       srfflx_state2d(c)%shf    (:) = 0.
       srfflx_state2d(c)%cflx   (:,:) = 0.
       srfflx_state2d(c)%wsx    (:) = 0.
       srfflx_state2d(c)%wsy    (:) = 0.
       srfflx_state2d(c)%tref   (:) = 0.
       srfflx_state2d(c)%ts     (:) = 0.

       surface_state2d(c)%tbot  (:) = 0.
       surface_state2d(c)%zbot  (:) = 0.
       surface_state2d(c)%ubot  (:) = 0.
       surface_state2d(c)%vbot  (:) = 0.
       surface_state2d(c)%qbot  (:) = 0.
       surface_state2d(c)%pbot  (:) = 0.
       surface_state2d(c)%thbot (:) = 0.
       surface_state2d(c)%tssub (:,:) = 0.
    end do
    
    call srfflx_parm_reset (srfflx_parm2d)

    return
  end subroutine initialize_comsrf

!===========================================================================
  subroutine srfflx_parm_reset(parm)
!---------------------------------------------------------------------------
!
! Purpose:
! Zero fluxes that are update by land,ocn,ice sub processes
!
! Method:
!
! Author: John Truesdale
!
!-----------------------------------------------------------------------
    implicit none
    type(srfflx_parm), intent(inout),dimension(begchunk:endchunk)  :: parm ! Parameterization tendencies
    integer c        ! chunk index

    call t_startf ('srfflx_rst_st')
    do c=begchunk,endchunk
       parm(c)%asdir(:) = 0.
       parm(c)%asdif(:) = 0.
       parm(c)%aldir(:) = 0.
       parm(c)%aldif(:) = 0.
       parm(c)%lwup (:) = 0.
       parm(c)%lhf  (:) = 0.
       parm(c)%shf  (:) = 0.
       parm(c)%cflx (:,:) = 0.
       parm(c)%wsx  (:) = 0.
       parm(c)%wsy  (:) = 0.
       parm(c)%tref (:) = 0.
       parm(c)%ts   (:) = 0.
    end do
    call t_stopf ('srfflx_rst_st')
    return
  end subroutine srfflx_parm_reset

  subroutine srfflx_state_reset(state)
!-----------------------------------------------------------------------
!
! Purpose:
! Zero fluxes that are update by land,ocn,ice sub processes
!
! Method:
!
! Author: John Truesdale
!
!-----------------------------------------------------------------------
    implicit none
    type(srfflx_state), dimension(begchunk:endchunk), intent(inout)  :: state   ! srfflx state variables
    integer c        ! chunk index

    call t_startf ('srfflx_rst_st')
    do c=begchunk,endchunk
       state(c)%asdir(:) = 0.
       state(c)%asdif(:) = 0.
       state(c)%aldir(:) = 0.
       state(c)%aldif(:) = 0.
       state(c)%lwup(:) = 0.
       state(c)%lhf(:) = 0.
       state(c)%shf(:) = 0.
       state(c)%cflx(:,:) = 0.
       state(c)%wsx(:) = 0.
       state(c)%wsy(:) = 0.
       state(c)%tref(:) = 0.
       state(c)%ts(:) = 0.
    end do
    call t_stopf ('srfflx_rst_st')

    return
  end subroutine srfflx_state_reset

  subroutine update_srf_fluxes(state, parm, frac)
!-----------------------------------------------------------------------
!
! Purpose:
! update surface fluxes
!
! Method:
!
! Author: John Truesdale
!
!------------------------------Arguments--------------------------------

    use physconst, only: stebol
    use phys_grid, only: get_ncols_p

    implicit none

    type(srfflx_parm), intent(inout)  :: parm(begchunk:endchunk)
    type(srfflx_state), intent(inout) :: state(begchunk:endchunk)
    real(r8) :: frac(pcols,begchunk:endchunk)
!
! Local workspace
!
    integer :: i,c,m     ! longitude, chunk, constituent indices
    integer :: ncol      ! number of longitudes this chunk

    call t_startf ('update_srf_st')
    do c=begchunk,endchunk
       ncol = get_ncols_p(c)
       do i=1,ncol
          if (frac(i,c) > 0.) then
             state(c)%asdir(i) = state(c)%asdir(i) + parm(c)%asdir(i) * frac(i,c)
             state(c)%asdif(i) = state(c)%asdif(i) + parm(c)%asdif(i) * frac(i,c)
             state(c)%aldir(i) = state(c)%aldir(i) + parm(c)%aldir(i) * frac(i,c)
             state(c)%aldif(i) = state(c)%aldif(i) + parm(c)%aldif(i) * frac(i,c)
             state(c)%lwup(i)  = state(c)%lwup(i)  + parm(c)%lwup(i)  * frac(i,c)
             state(c)%lhf(i)   = state(c)%lhf(i)   + parm(c)%lhf(i)   * frac(i,c)
             state(c)%shf(i)   = state(c)%shf(i)   + parm(c)%shf(i)   * frac(i,c)
             state(c)%wsx(i)   = state(c)%wsx(i)   + parm(c)%wsx(i)   * frac(i,c)
             state(c)%wsy(i)   = state(c)%wsy(i)   + parm(c)%wsy(i)   * frac(i,c)
             state(c)%tref(i)  = state(c)%tref(i)  + parm(c)%tref(i)  * frac(i,c) 

!
! if we are calculating ts for a non-fractional grid box (ie all land or
! all ocean or all ice then use the ts given by the parameterization) 
! otherwise calculate ts based on the grid averaged lwup 
!
!jt pull this code out after bit for bit testing
!jt
          if (frac(i,c) == 1.) then  
             state(c)%ts(i) = state(c)%ts(i) + &
                  parm(c)%ts(i) * frac(i,c) 
          else
             state(c)%ts(i)=sqrt(sqrt(state(c)%lwup(i)/stebol))
          end if

             do m=1,pcnst+pnats
                state(c)%cflx(i,m) = state(c)%cflx(i,m) + parm(c)%cflx(i,m) * frac(i,c)
             end do
          end if
       end do
    end do
!
! zero srfflx parameterization
!
    call t_stopf ('update_srf_st')
    call srfflx_parm_reset(parm)

    return
  end subroutine update_srf_fluxes

  subroutine update_srf_fractions
!-----------------------------------------------------------------------
!
! Purpose:
! update surface fluxes
!
! Method:
!
! Author: John Truesdale
!
!-----------------------------------------------------------------------
    use phys_grid, only: get_ncols_p

    implicit none

    integer :: j,i,ncol

! Make land ocean and ice concentrations consistant - after advnce
! is called the ice fraction will change due to interpolation in
! iceint so we must reapportion the ocean fraction accordingly.
!
! 1) land fraction is taken as given
! 2) ice percentage is allowed to occupy what is not land
!    ice percentage may be modified so that the sum of land and ice
!        fractions is <= 1.
! 3) ocean fraction is determined last.  Ocean occupies whatever is 
!    not land or ice
!
    call t_startf ('update_srf_st')
    do j=begchunk,endchunk
       ncol = get_ncols_p(j)
       do i=1,ncol
! fix inconsistancies between ice and land fractions, use land as truth
	if ((icefrac(i,j).gt.1.0.or.icefrac(i,j).lt.0.) .or. &
	   (landfrac(i,j).gt.1.0.or.landfrac(i,j).lt.0.)) then
	   write(6,*)'COMSRF: Error in orography fractions'
	   write(6,*)' Encountered a fraction greater than 1 or less than 0.'
	   write(6,*)' Calling endrun'
	   call endrun
	end if	
          if (icefrac(i,j)+landfrac(i,j) > 1.0_r8) then
             icefrac(i,j)=1.0_r8-landfrac(i,j)	
          end if
          ocnfrac(i,j)=1.0_r8-landfrac(i,j)-icefrac(i,j)
       end do
    end do
    call t_stopf ('update_srf_st')
    return
  end subroutine update_srf_fractions
end module comsrf
