! DART software - Copyright UCAR. This open source software is provided
! by UCAR, "as is", without charge, subject to all terms of use at
! http://www.image.ucar.edu/DAReS/DART/DART_download

! Thanks to Chris Riedel who developed the methods in this module.

module beta_distribution_mod

use types_mod,      only : r8, PI, missing_r8

use utilities_mod,  only : E_ERR, error_handler

use random_seq_mod, only : random_seq_type, random_uniform

use distribution_params_mod, only : distribution_params_type

use normal_distribution_mod, only : inv_cdf

implicit none
private

public :: beta_cdf,       inv_beta_cdf,         &
          beta_cdf_params, inv_beta_cdf_params, &
          beta_pdf, random_beta, test_beta, set_beta_params_from_ens

character(len=512)          :: errstring
character(len=*), parameter :: source = 'beta_distribution_mod.f90'

real(r8), parameter :: failed_value = -99.9_r8

contains

!-----------------------------------------------------------------------

subroutine test_beta

! This routine provides limited tests of the numerics in this module. It begins
! by comparing a handful of cases of the pdf and cdf to results from Matlab. It
! then tests the quality of the inverse cdf for a single shape/scale pair. Failing
! these tests suggests a serious problem. Passing them does not indicate that 
! there are acceptable results for all possible inputs. 

real(r8) :: x, y, p, inv
real(r8) :: alpha, beta, max_diff
integer :: i

! Comparative results for a handful of cases from MATLAB21a
real(r8) :: pdf_diff(7), cdf_diff(7)
real(r8) :: malpha(7) = [0.5_r8, 5.0_r8, 1.0_r8, 2.0_r8, 2.0_r8, 5.0_r8, 0.5_r8]
real(r8) :: mbeta(7) = [0.5_r8, 1.0_r8, 3.0_r8, 2.0_r8, 5.0_r8, 2.0_r8, 1.0_r8]
real(r8) :: mx(7)     = [0.1_r8, 0.3_r8, 0.5_r8, 0.6_r8, 0.7_r8, 0.8_r8, 0.9_r8]
! Generated by matlab betapdf(mx, malpha, mbeta)
real(r8) :: mpdf(7) = [1.061032953945969_r8, 0.040500000000000_r8, 0.750000000000000_r8, &
                       1.440000000000000_r8, 0.170100000000000_r8, 2.457600000000000_r8, &
                       0.527046276694730_r8]
! Generated by matlab gamcdf(mx, malpha, mbeta)
real(r8) :: mcdf(7) = [0.204832764699133_r8, 0.002430000000000_r8, 0.875000000000000_r8, &
                       0.648000000000000_r8, 0.989065000000000_r8, 0.655360000000000_r8, &
                       0.948683298050514_r8]

! Compare to matlab
write(*, *) 'Absolute value of differences should be less than 1e-15'
do i = 1, 7
   pdf_diff(i) = beta_pdf(mx(i), malpha(i), mbeta(i)) - mpdf(i)
   cdf_diff(i) = beta_cdf(mx(i), malpha(i), mbeta(i), 0.0_r8, 1.0_r8) - mcdf(i)
   write(*, *) i, pdf_diff(i), cdf_diff(i)
end do

! Test many x values for cdf and inverse cdf for a single set of alpha and beta
alpha = 5.0_r8
beta = 2.0_r8

max_diff = -1.0_r8
do i = 0, 1000
   x = i / 1000.0_r8
   p = beta_pdf(x, alpha, beta)
   y = beta_cdf(x, alpha, beta, 0.0_r8, 1.0_r8)
   inv = inv_beta_cdf(y, alpha, beta, 0.0_r8, 1.0_r8)
   max_diff = max(abs(x - inv), max_diff)
end do

write(*, *) '----------------------------'
write(*, *) 'max difference in inversion is ', max_diff
write(*, *) 'max difference should be less than 1e-14'

end subroutine test_beta

!-----------------------------------------------------------------------

function inv_beta_cdf_params(quantile, p) result(x)

real(r8)                                   :: x
real(r8), intent(in)                       :: quantile
type(distribution_params_type), intent(in) :: p

x = inv_cdf(quantile, beta_cdf_params, inv_beta_first_guess_params, p)

end function inv_beta_cdf_params

!-----------------------------------------------------------------------

function inv_beta_cdf(quantile, alpha, beta, lower_bound, upper_bound) result(x)

real(r8)             :: x
real(r8), intent(in) :: quantile
real(r8), intent(in) :: alpha, beta
real(r8), intent(in) :: lower_bound,   upper_bound

! Given a quantile, finds the value of x for which the scaled beta cdf
! with alpha and beta has approximately this quantile

type(distribution_params_type) :: p

if (alpha <= 0.0_r8 .or. beta <= 0.0_r8) then
  errstring = 'Negative input beta parameters'
  call error_handler(E_ERR, 'inv_beta_cdf', errstring, source)
endif

p%params(1) = alpha;  p%params(2) = beta
! Beta must be bounded on both sides
p%lower_bound = lower_bound;       p%upper_bound = upper_bound

x = inv_beta_cdf_params(quantile, p)

! Undo the scaling 
x = x * (upper_bound - lower_bound) + lower_bound

end function inv_beta_cdf

!---------------------------------------------------------------------------

function beta_pdf(x, alpha, beta)

! Returns the probability density of a beta function with alpha and beta
! at the value x

! Returns a large negative value if called with illegal values

real(r8) :: beta_pdf
real(r8), intent(in) :: x, alpha, beta

real(r8) :: gamma_ratio

! Parameters alpha and beta must be positive
if(alpha <= 0.0_r8 .or. beta <= 0.0_r8) then
   beta_pdf = failed_value
elseif(x < 0.0 .or. x > 1.0_r8) then
   beta_pdf = failed_value
elseif(alpha == 1.0_r8 .and. x == 0.0_r8) then
   ! Tricky stuff for x = 0 or 1; 
    beta_pdf = beta
elseif(beta == 1.0_r8 .and. x == 1.0_r8) then
    beta_pdf = alpha
elseif(alpha < 1.0_r8 .and. x == 0.0_r8) then
    beta_pdf = failed_value
elseif(beta < 1.0_r8 .and. x == 1.0_r8) then
    beta_pdf = failed_value
else
    ! Use definition via gammas since this is a Fortran intrinsic
    gamma_ratio = gamma(alpha) * gamma(beta) / gamma(alpha + beta)
    beta_pdf = x**(alpha - 1.0_r8) * (1.0_r8 - x)**(beta - 1.0_r8) / gamma_ratio
endif

end function beta_pdf

!---------------------------------------------------------------------------

function beta_cdf_params(x, p)

real(r8)                                   :: beta_cdf_params
real(r8), intent(in)                       :: x
type(distribution_params_type), intent(in) :: p

real(r8) :: alpha, beta

alpha = p%params(1);    beta = p%params(2)
beta_cdf_params = beta_cdf(x, alpha, beta, p%lower_bound, p%upper_bound)

end function beta_cdf_params

!---------------------------------------------------------------------------

function beta_cdf(x, alpha, beta, lower_bound, upper_bound)

! Returns the cumulative distribution of a beta function with alpha and beta
! at the value x

! Returns a large negative value if called with illegal values

real(r8) :: beta_cdf
real(r8), intent(in) :: x, alpha, beta
real(r8), intent(in) :: lower_bound,   upper_bound

! Parameters must be positive
if(alpha <= 0.0_r8 .or. beta <= 0.0_r8) then
   beta_cdf = failed_value
elseif(x < 0.0_r8 .or. x > 1.0_r8) then
   ! x must be in 0 1
   beta_cdf = failed_value
elseif(x == 0.0_r8) then 
   beta_cdf = 0.0_r8
elseif(x == 1.0_r8) then
   beta_cdf = 1.0_r8
elseif (x > (alpha + 1.0_r8)/(alpha + beta + 2.0_r8)) then
    beta_cdf = (1.0_r8 - incomplete_beta(beta, alpha, 1.0_r8 - x))
else
    beta_cdf = incomplete_beta(alpha, beta, x)
endif

end function beta_cdf

!---------------------------------------------------------------------------

function random_beta(r, alpha, beta)

! Note that this provides same qualitative functionality as a similarly named
! routine in the random_seq_mod that uses a rejection algorithm. However, once
! we have an inverse cdf function for a distribution, it is possible to generate
! random numbers by first getting a draw from a U(0, 1) and then inverting these
! quantiles to get an actual value

type(random_seq_type), intent(inout) :: r
real(r8),              intent(in)    :: alpha
real(r8),              intent(in)    :: beta
real(r8)                             :: random_beta

real(r8) :: quantile
if (alpha <= 0.0_r8) then
   write(errstring, *) 'Alpha parameter must be positive, was ', alpha
   call error_handler(E_ERR, 'random_beta', errstring, source)
endif

if (beta <= 0.0_r8) then
   write(errstring, *) 'Beta parameter must be positive, was ', beta
   call error_handler(E_ERR, 'random_beta', errstring, source)
endif

! Draw from U(0, 1) to get a quantile
quantile = random_uniform(r)
! Invert cdf to get a draw from beta
random_beta = inv_beta_cdf(quantile, alpha, beta, 0.0_r8, 1.0_r8)

end function random_beta

!---------------------------------------------------------------------------

function incomplete_beta(a,b,x)

! Computes an approximation of the incomplete beta integral using the continued
! fraction evaluation routine also found in numerical recipes

real(r8)             :: incomplete_beta
real(r8), intent(in) :: a, b, x

real(r8), parameter :: TINY = 1.0e-30
real(r8), parameter :: STOP = 1.0e-14
integer,  parameter :: max_iter = 100

real(r8) :: front, f, c, d, numerator, cd
integer  :: m, iter

if (x < 0.0_r8 .or. x > 1.0_r8) then
    errstring = 'Input value for x is not between 0 - 1'
    call error_handler(E_ERR, 'incomplete_beta', errstring, source)
endif

! Set a default failed value
incomplete_beta = missing_r8

front = exp(log(x)*a + log(1.0_r8-x)*b - log_beta(a, b)) / a
f = 1.0_r8
c = 1.0_r8
d = 0.0_r8

do iter = 0, max_iter
   m = floor(iter/2.0_r8)

   ! Initial step numerator is 1
   if (iter == 0) then
      numerator = 1.0_r8     
   ! Algorithm has an odd and even iteration step
   else if (mod(iter, 2) == 0) then
      numerator = (m*(b - m)*x)/((a + 2.0_r8*m - 1.0_r8)*(a + 2.0_r8*m))
   else
      numerator = -((a + m)*(a + b + m)*x)/((a + 2.0_r8*m)*(a + 2.0_r8*m + 1.0_r8))
   end if   

   d = 1.0_r8 + (numerator * d)
   if (abs(d) < TINY) d = TINY
   d = 1.0_r8 / d

   c = 1.0_r8 + (numerator/c)
   if (abs(c) < TINY) c = TINY

   cd = c*d
   f  = cd*f

   if (abs(1.0_r8 - cd) < STOP) then
      incomplete_beta = front * (f - 1.0_r8)
      return
   end if
end do

! Error if failed to converge
errstring = 'Alg. did not converge'
call error_handler(E_ERR, 'incomplete_beta', errstring, source)

end function incomplete_beta

!---------------------------------------------------------------------------

function log_beta(a, b)

real(r8)              :: log_beta
real(r8), intent(in)  :: a, b

log_beta = log(gamma(a)) + log(gamma(b)) - log(gamma(a + b))

end function log_beta

!---------------------------------------------------------------------------

function inv_beta_first_guess_params(quantile, p)

real(r8)                                   :: inv_beta_first_guess_params
real(r8), intent(in)                       :: quantile
type(distribution_params_type), intent(in) :: p

real(r8) :: alpha, beta

alpha = p%params(1);     beta = p%params(2)
inv_beta_first_guess_params = inv_beta_first_guess(quantile, alpha, beta, &
   p%bounded_below, p%bounded_above, p%lower_bound, p%upper_bound)

end function inv_beta_first_guess_params

!---------------------------------------------------------------------------

function inv_beta_first_guess(x, alpha, beta, &
   bounded_below, bounded_above, lower_bound, upper_bound)

real(r8) :: inv_beta_first_guess
real(r8), intent(in) :: x
real(r8), intent(in) :: alpha, beta
logical,  intent(in) :: bounded_below, bounded_above
real(r8), intent(in) :: lower_bound,   upper_bound

! Need some sort of first guess, should be smarter here
! For starters, take the mean for this alpha and beta
inv_beta_first_guess = alpha/(alpha + beta)

end function inv_beta_first_guess 

!---------------------------------------------------------------------------

subroutine beta_alpha_beta(x, num, alpha, beta)

! Computes the alpha and beta parameters for a beta distribution from an ensemble
! Assumes the ensemble members are confined to [0, 1]
! This may not be the maximum likelihood estimate

integer,  intent(in)  :: num
real(r8), intent(in)  :: x(num)
real(r8), intent(out) :: alpha
real(r8), intent(out) :: beta

real(r8) :: mean, variance

mean = sum(x) / num
variance  = sum((x - mean)**2) / (num- 1)
! Get alpha and beta
alpha = mean**2 * (1.0_r8 - mean) / variance - mean
beta  = alpha * (1.0_r8 / mean - 1.0_r8)

end subroutine beta_alpha_beta

!---------------------------------------------------------------------------

subroutine set_beta_params_from_ens(ens, num, lower_bound, upper_bound, p)

integer,                        intent(in)    :: num
real(r8),                       intent(in)    :: ens(num)
real(r8),                       intent(in)    :: lower_bound,   upper_bound
type(distribution_params_type), intent(inout) :: p
                                     
real(r8) :: alpha, beta

! Set the bounds info
p%lower_bound   = lower_bound;    p%upper_bound   = upper_bound

! Get alpha and beta for the scaled ensemble
call beta_alpha_beta(ens, num, alpha, beta)
p%params(1) = alpha
p%params(2) = beta

end subroutine set_beta_params_from_ens
                     
!---------------------------------------------------------------------------



end module beta_distribution_mod
