! DART software - Copyright UCAR. This open source software is provided
! by UCAR, "as is", without charge, subject to all terms of use at
! http://www.image.ucar.edu/DAReS/DART/DART_download

!----------------------------------------------------------------------
! WARNING!!  The file obs_kind_mod.f90 is AUTOGENERATED by the
! 'preprocess' program.  Any changes made to this file will be
! overwritten when it is regenerated.  To make permanent changes in
! the code, edit DEFAULT_obs_kind_mod.F90, edit the observation 
! specific obs_def_xxx_mod.f90 files, or edit the xxx_quantity.f90 files.
!----------------------------------------------------------------------

! FIXME: this should change to obs_qty_mod - but that is a large footprint,
! non-backwards compatible change.  almost every other module in the system
! has a use statement for this module

! module obs_qty_mod
module obs_kind_mod

use        types_mod, only : obstypelength, r8, MISSING_R8
use    utilities_mod, only : error_handler, E_ERR, E_WARN,  &
                             logfileunit, find_namelist_in_file, log_it,     &
                             check_namelist_read, do_output, ascii_file_format, &
                             string_to_real

implicit none
private

public :: get_name_for_type_of_obs,       &
          assimilate_this_type_of_obs,    &
          evaluate_this_type_of_obs,      &
          get_quantity_for_type_of_obs,   &
          get_index_for_type_of_obs,      &
          write_type_of_obs_table,        &
          read_type_of_obs_table,         &
          get_type_of_obs_from_menu,      &
          map_type_of_obs_table,          &
          use_ext_prior_this_type_of_obs, &
          get_name_for_quantity,          &
          get_index_for_quantity,         &
          set_namevalue_for_quantity,     &
          get_num_items_for_quantity,     &
          get_itemname_for_quantity,      &
          get_itemvalue_for_quantity,     &
          has_bounds_for_quantity 

public :: get_num_types_of_obs, get_num_quantities

!----------------------------------------------------------------------------
! These lists are autogenerated by the 'preprocess' program.  
! 
! To add new observation types (e.g. AIRS_U_WIND_COMPONENT), edit the 
! obs_def_xxx_mod.f90 files and add the filename to the 'obs_type_files' variable
! in the &preprocess_nml namelist of the model-specific work/input.nml file.
! There can be multiple filenames listed for 'obs_type_files'.
!
! To add a new fundamental quantity (e.g. QTY_TEMPERATURE), first examine
! all the xxx_quantities_mod.f90 files to be sure it does not already exist.  
! If it really does not, add QTY_xxx to the most appropriate file and 
! add xxx_quantities_mod.f90 to the 'quantity_files' variable in the &preprocess_nml 
! namelist.  There can be multiple filenames listed for 'quantity_files'.
!
! Add a descriptive comment along with expected units and any other
! helpful information.  These quantities should be useable by any
! model of the same system to allow interoperability and comparisons
! between model results.
!

! DART PREPROCESS INTEGER DECLARATIONS INSERTED HERE

!----------------------------------------------------------------------------

character(len=*), parameter :: source = 'DEFAULT_obs_def_mod.F90'

! integer, parameters: max_defined_types_of_obs, max_defined_quantities 
! generated and inserted by preprocess.

logical, save :: module_initialized = .false.

character(len=512) :: msg_string, msg_string1

! @todo FIXME: what is the right len for a units and
! other name/value pair strings?
integer, parameter :: namelen  = 256
integer, parameter :: valuelen = 256

integer :: num_types_assimilate, num_types_evaluate 
integer :: num_types_use_precomputed_FOs

! Map from values of type in a TOC (e.g. the start of an obs_seq file)
!  to the type index in this module.
! Initially, these are undefined and have values -1.
! In each entry, the toc_type_index value is the index in the table of
! contents (usually an input obs_sequence file), and the mod_type_index 
! is the current type value in this module.

type toc_mod_type_map_type
   integer :: toc_type_index(max_defined_types_of_obs) = -1
   integer :: mod_type_index(max_defined_types_of_obs) = -1
end type toc_mod_type_map_type

type(toc_mod_type_map_type) :: toc_mod_type_map

! old:
!integer :: map(2, max_defined_types_of_obs) = -1

! An observation type links together a unique integer index, 
! a character string which matches the integer parameter name, 
! what quantity this type is associated with,
! and whether observations of this type should be assimilated,
! evaluated, or neither.
!
! Name lengths are limited to 32 characters by compiler
! restrictions on the length of parameter identifiers.
type obs_type_type
   integer              :: index = -1
   character(len=obstypelength) :: name = ''
   integer              :: quantity = -1
   logical              :: assimilate = .false.
   logical              :: evaluate = .false.
   logical              :: use_precomputed_FO = .false.
end type obs_type_type

type(obs_type_type) :: obs_type_info(max_defined_types_of_obs)

! An observation quantity type stores a unique integer index,
! a character string which matches the integer parameter name,
! and name/value pairs of metadata for this quantity.

integer, parameter :: MAX_ITEMS = 50

type obs_qty_type
   integer                      :: index = -1
   character(len=obstypelength) :: name = ''
   integer                      :: nitems = 0
   character(len=namelen)       :: itemname(MAX_ITEMS)  = ''
   character(len=valuelen)      :: itemvalue(MAX_ITEMS) = ''
end type obs_qty_type

! the raw quantity uses index 0, so this needs to match.
type(obs_qty_type) :: obs_qty_info(0:max_defined_quantities)


! Namelist array to turn on any requested observation types
character(len=obstypelength) :: assimilate_these_obs_types(max_defined_types_of_obs) = 'null'
character(len=obstypelength) :: evaluate_these_obs_types(max_defined_types_of_obs) = 'null'
character(len=obstypelength) :: use_precomputed_FOs_these_obs_types(max_defined_types_of_obs) = 'null' 


! namelist /obs_qty_nml/ ...
namelist /obs_kind_nml/ assimilate_these_obs_types, &
                        evaluate_these_obs_types, &
                        use_precomputed_FOs_these_obs_types

contains

!----------------------------------------------------------------------------

subroutine initialize_module()

integer :: iunit, io, i, j
character(len = 169) :: err_string
character(len=*), parameter :: routine = 'initialize_module'

module_initialized = .true.

! Read the namelist entry
call find_namelist_in_file("input.nml", "obs_kind_nml", iunit)
read(iunit, nml = obs_kind_nml, iostat = io)
call check_namelist_read(iunit, io, "obs_kind_nml")


!----------------------------------------------------------------------------

! These lists are autogenerated by the 'preprocess' program.  
!
! To add quantities, edit the appropriate xxx_quantity_mod.f90 files
! and then add them to the 'quantity_files' variable in the
! &preprocess_nml namelist in the input.nml file in the current directory.
!
! To add types, edit the obs_def_xxx_mod.f90 files and then add them
! to the 'obs_type_files' variable of the &preprocess_nml namelist
! in the input.nml file in the current directory.
!
! Associate integer parameter names with a string of the same name.  
! Also associate types of obs with the quantity.

! DART PREPROCESS DERIVED TYPE INITIALIZATIONS INSERTED HERE

! Default for all obs is to not assimilate or evaluate.
! Count up number being assimilated and evaluated here.

num_types_assimilate = 0
do i = 1, max_defined_types_of_obs
   if(assimilate_these_obs_types(i) == 'null' .or. len_trim(assimilate_these_obs_types(i)) == 0 ) exit
   num_types_assimilate = i
end do

num_types_evaluate = 0
do i = 1, max_defined_types_of_obs
   if(evaluate_these_obs_types(i) == 'null' .or. len_trim(evaluate_these_obs_types(i)) == 0) exit
   num_types_evaluate = i
end do

! Special case when all obs_types should use precomputed_FOs
if( any(use_precomputed_FOs_these_obs_types .eq. 'all') ) then
   num_types_use_precomputed_FOs = num_types_assimilate + num_types_evaluate
   j = 1
   if ( num_types_assimilate > 0 ) then
      use_precomputed_FOs_these_obs_types(j:num_types_assimilate) = assimilate_these_obs_types(1:num_types_assimilate)
      j = j + num_types_assimilate
   endif
   if ( num_types_evaluate > 0 ) use_precomputed_FOs_these_obs_types(j:num_types_use_precomputed_FOs) = evaluate_these_obs_types(1:num_types_evaluate)
else
   num_types_use_precomputed_FOs = 0
   do i = 1, max_defined_types_of_obs
      if(use_precomputed_FOs_these_obs_types(i) == 'null' .or.  len_trim(use_precomputed_FOs_these_obs_types(i)) == 0) exit
      num_types_use_precomputed_FOs = i
   end do
endif

if (do_output() .and. (num_types_assimilate > 0 .or. &
                       num_types_evaluate > 0   .or. &
                       num_types_use_precomputed_FOs > 0 )) then  
   call log_it('')
   call log_it('Assimilate_these_obs_types:')
   if (num_types_assimilate < 1) then
         call log_it('   none')
   else
      do i = 1, num_types_assimilate
         call log_it('   '//trim(assimilate_these_obs_types(i)))
      enddo
   endif

   call log_it('Evaluate_these_obs_types:')
   if (num_types_evaluate <1) then
         call log_it('   none')
   else
      do i = 1, num_types_evaluate
         call log_it('   '//trim(evaluate_these_obs_types(i)))
      enddo
   endif

   call log_it('Use the precomputed Prior Forward Operators for these obs types:')
   if (num_types_use_precomputed_FOs <1) then
         call log_it('   none')
   else
      do i = 1, num_types_use_precomputed_FOs
         call log_it('   '//trim(use_precomputed_FOs_these_obs_types(i)))
      enddo
   endif
   call log_it('')
endif


! Figure out which types are being used, look for errors
! Start by loading up types to assimilate
if (num_types_assimilate > 0) then
   do i = 1, num_types_assimilate
      ! Search for the matching string
      do j = 1, max_defined_types_of_obs
         if(assimilate_these_obs_types(i) == obs_type_info(j)%name) then
            obs_type_info(j)%assimilate = .true.
            goto 44
         endif
      end do
      ! Falling off the end is an error
      write(err_string, *) '"',trim(assimilate_these_obs_types(i)), &
         '" from obs_kind_nml::assimilate_these_obs_types is not a legal observation type'
      call error_handler(E_ERR, routine, err_string, source)
      44 continue
   end do
endif

! Now look for types to evaluate
if (num_types_evaluate > 0) then
   do i = 1, num_types_evaluate
      ! Search for the matching string
      do j = 1, max_defined_types_of_obs
         if(evaluate_these_obs_types(i) == obs_type_info(j)%name) then
            obs_type_info(j)%evaluate = .true.
            goto 55
         endif
      end do
      ! Falling off the end is an error
      write(err_string, *) '"',trim(evaluate_these_obs_types(i)), &
         '" from obs_kind_nml::evaluate_these_obs_types is not a legal observation type'
      call error_handler(E_ERR, routine, err_string, source)
      55 continue
   end do
endif

if (num_types_use_precomputed_FOs > 0) then
   do i = 1, num_types_use_precomputed_FOs
      ! Search for the matching string
      do j = 1, max_defined_types_of_obs
         if(use_precomputed_FOs_these_obs_types(i) == obs_type_info(j)%name) then
            obs_type_info(j)%use_precomputed_FO = .true.
            goto 66
         endif
      end do
      ! Falling off the end is an error
      write(err_string, *) '"',trim(use_precomputed_FOs_these_obs_types(i)), &
         '" from obs_kind_nml::use_precomputed_FOs_these_obs_types is not a legal observation type'
      call error_handler(E_ERR, routine, err_string, source)
      66 continue
   end do
endif

! Make it an error to ask to assimilate AND evaluate the same obs kind
do i = 1, max_defined_types_of_obs
   if(obs_type_info(i)%evaluate .and. obs_type_info(i)%assimilate) then
      write(err_string, *) 'Illegal to both evaluate and assimilate same type ', &
         trim(obs_type_info(i)%name)
      call error_handler(E_ERR, routine, err_string, source)
   endif
end do

end subroutine initialize_module

!---------------------------------------------------------------------------

function map_type_of_obs_table(obs_def_index)

! Argument is the index from the obs_def; needs to be mapped to the appropriate
! Integer storage index
integer, intent(in) :: obs_def_index
integer             :: map_type_of_obs_table

character(len = 169) :: err_string
integer :: i
character(len=*), parameter :: routine = "map_type_of_obs_table"

if ( .not. module_initialized ) call initialize_module

! Need to search through the first map column to find this obs_def_index value
! Then return the index into table in this module from corresponding row in
! second column.
do i = 1, max_defined_types_of_obs
   if(toc_mod_type_map%toc_type_index(i) == obs_def_index) then
      map_type_of_obs_table = toc_mod_type_map%mod_type_index(i)
      return
   endif
end do

! Error, didn't find this obs_def_index in the map
write(err_string, *) 'Could not find obs type index ', obs_def_index, &
   ' in current type list compiled in this program'
call error_handler(E_ERR, routine, err_string, source)

end function map_type_of_obs_table

!----------------------------------------------------------------------------

function get_name_for_type_of_obs(obs_type_ind)

! Returns observation type name

integer, intent(in) :: obs_type_ind
character(len=obstypelength) :: get_name_for_type_of_obs
character(len=*), parameter :: routine = 'get_name_for_type_of_obs'

if ( .not. module_initialized ) call initialize_module

call validate_obs_type_index(obs_type_ind, routine)

get_name_for_type_of_obs = obs_type_info(obs_type_ind)%name

end function get_name_for_type_of_obs

!----------------------------------------------------------------------------
! Added by TRW to handle matching RAW variable types to their strings
! as well as the derived types - this will make the restart file
! handling more readable.

function get_name_for_quantity(obs_qty_ind)

! Returns observation quantity name

integer, intent(in) :: obs_qty_ind
character(len=obstypelength) :: get_name_for_quantity

character(len=*), parameter :: routine = 'get_name_for_quantity'

if (.not. module_initialized) call initialize_module

call validate_obs_qty_index(obs_qty_ind, routine)

get_name_for_quantity = obs_qty_info(obs_qty_ind)%name

end function get_name_for_quantity
!----------------------------------------------------------------------------

function get_index_for_type_of_obs(obs_type_name)

! Returns the integer index corresponding to an observation type string name
! Returns a -1 if this string is not in list

character(len = *), intent(in)  :: obs_type_name
integer                         :: get_index_for_type_of_obs

integer :: i
character(len=*), parameter :: routine = 'get_index_for_type_of_obs'

if ( .not. module_initialized ) call initialize_module

!>@todo FIXME binary search on a sorted list?

do i = 1, max_defined_types_of_obs
   if(obs_type_name == obs_type_info(i)%name) then
      get_index_for_type_of_obs = i
      return
   endif
end do

get_index_for_type_of_obs = -1

end function get_index_for_type_of_obs

!----------------------------------------------------------------------------
! Added by TRW to handle matching RAW variable types to their strings
! as well as the derived types - this will make the restart file
! handling more readable.

function get_index_for_quantity(obs_qty_name)

! Returns the integer index corresponding to an observation quantity string name
! Returns a -1 if this string is not in list

character(len=*), intent(in)  :: obs_qty_name
integer                       :: get_index_for_quantity

integer :: i
character(len=*), parameter :: routine = 'get_index_for_quantity'

if (.not. module_initialized) call initialize_module

do i = 0, max_defined_quantities
   if(obs_qty_name == obs_qty_info(i)%name) then
      get_index_for_quantity = i
      return
   end if
end do

get_index_for_quantity = -1

end function get_index_for_quantity

!----------------------------------------------------------------------------
! Add a name/value pair to this quantity.
! Error if index out of range
!
! FIXME: find a better identifier than 'item' here? meta something?

subroutine set_namevalue_for_quantity(obs_qty_ind, itemname, itemvalue)

integer, intent(in) :: obs_qty_ind
character(len=*), intent(in) :: itemname
character(len=*), intent(in) :: itemvalue

integer :: i
character(len=*), parameter :: routine = 'set_namevalue_for_quantity'

if (.not. module_initialized) call initialize_module

call validate_obs_qty_index(obs_qty_ind, routine)

call validate_metadata_strings(obs_qty_ind, itemname, itemvalue)

! FIXME: are replicated names an error?
! they could replace existing value for that name; or error out.

do i=1, obs_qty_info(obs_qty_ind)%nitems
   if (obs_qty_info(obs_qty_ind)%itemname(i) == itemname) then
      ! item already found - do what? replace
      obs_qty_info(obs_qty_ind)%itemvalue(i) = itemvalue
      ! or error out?
      ! call error_handler()
      return
   endif
enddo

! add new entry
i = obs_qty_info(obs_qty_ind)%nitems + 1 
obs_qty_info(obs_qty_ind)%nitems = i
obs_qty_info(obs_qty_ind)%itemname(i) = itemname
obs_qty_info(obs_qty_ind)%itemvalue(i) = itemvalue

end subroutine set_namevalue_for_quantity

!----------------------------------------------------------------------------
! Get number of name/value items for quantity
! Error if qty index out of range

! (FIXME: terminology: metadata vs item vs ??)

function get_num_items_for_quantity(obs_qty_ind)

integer, intent(in) :: obs_qty_ind
integer :: get_num_items_for_quantity

integer :: i
character(len=*), parameter :: routine = 'get_num_items_for_quantity'

if (.not. module_initialized) call initialize_module

call validate_obs_qty_index(obs_qty_ind, routine)

get_num_items_for_quantity = obs_qty_info(obs_qty_ind)%nitems

end function get_num_items_for_quantity

!----------------------------------------------------------------------------
! Get string value for item name by index for quantity of name/value pair
! Error if qty index out of range
! Error if item index out of range

! (FIXME: terminology: metadata vs item vs ??)

function get_itemname_for_quantity(obs_qty_ind, item_index)

integer, intent(in) :: obs_qty_ind
integer, intent(in) :: item_index
character(len=namelen) :: get_itemname_for_quantity

integer :: i
character(len=*), parameter :: routine = 'get_itemname_for_quantity'

if (.not. module_initialized) call initialize_module

! this validates the quantity index first, then the item index.
! if it returns w/o error, both indices are safe to use.
call validate_qty_item_index(obs_qty_ind, item_index, routine)

get_itemname_for_quantity = obs_qty_info(obs_qty_ind)%itemname(item_index)

end function get_itemname_for_quantity

!----------------------------------------------------------------------------
! Get string value for quantity by (qty index, item name) of name/value pair
! Error if qty index out of range
! Returns '' if no item name match  (or 'null'?)

! (FIXME: terminology: metadata vs item vs ??)

function get_itemvalue_for_quantity(obs_qty_ind, itemname)

integer, intent(in) :: obs_qty_ind
character(len=*), intent(in) :: itemname
character(len=valuelen) :: get_itemvalue_for_quantity

integer :: i
character(len=*), parameter :: routine = 'get_itemvalue_for_quantity'

if (.not. module_initialized) call initialize_module

call validate_obs_qty_index(obs_qty_ind, routine)

do i=1, obs_qty_info(obs_qty_ind)%nitems
   if (obs_qty_info(obs_qty_ind)%itemname(i) == itemname) then
      get_itemvalue_for_quantity = obs_qty_info(obs_qty_ind)%itemvalue(i)
      return
   endif
enddo

get_itemvalue_for_quantity = ''

end function get_itemvalue_for_quantity

!----------------------------------------------------------------------------
! convenience routine, could also be queried using the generic name=value interface
! Get bounds values for quantity by index
! Returns .false. if both min and max are missing_r8
! A potential code shortcut for calling code if no bounds are present

function has_bounds_for_quantity(obs_qty_ind, minbound, maxbound)

integer,  intent(in)  :: obs_qty_ind
real(r8), intent(out) :: minbound
real(r8), intent(out) :: maxbound
logical :: has_bounds_for_quantity

integer :: i
character(len=valuelen) :: boundstring
character(len=*), parameter :: routine = 'get_bounds_for_quantity'

if (.not. module_initialized) call initialize_module

call validate_obs_qty_index(obs_qty_ind, routine)

minbound = MISSING_R8
maxbound = MISSING_R8

do i=1, obs_qty_info(obs_qty_ind)%nitems
   if (obs_qty_info(obs_qty_ind)%itemname(i) == "minbound") then
      boundstring = obs_qty_info(obs_qty_ind)%itemvalue(i)
      minbound = string_to_real(boundstring)
   endif
   if (obs_qty_info(obs_qty_ind)%itemname(i) == "maxbound") then
      boundstring = obs_qty_info(obs_qty_ind)%itemvalue(i)
      maxbound = string_to_real(boundstring)
   endif
enddo

has_bounds_for_quantity = .not. (minbound == MISSING_R8 .and. maxbound == MISSING_R8)

end function has_bounds_for_quantity

!----------------------------------------------------------------------------
!> Accessor function to return observation type count

function get_num_types_of_obs()

integer :: get_num_types_of_obs

if ( .not. module_initialized ) call initialize_module

get_num_types_of_obs = max_defined_types_of_obs

end function get_num_types_of_obs

!----------------------------------------------------------------------------
!> Accessor function to return observation quantity count

function get_num_quantities()

integer :: get_num_quantities

if (.not. module_initialized) call initialize_module

get_num_quantities = max_defined_quantities

end function get_num_quantities

!----------------------------------------------------------------------------
!> Returns true if this obs_type is being assimilated

function assimilate_this_type_of_obs(obs_type_ind)

logical             :: assimilate_this_type_of_obs
integer, intent(in) :: obs_type_ind

character(len=*), parameter :: routine = 'assimilate_this_type_of_obs'

if ( .not. module_initialized ) call initialize_module

call validate_obs_type_index(obs_type_ind, routine)

assimilate_this_type_of_obs = obs_type_info(obs_type_ind)%assimilate

end function assimilate_this_type_of_obs

!----------------------------------------------------------------------------
!> Returns true if this obs_type is being evaluated

function evaluate_this_type_of_obs(obs_type_ind)

logical             :: evaluate_this_type_of_obs
integer, intent(in) :: obs_type_ind

character(len=*), parameter :: routine = 'evaluate_this_type_of_obs'

if ( .not. module_initialized ) call initialize_module

call validate_obs_type_index(obs_type_ind, routine)

evaluate_this_type_of_obs = obs_type_info(obs_type_ind)%evaluate

end function evaluate_this_type_of_obs

!----------------------------------------------------------------------------
!> Returns true if this obs_type should use externally computed priors

function use_ext_prior_this_type_of_obs(obs_type_ind)

logical             :: use_ext_prior_this_type_of_obs
integer, intent(in) :: obs_type_ind

character(len=*), parameter :: routine = 'use_ext_prior_this_type_of_obs'

if ( .not. module_initialized ) call initialize_module

call validate_obs_type_index(obs_type_ind, routine)

use_ext_prior_this_type_of_obs = obs_type_info(obs_type_ind)%use_precomputed_FO

end function use_ext_prior_this_type_of_obs

!----------------------------------------------------------------------------
!> Returns the associated generic quantity associated with the
!> specific type of this observation

function get_quantity_for_type_of_obs(obs_type_ind)

integer, intent(in) :: obs_type_ind
integer             :: get_quantity_for_type_of_obs

character(len=*), parameter :: routine = 'get_quantity_for_type_of_obs'

if ( .not. module_initialized ) call initialize_module

call validate_obs_type_index(obs_type_ind, routine)

get_quantity_for_type_of_obs = obs_type_info(obs_type_ind)%quantity

end function get_quantity_for_type_of_obs

!----------------------------------------------------------------------------
!> Writes out the observation type strings and corresponding integer
!> indices as a header for an obs_sequence file.

subroutine write_type_of_obs_table(ifile, fform, use_list)

integer, intent(in)                    :: ifile
character(len=*), intent(in), optional :: fform
integer,          intent(in), optional :: use_list(:)

integer :: i, ntypes
logical :: is_ascii, restrict
character(len=*), parameter :: routine = 'write_type_of_obs_table'

if ( .not. module_initialized ) call initialize_module

is_ascii = ascii_file_format(fform)

! Write the 20 character identifier to indicate the start of a type table.
! To maintain complete backwards compatibility with the original read
! code this string must start in column 1.
! you cannot use: write(ifile, *) 'string'  because the output string
! will start in col 2.  the string either has to be part of the format
! argument to write(), or you have to use a separate format statement.
! FIXME: this needs to be obs_type_definitions for write.  read has to
! accept either kind (now quantity and was incorrect for this table in
! any case) or type.
if (is_ascii) then
   write(ifile,  "('obs_type_definitions')")   ! see note above!
else
   write(ifile)    'obs_type_definitions'
endif

! If this routine is called with a list of which types are actually
! being used, restrict the table of contents to only those.
! Otherwise, write all known types.
if (present(use_list)) then
   ! make sure the list is the right length
   if (size(use_list) /= max_defined_types_of_obs) then
      call error_handler(E_ERR, routine, &
              'use_list(:) must be the same length as number of types', source)
   endif

   ntypes = count(use_list(:) > 0)
   restrict = .true.
else
   ntypes = max_defined_types_of_obs
   restrict = .false.
endif

if (is_ascii) then
   write(ifile, *) ntypes
else
   write(ifile)    ntypes
endif

do i = 1, max_defined_types_of_obs
   if (restrict) then
       if (use_list(i) == 0) cycle
   endif

   if (is_ascii) then
      write(ifile, *) obs_type_info(i)%index, obs_type_info(i)%name
   else
      write(ifile)    obs_type_info(i)%index, obs_type_info(i)%name
   endif
end do

end subroutine write_type_of_obs_table

!----------------------------------------------------------------------------
!> Reads the observation type strings and corresponding integer
!> indices as a header for an obs_sequence file.

subroutine read_type_of_obs_table(ifile, pre_I_format, fform)

integer,                    intent(in) :: ifile
logical,                    intent(in) :: pre_I_format
character(len=*), intent(in), optional :: fform

character(len=20)  :: header
character(len=obstypelength) :: o_name
integer            :: i, num_def_types, o_index, list_index, rc
logical            :: is_ascii
character(len=*), parameter :: routine = 'read_type_of_obs_table'

if ( .not. module_initialized ) call initialize_module

! pre_I_format has been deprecated.
if(pre_I_format) then
   call error_handler(E_ERR, routine, 'pre_I_format no longer supported', source)
endif

is_ascii = ascii_file_format(fform)

! Read the 20 character identifier which identifies the start
! of the obstype number/name table for this sequence file.
if (is_ascii) then
   read(ifile, *, iostat=rc) header
else
   read(ifile,    iostat=rc) header
endif

if(rc /= 0 .or. (header /= 'obs_type_definitions' .and. header /= 'obs_kind_definitions')) then
   write(msg_string,  *) 'Did not find expected "obs_type_definitions" or "obs_kind_definitions" string at start of obs_seq file '
   write(msg_string1, *) 'Possible causes include: not an obs_seq file format, corrupted file, or wrong-endian binary file'
   call error_handler(E_ERR, routine, msg_string, source, text2=msg_string1)
endif

! Loop through the list to read the integer indices and strings
! For all the defined observation types
! Set up the map from types in the obs_sequence file to those
! in the data structure in this module.
if (is_ascii) then
   read(ifile, *) num_def_types
else
   read(ifile)    num_def_types
endif

do i = 1, num_def_types
   if (is_ascii) then
      read(ifile, *) o_index, o_name
   else
      read(ifile)    o_index, o_name
   endif

   ! What is the integer associated with this o_name in this module?
   list_index = get_index_for_type_of_obs(o_name)

   ! Check for error
   if(list_index == -1) then
      write(msg_string, *) 'Did not find observation type "', o_name, &
         '" in current type list compiled in this program'
      call error_handler(E_ERR, routine, msg_string, source)
   endif

   toc_mod_type_map%toc_type_index(i) = o_index
   toc_mod_type_map%mod_type_index(i) = list_index
end do

end subroutine read_type_of_obs_table

!----------------------------------------------------------------------------
!> Print a menu and read an obs type number
!> (Used for example in an interactive program)

function get_type_of_obs_from_menu()

integer :: get_type_of_obs_from_menu

integer :: i, ierr
character(len=obstypelength) :: in
character(len=*), parameter :: routine = 'get_type_of_obs_from_menu'

if ( .not. module_initialized ) call initialize_module

! Should only do types that have been selected by preprocessor
! since those are being evaluated or assimilated.
21 continue
write(*, *) '     ', 'Input the name of the observation types from table below'
write(*, *) '     ', 'OR input (-1 * state variable index) for identity observations:'
do i = 1, max_defined_types_of_obs
   if(assimilate_this_type_of_obs(i) .or. evaluate_this_type_of_obs(i)) &
      write(*, *) '     ',  obs_type_info(i)%index, trim(obs_type_info(i)%name)
end do

! Read the input as a string, convert to integers as appropriate
read(*, '(A)') in

! If string is a positive or negative number, convert it to integer
read(in, *, IOSTAT = ierr) get_type_of_obs_from_menu
if(ierr /= 0) then
   get_type_of_obs_from_menu = get_index_for_type_of_obs(in)
   ! If string isn't found, need to reprompt
   if(get_type_of_obs_from_menu == -1) then
      write(*, *) trim(in) // ' is not a supported type: Please try again.'
      goto 21
   endif
else
   ! Make sure that number entered isn't 0 or too larg
   if(get_type_of_obs_from_menu == 0 .or. get_type_of_obs_from_menu > max_defined_types_of_obs) then
      write(*, *) get_type_of_obs_from_menu, 'is not a legal entry: Please try again.'
      goto 21
   endif
endif

! Make sure

end function get_type_of_obs_from_menu

!----------------------------------------------------------------------------
!> call this routine only where if an index is expected to be valid. 
!> (it is a fatal error if not.)  don't call this routine from code where 
!> an out-of-range value is handled (e.g. it returns -1 instead).

subroutine validate_obs_type_index(test_me, calling_routine)

integer,          intent(in) :: test_me
character(len=*), intent(in) :: calling_routine

if (test_me < 1 .or. test_me > max_defined_types_of_obs) then
   write(msg_string,'(A,I6,A,I6)') 'obs type number ', test_me, &
                                   ' must be between 1 and ', max_defined_types_of_obs
   call error_handler(E_ERR, calling_routine, msg_string, source)
endif

end subroutine validate_obs_type_index

!----------------------------------------------------------------------------
!> call this routine only where if an index is expected to be valid. 
!> (it is a fatal error if not.)  don't call this routine from code where 
!> an out-of-range value is handled (e.g. it returns -1 instead).

subroutine validate_obs_qty_index(test_me, calling_routine)

integer,          intent(in) :: test_me
character(len=*), intent(in) :: calling_routine

if (test_me < 0 .or. test_me > max_defined_quantities) then
   write(msg_string,'(A,I6,A,I6)') 'obs quantity number ', test_me, &
                                   ' must be between 0 and ', max_defined_quantities
   call error_handler(E_ERR, calling_routine, msg_string, source)
endif

end subroutine validate_obs_qty_index

!----------------------------------------------------------------------------
!> call this routine only where if an index is expected to be valid. 
!> (it is a fatal error if not.)  don't call this routine from code where 
!> an out-of-range value is handled (e.g. it returns -1 instead).

subroutine validate_qty_item_index(qty_index, test_me, calling_routine)
integer,          intent(in) :: qty_index
integer,          intent(in) :: test_me
character(len=*), intent(in) :: calling_routine

integer :: nitems

! test before using index
call validate_obs_qty_index(qty_index, calling_routine)

nitems = obs_qty_info(qty_index)%nitems

if (test_me < 1 .or. test_me > nitems) then
   write(msg_string,'(3(A,I6))') 'item number ', test_me, ' for obs quantity number ', qty_index, &
                                   ' ('//trim(obs_type_info(qty_index)%name)//') must be between 1 and ', nitems
   call error_handler(E_ERR, calling_routine, msg_string, source)
endif

end subroutine validate_qty_item_index

!----------------------------------------------------------------------------

subroutine validate_metadata_strings(obs_qty_ind, itemname, itemvalue)

integer, intent(in) :: obs_qty_ind
character(len=*), intent(in) :: itemname
character(len=*), intent(in) :: itemvalue

character(len=*), parameter :: routine = 'validate_metadata_strings'

if (len_trim(itemname) > namelen) then
  write(msg_string, *) 'quantity ', obs_qty_ind, ' metadata name "'//trim(itemname)//'" must be shorter than', namelen
  write(msg_string1, *) 'quantity ', obs_qty_ind, ' is ', get_name_for_quantity(obs_qty_ind)
  call error_handler(E_ERR, routine, msg_string, source, text2=msg_string1)
endif

if (len_trim(itemvalue) > valuelen) then
  write(msg_string, *) 'quantity ', obs_qty_ind, ' metadata value "'//trim(itemvalue)//'" must be shorter than', valuelen
  write(msg_string1, *) 'quantity ', obs_qty_ind, ' is ', get_name_for_quantity(obs_qty_ind)
  call error_handler(E_ERR, routine, msg_string, source, text2=msg_string1)
endif

end subroutine validate_metadata_strings

!----------------------------------------------------------------------------

end module obs_kind_mod
!end module obs_qty_mod
