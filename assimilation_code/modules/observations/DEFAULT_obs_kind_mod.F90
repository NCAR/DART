! DART software - Copyright UCAR. This open source software is provided
! by UCAR, "as is", without charge, subject to all terms of use at
! http://www.image.ucar.edu/DAReS/DART/DART_download

!----------------------------------------------------------------------
! WARNING!!  The file obs_kind_mod.f90 is AUTOGENERATED by the
! 'preprocess' program.  Any changes made to this file will be
! overwritten when it is regenerated.  To make permanent changes
! in the code, edit DEFAULT_obs_kind_mod.F90, or edit the
! observation specific obs_def_xxx_mod.f90 files.
!----------------------------------------------------------------------

module obs_kind_mod

use        types_mod, only : obstypelength, r8, MISSING_R8
use    utilities_mod, only : register_module, error_handler, E_ERR, E_WARN,  &
                             logfileunit, find_namelist_in_file, log_it,     &
                             check_namelist_read, do_output, ascii_file_format

implicit none
private

public :: get_name_for_type_of_obs,       &
          assimilate_this_type_of_obs,    &
          evaluate_this_type_of_obs,      &
          get_quantity_for_type_of_obs,   &
          get_index_for_type_of_obs,      &
          write_type_of_obs_table,        &
          read_type_of_obs_table,         &
          get_type_of_obs_from_menu,      &
          map_type_of_obs_table,          &
          use_ext_prior_this_type_of_obs, &
          get_name_for_quantity,          &
          get_index_for_quantity,         &
          get_units_for_quantity,         &
          get_bounds_for_quantity

public :: get_num_types_of_obs, get_num_quantities

!----------------------------------------------------------------------------
! These lists are autogenerated by the 'preprocess' program.  
! 
! To add new observation types (e.g. AIRS_U_WIND_COMPONENT), edit the 
! obs_def_xxx_mod.f90 files and add the filename to the 'obs_type_files' variable
! in the &preprocess_nml namelist of the model-specific work/input.nml file.
! There can be multiple filenames listed for 'obs_type_files'.
!
! To add a new fundamental quantity (e.g. TEMPERATURE), first examine
! all the xxx_quantities.f90 files to be sure it does not already exist.  
! If it really does not, add QTY_xxx to the most appropriate file and 
! add xxx_quantities.f90 to the 'quantity_files' variable in the &preprocess_nml 
! namelist.  There can be multiple filenames listed for 'quantity_files'.
!
! Add a descriptive comment along with expected units and any other
! helpful information.  These quantities should be useable by any
! model of the same system to allow interoperability and comparisons
! between model results.
!

! DART PREPROCESS INTEGER DECLARATIONS INSERTED HERE

!----------------------------------------------------------------------------

! version controlled file description for error handling, do not edit
character(len=*), parameter :: source   = 'DEFAULT_obs_def_mod.F90'
character(len=*), parameter :: revision = ''
character(len=*), parameter :: revdate  = ''

! integer, parameters: max_defined_types_of_obs, max_defined_quantities 
! generated and inserted by preprocess.

logical, save :: module_initialized = .false.

character(len=512) :: msg_string, msg_string1

! @todo FIXME: what is the right len for a units string?
integer, parameter :: unitslen = 128

integer :: num_types_assimilate, num_types_evaluate 
integer :: num_types_use_precomputed_FOs

! Map from values of kind in obs_def to the fixed values in the list above.
! Initially, these are undefined and have values -1.
! For the first index 1, the value is the index in the input obs_sequence file.
! The first index 2 is the value of the corresponding index in this kind module.
integer :: map(2, max_defined_types_of_obs) = -1

! An observation kind type links together all the information required.
! An integer index that is also associated with the parameter above,
! A character string that has the same string as the parameter above,
! an integer that indicates what kind of variable type this is (for
! instance a radiosonde u wind component is a u wind component, but so
! is a 10 meter u wind component), and two logicals that indicate
! whether observations of this kind are to be assimilated, evaluated,
! or neither. Name lengths are limited to 32 characters by compiler
! restrictions on the length of parameter identifiers.
type obs_type_type
   integer              :: index
   character(len=obstypelength) :: name
   integer              :: quantity
   logical              :: assimilate
   logical              :: evaluate
   logical              :: use_precomputed_FO
end type obs_type_type

! An obs_type_type is defined by the preprocessor to store the association
! between obs_types, associated integer identifiers, the underlying kind,
! and whether observations of this type should be assimilate or evaluated.
type(obs_type_type) :: obs_type_info(max_defined_types_of_obs)

type obs_qty_type
   integer                      :: index = -1
   character(len=obstypelength) :: name = 'null'
   character(len=unitslen)      :: units = 'none'
   real(r8)                     :: minbound = MISSING_R8
   real(r8)                     :: maxbound = MISSING_R8
end type obs_qty_type

! An obs_qty_name_type is defined by the preprocess program to store
! the association between obs_qty index numbers and string names.
! raw is index 0, so this needs to match.  revisit the direct indexing
! since we have an index in the table -- redundant info?
type(obs_qty_type) :: obs_qty_names(0:max_defined_quantities)

integer, parameter :: MAX_ITEMS = 500

! Namelist array to turn on any requested observation types
character(len=obstypelength) :: assimilate_these_obs_types(MAX_ITEMS) = 'null'
character(len=obstypelength) :: evaluate_these_obs_types(MAX_ITEMS) = 'null'
character(len=obstypelength) :: use_precomputed_FOs_these_obs_types(MAX_ITEMS) = 'null' 


namelist /obs_kind_nml/ assimilate_these_obs_types, evaluate_these_obs_types, &
                        use_precomputed_FOs_these_obs_types

contains

!----------------------------------------------------------------------------

subroutine initialize_module()

integer :: iunit, io, i, j
character(len = 169) :: err_string
character(len=*), parameter :: routine = 'initialize_module'

call register_module(source, revision, revdate)
module_initialized = .true.

! Read the namelist entry
call find_namelist_in_file("input.nml", "obs_kind_nml", iunit)
read(iunit, nml = obs_kind_nml, iostat = io)
call check_namelist_read(iunit, io, "obs_kind_nml")


!----------------------------------------------------------------------------

! These lists are autogenerated by the 'preprocess' program.  
! To add quantities, edit the DEFAULT_obs_kind_mod.F90 file and add them
! in the top section.
! To add types, edit the obs_def_xxx_mod.f90 files and then add them
! to the 'input_files' variable of the &preprocess_nml namelist
! in the model-specific work/input.nml file.

! Tables which associate integer parameter names with a string of the
! same name.  Also tables which associate types of obs with the quantity.

! DART PREPROCESS DERIVED TYPE INITIALIZATIONS INSERTED HERE

!----------------------------------------------------------------------------

! Default for all obs is to not assimilate or evaluate.
! Count up number being assimilated and evaluated here.

num_types_assimilate = 0
do i = 1, max_defined_types_of_obs
   if(assimilate_these_obs_types(i) == 'null' .or. len_trim(assimilate_these_obs_types(i)) == 0 ) exit
   num_types_assimilate = i
end do

num_types_evaluate = 0
do i = 1, max_defined_types_of_obs
   if(evaluate_these_obs_types(i) == 'null' .or. len_trim(evaluate_these_obs_types(i)) == 0) exit
   num_types_evaluate = i
end do

! Special case when all obs_types should use precomputed_FOs
if( any(use_precomputed_FOs_these_obs_types .eq. 'all') ) then
   num_types_use_precomputed_FOs = num_types_assimilate + num_types_evaluate
   j = 1
   if ( num_types_assimilate > 0 ) then
      use_precomputed_FOs_these_obs_types(j:num_types_assimilate) = assimilate_these_obs_types(1:num_types_assimilate)
      j = j + num_types_assimilate
   endif
   if ( num_types_evaluate > 0 ) use_precomputed_FOs_these_obs_types(j:num_types_use_precomputed_FOs) = evaluate_these_obs_types(1:num_types_evaluate)
else
   num_types_use_precomputed_FOs = 0
   do i = 1, max_defined_types_of_obs
      if(use_precomputed_FOs_these_obs_types(i) == 'null' .or.  len_trim(use_precomputed_FOs_these_obs_types(i)) == 0) exit
      num_types_use_precomputed_FOs = i
   end do
endif

if (do_output() .and. (num_types_assimilate > 0 .or. &
                       num_types_evaluate > 0   .or. &
                       num_types_use_precomputed_FOs > 0 )) then  
   call log_it('')
   call log_it('Assimilate_these_obs_types:')
   if (num_types_assimilate < 1) then
         call log_it('   none')
   else
      do i = 1, num_types_assimilate
         call log_it('   '//trim(assimilate_these_obs_types(i)))
      enddo
   endif

   call log_it('Evaluate_these_obs_types:')
   if (num_types_evaluate <1) then
         call log_it('   none')
   else
      do i = 1, num_types_evaluate
         call log_it('   '//trim(evaluate_these_obs_types(i)))
      enddo
   endif

   call log_it('Use the precomputed Prior Forward Operators for these obs types:')
   if (num_types_use_precomputed_FOs <1) then
         call log_it('   none')
   else
      do i = 1, num_types_use_precomputed_FOs
         call log_it('   '//trim(use_precomputed_FOs_these_obs_types(i)))
      enddo
   endif
   call log_it('')
endif


! Figure out which kinds are being used, look for errors
! Start by loading up kinds to assimilate
if (num_types_assimilate > 0) then
   do i = 1, num_types_assimilate
      ! Search for the matching string
      do j = 1, max_defined_types_of_obs
         if(assimilate_these_obs_types(i) == obs_type_info(j)%name) then
            obs_type_info(j)%assimilate = .true.
            goto 44
         endif
      end do
      ! Falling off the end is an error
      write(err_string, *) '"',trim(assimilate_these_obs_types(i)), &
         '" from obs_kind_nml is not a legal observation kind to assimilate'
      call error_handler(E_ERR, routine, err_string, source, revision, revdate)
      44 continue
   end do
endif

! Now look for kinds to evaluate
if (num_types_evaluate > 0) then
   do i = 1, num_types_evaluate
      ! Search for the matching string
      do j = 1, max_defined_types_of_obs
         if(evaluate_these_obs_types(i) == obs_type_info(j)%name) then
            obs_type_info(j)%evaluate = .true.
            goto 55
         endif
      end do
      ! Falling off the end is an error
      write(err_string, *) '"',trim(evaluate_these_obs_types(i)), &
         '" from obs_kind_nml is not a legal observation kind to evaluate'
      call error_handler(E_ERR, routine, err_string, source, revision, revdate)
      55 continue
   end do
endif

if (num_types_use_precomputed_FOs > 0) then
   do i = 1, num_types_use_precomputed_FOs
      ! Search for the matching string
      do j = 1, max_defined_types_of_obs
         if(use_precomputed_FOs_these_obs_types(i) == obs_type_info(j)%name) then
            obs_type_info(j)%use_precomputed_FO = .true.
            goto 66
         endif
      end do
      ! Falling off the end is an error
      write(err_string, *) '"',trim(use_precomputed_FOs_these_obs_types(i)), &
         '" from obs_kind_nml is not a legal observation type'
      call error_handler(E_ERR, routine, err_string, source, revision, revdate)
      66 continue
   end do
endif

! Make it an error to ask to assimilate AND evaluate the same obs kind
do i = 1, max_defined_types_of_obs
   if(obs_type_info(i)%evaluate .and. obs_type_info(i)%assimilate) then
      write(err_string, *) 'Illegal to evaluate and assimilate same kind ', &
         trim(obs_type_info(i)%name)
      call error_handler(E_ERR, routine, err_string, source, revision, revdate)
   endif
end do

end subroutine initialize_module

!---------------------------------------------------------------------------

function map_type_of_obs_table(obs_def_index)

! Argument is the index from the obs_def; needs to be mapped to the appropriate
! Integer storage index
integer, intent(in) :: obs_def_index
integer             :: map_type_of_obs_table

character(len = 169) :: err_string
integer :: i
character(len=*), parameter :: routine = "map_type_of_obs_table"

if ( .not. module_initialized ) call initialize_module

! Need to search through the first map column to find this obs_def_index value
! Then return the index into table in this module from corresponding row in
! second column.
do i = 1, max_defined_types_of_obs
   if(map(1, i) == obs_def_index) then
      map_type_of_obs_table = map(2, i)
      return
   endif
end do

! Error, didn't find this obs_def_index in the map
write(err_string, *) 'Could not find obs_def_index ', obs_def_index, &
   ' in obs_kind map'
call error_handler(E_ERR, routine, err_string, source, revision, revdate)

end function map_type_of_obs_table

!----------------------------------------------------------------------------

function get_name_for_type_of_obs(obs_type_ind)

! Returns observation type name

integer, intent(in) :: obs_type_ind
character(len=obstypelength) :: get_name_for_type_of_obs
character(len=*), parameter :: routine = 'get_name_for_type_of_obs'

if ( .not. module_initialized ) call initialize_module

call validate_obs_type_index(obs_type_ind, routine)

get_name_for_type_of_obs = obs_type_info(obs_type_ind)%name

end function get_name_for_type_of_obs

!----------------------------------------------------------------------------
! Added by TRW to handle matching RAW variable types to their strings
! as well as the derived types - this will make the restart file
! handling more readable.

function get_name_for_quantity(obs_qty_ind)

! Returns observation kind name

integer, intent(in) :: obs_qty_ind
character(len=obstypelength) :: get_name_for_quantity

character(len=*), parameter :: routine = 'get_name_for_quantity'

if (.not. module_initialized) call initialize_module

call validate_obs_qty_index(obs_qty_ind, routine)

get_name_for_quantity = obs_qty_names(obs_qty_ind)%name

end function get_name_for_quantity
!----------------------------------------------------------------------------

function get_index_for_type_of_obs(obs_type_name)

! Returns the integer index corresponding to an observation type string name
! Returns a -1 if this string is not in list

character(len = *), intent(in)  :: obs_type_name
integer                         :: get_index_for_type_of_obs

integer :: i
character(len=*), parameter :: routine = 'get_index_for_type_of_obs'

if ( .not. module_initialized ) call initialize_module

!>@todo FIXME binary search on a sorted list?

do i = 1, max_defined_types_of_obs
   if(obs_type_name == obs_type_info(i)%name) then
      get_index_for_type_of_obs = i
      return
   endif
end do

get_index_for_type_of_obs = -1

end function get_index_for_type_of_obs

!----------------------------------------------------------------------------
! Added by TRW to handle matching RAW variable types to their strings
! as well as the derived types - this will make the restart file
! handling more readable.

function get_index_for_quantity(obs_qty_name)

! Returns the integer index corresponding to an observation kind string name
! Returns a -1 if this string is not in list

character(len=*), intent(in)  :: obs_qty_name
integer                       :: get_index_for_quantity

integer :: i
character(len=*), parameter :: routine = 'get_index_for_quantity'

if (.not. module_initialized) call initialize_module

do i = 0, max_defined_quantities
   if(obs_qty_name == obs_qty_names(i)%name) then
      get_index_for_quantity = i
      return
   end if
end do

get_index_for_quantity = -1

end function get_index_for_quantity

!----------------------------------------------------------------------------
! Get units string for quantity by index

function get_units_for_quantity(obs_qty_ind)

! Returns the units string for this quantity index
! Returns 'null' if index out of range

integer, intent(in) :: obs_qty_ind
character(len=128)  :: get_units_for_quantity

character(len=*), parameter :: routine = 'get_units_for_quantity'

if (.not. module_initialized) call initialize_module

call validate_obs_qty_index(obs_qty_ind, routine)

get_units_for_quantity = obs_qty_names(obs_qty_ind)%units

end function get_units_for_quantity

!----------------------------------------------------------------------------
! Get bounds values for quantity by index
! Returns .false. for 'hasbounds' if both min and max are missing_r8
! (hopefully a shortcut for calling code to skip additional tests.)

subroutine get_bounds_for_quantity(obs_qty_ind, hasbounds, minbounds, maxbounds)

! Returns the min/max bounds, if any, for this quantity index
! Returns MISSING_R8 if no bounds

integer,  intent(in)  :: obs_qty_ind
logical,  intent(out) :: hasbounds
real(r8), intent(out) :: minbounds
real(r8), intent(out) :: maxbounds

character(len=*), parameter :: routine = 'get_bounds_for_quantity'

if (.not. module_initialized) call initialize_module

call validate_obs_qty_index(obs_qty_ind, routine)

minbounds = obs_qty_names(obs_qty_ind)%minbound
maxbounds = obs_qty_names(obs_qty_ind)%maxbound

hasbounds = .not. (minbounds == MISSING_R8 .and. maxbounds == MISSING_R8)

end subroutine get_bounds_for_quantity

!----------------------------------------------------------------------------
!> Accessor function to return observation type count

function get_num_types_of_obs()

integer :: get_num_types_of_obs

if ( .not. module_initialized ) call initialize_module

get_num_types_of_obs = max_defined_types_of_obs

end function get_num_types_of_obs

!----------------------------------------------------------------------------
!> Accessor function to return observation quantity

function get_num_quantities()

integer :: get_num_quantities

if (.not. module_initialized) call initialize_module

get_num_quantities = max_defined_quantities

end function get_num_quantities

!----------------------------------------------------------------------------
!> Returns true if this obs_type is being assimilated

function assimilate_this_type_of_obs(obs_type_ind)

logical             :: assimilate_this_type_of_obs
integer, intent(in) :: obs_type_ind

character(len=*), parameter :: routine = 'assimilate_this_type_of_obs'

if ( .not. module_initialized ) call initialize_module

call validate_obs_type_index(obs_type_ind, routine)

assimilate_this_type_of_obs = obs_type_info(obs_type_ind)%assimilate

end function assimilate_this_type_of_obs

!----------------------------------------------------------------------------
!> Returns true if this obs_type is being assimilated

function evaluate_this_type_of_obs(obs_type_ind)

logical             :: evaluate_this_type_of_obs
integer, intent(in) :: obs_type_ind

character(len=*), parameter :: routine = 'evaluate_this_type_of_obs'

if ( .not. module_initialized ) call initialize_module

call validate_obs_type_index(obs_type_ind, routine)

evaluate_this_type_of_obs = obs_type_info(obs_type_ind)%evaluate

end function evaluate_this_type_of_obs

!----------------------------------------------------------------------------
!> Returns true if this obs_type should use externally computed priors

function use_ext_prior_this_type_of_obs(obs_type_ind)

logical             :: use_ext_prior_this_type_of_obs
integer, intent(in) :: obs_type_ind

character(len=*), parameter :: routine = 'use_ext_prior_this_type_of_obs'

if ( .not. module_initialized ) call initialize_module

call validate_obs_type_index(obs_type_ind, routine)

use_ext_prior_this_type_of_obs = obs_type_info(obs_type_ind)%use_precomputed_FO

end function use_ext_prior_this_type_of_obs

!----------------------------------------------------------------------------

function get_quantity_for_type_of_obs(obs_type_ind)

! Returns the associated generic kind associated with the
! specific type of this observation

integer, intent(in) :: obs_type_ind
integer             :: get_quantity_for_type_of_obs

character(len=*), parameter :: routine = 'get_quantity_for_type_of_obs'

if ( .not. module_initialized ) call initialize_module

call validate_obs_type_index(obs_type_ind, routine)

get_quantity_for_type_of_obs = obs_type_info(obs_type_ind)%quantity

end function get_quantity_for_type_of_obs

!----------------------------------------------------------------------------

subroutine write_type_of_obs_table(ifile, fform, use_list)

! Writes out the observation kind strings and corresponding integer
! indices as a header for an obs_sequence file.

integer, intent(in)                    :: ifile
character(len=*), intent(in), optional :: fform
integer,          intent(in), optional :: use_list(:)

integer :: i, ntypes
logical :: is_ascii, restrict
character(len=*), parameter :: routine = 'write_type_of_obs_table'

if ( .not. module_initialized ) call initialize_module

is_ascii = ascii_file_format(fform)

! Write the 20 character identifier to indicate the start of a kind table.
! To maintain complete backwards compatibility with the original read
! code this string must start in column 1.
! you cannot use: write(ifile, *) 'string'  because the output string
! will start in col 2.  the string either has to be part of the format
! argument to write(), or you have to use a separate format statement.
if (is_ascii) then
   write(ifile,  "('obs_kind_definitions')")   ! see note above!
else
   write(ifile)    'obs_kind_definitions'
endif

! If this routine is called with a list of which types are actually
! being used, restrict the table of contents to only those.
! Otherwise, write all known types.
if (present(use_list)) then
   ! make sure the list is the right length
   if (size(use_list) /= max_defined_types_of_obs) then
      call error_handler(E_ERR, routine, 'use_list(:) must be the same length as number of types', &
                         source, revision, revdate)
   endif

   ntypes = count(use_list(:) > 0)
   restrict = .true.
else
   ntypes = max_defined_types_of_obs
   restrict = .false.
endif

if (is_ascii) then
   write(ifile, *) ntypes
else
   write(ifile)    ntypes
endif

do i = 1, max_defined_types_of_obs
   if (restrict) then
       if (use_list(i) == 0) cycle
   endif

   if (is_ascii) then
      write(ifile, *) obs_type_info(i)%index, obs_type_info(i)%name
   else
      write(ifile)    obs_type_info(i)%index, obs_type_info(i)%name
   endif
end do

end subroutine write_type_of_obs_table

!----------------------------------------------------------------------------


subroutine read_type_of_obs_table(ifile, pre_I_format, fform)

! Reads the observation kind strings and corresponding integer
! indices as a header for an obs_sequence file.

integer,                    intent(in) :: ifile
logical,                    intent(in) :: pre_I_format
character(len=*), intent(in), optional :: fform

character(len=20)  :: header
character(len=obstypelength) :: o_name
integer            :: i, num_def_types, o_index, list_index, rc
logical            :: is_ascii
character(len=*), parameter :: routine = 'read_type_of_obs_table'

if ( .not. module_initialized ) call initialize_module

! pre_I_format has been deprecated.
if(pre_I_format) then
   call error_handler(E_ERR, routine, 'pre_I_format no longer supported', &
                      source, revision, revdate)
endif

is_ascii = ascii_file_format(fform)

! Read the 20 character identifier which identifies the start
! of the obstype number/name table for this sequence file.
if (is_ascii) then
   read(ifile, *, iostat=rc) header
else
   read(ifile,    iostat=rc) header
endif

if(rc /= 0 .or. header /= 'obs_kind_definitions') then
   write(msg_string,  *) 'Did not find expected "obs_kind_definitions" string at start of obs_seq file '
   write(msg_string1, *) 'Bad file format, corrupted file, or wrong-endian binary file'
   call error_handler(E_ERR, routine, msg_string, source, revision, revdate, text2=msg_string1)
endif

! Loop through the list to read the integer indices and strings
! For all the defined observation types
! Set up the map from kinds in the obs_sequence file to those
! in the data structure in this module.
if (is_ascii) then
   read(ifile, *) num_def_types
else
   read(ifile)    num_def_types
endif

do i = 1, num_def_types
   if (is_ascii) then
      read(ifile, *) o_index, o_name
   else
      read(ifile)    o_index, o_name
   endif

   ! What is the integer associated with this o_name in this module?
   list_index = get_index_for_type_of_obs(o_name)
   ! Check for error
   if(list_index == -1) then
      write(msg_string, *) 'Did not find observation type "', o_name, &
         '" in obs_qty_mod list'
      call error_handler(E_ERR, routine, msg_string, source, revision, revdate)
   endif
   map(1, i) = o_index
   map(2, i) = list_index
end do

end subroutine read_type_of_obs_table

!----------------------------------------------------------------------------

function get_type_of_obs_from_menu()

integer :: get_type_of_obs_from_menu

integer :: i, ierr
character(len=obstypelength) :: in
character(len=*), parameter :: routine = 'get_type_of_obs_from_menu'

if ( .not. module_initialized ) call initialize_module

! Should only do kinds that have been selected by preprocessor, so those
! are ones that are being evaluated or assimilated.
21 continue
write(*, *) '     ', 'Input -1 * state variable index for identity observations'
write(*, *) '     ', 'OR input the name of the observation kind from table below:'
write(*, *) '     ', 'OR input the integer index, BUT see documentation...'
do i = 1, max_defined_types_of_obs
   if(assimilate_this_type_of_obs(i) .or. evaluate_this_type_of_obs(i)) &
      write(*, *) '     ',  obs_type_info(i)%index, trim(obs_type_info(i)%name)
end do

! Read the input as a string, convert to integers as appropriate
read(*, '(A)') in

! If string is a positive or negative number, convert it to integer
read(in, *, IOSTAT = ierr) get_type_of_obs_from_menu
if(ierr /= 0) then
   get_type_of_obs_from_menu = get_index_for_type_of_obs(in)
   ! If string isn't found, need to reprompt
   if(get_type_of_obs_from_menu == -1) then
      write(*, *) trim(in) // ' is not a supported kind: Please try again.'
      goto 21
   endif
else
   ! Make sure that number entered isn't 0 or too larg
   if(get_type_of_obs_from_menu == 0 .or. get_type_of_obs_from_menu > max_defined_types_of_obs) then
      write(*, *) get_type_of_obs_from_menu, 'is not a legal entry: Please try again.'
      goto 21
   endif
endif

! Make sure

end function get_type_of_obs_from_menu

!----------------------------------------------------------------------------

subroutine validate_obs_type_index(test_me, calling_routine)

integer,          intent(in) :: test_me
character(len=*), intent(in) :: calling_routine

if (test_me < 1 .or. test_me > max_defined_types_of_obs) then
   write(msg_string,'(A,I6,A,I6)') 'obs type number ', test_me, &
                                   ' must be between 1 and ', max_defined_types_of_obs
   call error_handler(E_ERR, calling_routine, msg_string, source, revision, revdate)
endif

end subroutine validate_obs_type_index

!----------------------------------------------------------------------------

subroutine validate_obs_qty_index(test_me, calling_routine)

integer,          intent(in) :: test_me
character(len=*), intent(in) :: calling_routine

if (test_me < 0 .or. test_me > max_defined_quantities) then
   write(msg_string,'(A,I6,A,I6)') 'obs quantity number ', test_me, &
                                   ' must be between 0 and ', max_defined_quantities
   call error_handler(E_ERR, calling_routine, msg_string, source, revision, revdate)
endif

end subroutine validate_obs_qty_index

!----------------------------------------------------------------------------

end module obs_kind_mod

