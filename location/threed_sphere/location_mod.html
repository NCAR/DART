<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
          "http://www.w3.org/TR/html4/strict.dtd">
<HTML>
<HEAD>
<TITLE>module location_mod</TITLE>
<link rel="stylesheet" type="text/css" href="../../doc/html/doc.css">
</HEAD>
<BODY>
<A NAME="TOP"></A>

<center>
<A HREF="#Interface">INTERFACES</A> /
<A HREF="#Namelist">NAMELIST</A> /
<A HREF="#FilesUsed">FILES</A> /
<A HREF="#References">REFERENCES</A> /
<A HREF="#Errors">ERRORS</A> /
<A HREF="#FuturePlans">PLANS</A> /
<A HREF="#PrivateComponents">PRIVATE COMPONENTS</A> /
<A HREF="#Legalese">TERMS OF USE</A>
</center>

<H1>MODULE location_mod (threed_sphere)</H1>
<!-- version tag follows, do not edit --><P>$Id$</P>

<P>
   Provides a representation of a physical location on a 3-D spherical
   shell. A type that abstracts the location is provided along
   with operators to compute the distance between two locations. This is
   a member of a class of similar location modules that provide the same 
   abstraction for different represenations of physical space (for instance
   a one-dimensional periodic domain for low-order modules).
</P>

<!--==================================================================-->

<A NAME="OtherModulesUsed"></A>
<HR>
<H2>OTHER MODULES USED</H2>
<PRE>
types_mod
utilities_mod
random_seq_mod
</PRE>

<!--==================================================================-->
<!-- Declare all public entities ...                                  -->
<!-- duplicate public routines template as many times as necessary    -->
<!-- make sure you replace all yyyroutine?? strings                   -->
<!--==================================================================-->
<!--Note to authors. The first row of the table is different.         -->
<!--==================================================================-->

<A NAME="Interface"></A>
<HR>
<H2>PUBLIC INTERFACES</H2>

<TABLE>
<TR><TD><em class=code>use location_mod, only : </em></TD>
                   <TD><A HREF="#location_type">location_type</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_dist">get_dist</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_location">get_location</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#set_location">set_location</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#write_location">write_location</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#read_location">read_location</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#interactive_location">interactive_location</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#set_location_missing">set_location_missing</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#vert_is_undef">vert_is_undef</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#vert_is_surface">vert_is_surface</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#vert_is_pressure">vert_is_pressure</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#vert_is_level">vert_is_level</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#vert_is_height">vert_is_height</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#query_location">query_location</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#LocationDims">LocationDims</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#LocationName">LocationName</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#LocationLName">LocationLName</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#horiz_dist_only">horiz_dist_only</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_close_obs">get_close_obs</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_close_type">get_close_type</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_close_maxdist_init">get_close_maxdist_init</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_close_obs_init">get_close_obs_init</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#vert_constants">VERTISUNDEF</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#vert_constants">VERTISSURFACE</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#vert_constants">VERTISLEVEL</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#vert_constants">VERTISPRESSURE</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#vert_constants">VERTISHEIGHT</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#equal">operator(==)</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#not_equal">operator(/=)</A></TD></TR>
</TABLE>

<P>
Optional namelist interface
<A HREF="#Namelist"><em class=code>&amp;location_nml</em> </A>
may be read from file <em class=file>input.nml</em>.
</P>

<P>
   A note about documentation style. 
   Optional arguments are enclosed in brackets 
   <em class=optionalcode>[like this]</em>.
</P>

<!--===================== DESCRIPTION OF A LOCAL TYPE =====================-->

<A NAME="location_type"></A>
<br>
<div class=type><pre>
type location_type
   private
   real(r8) :: lon, lat, vloc
   integer  :: which_vert
end type location_type
</pre></div>

<div class=indent1>
<!-- Description -->

<P>Provides an abstract representation of physical location on a 
three-d spherical shell.
</P>

<TABLE border=0 cellpadding=3 width=100%>
<TR><TH align=left>Component   </TH>
    <TH align=left>Description </TH></TR>
<TR><TD valign=top> lon        </TD>
    <TD>longitude in radians   </TD></TR>
<TR><TD valign=top> lat        </TD>
    <TD>latitude in radians    </TD></TR>
<TR><TD valign=top> vloc       </TD>
    <TD>vertical location, units as selected by which_vert</TD></TR>
<TR><TD valign=top> which_vert </TD>
    <TD>type of vertical location: -2=no vert location; -1=surface; 
        1=level; 2=pressure; 3=height</TD></TR>
</TABLE>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="get_location"></A>
<br>
<div class=routine>
<em class=call> var = get_location(loc) </em>
<pre>
real(r8), dimension(3), intent(inout) :: <em class=code>get_location</em>
type(location_type), intent(in)       :: <em class=code>loc</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Extracts the longitude and latitude (converted to degrees) and the vertical
location from a location type and returns in a 3 element real array.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>
<TR><TD valign=top><em class=code>get_location&nbsp;&nbsp;</em></TD>
    <TD>The longitude and latitude (in degrees) and vertical location</TD></TR>
<TR><TD valign=top><em class=code>loc&nbsp;&nbsp;</em></TD>
    <TD>A location type</TD></TR>
</TABLE>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="set_location"></A>
<br>
<div class=routine>
<em class=call> var = set_location(lon, lat, vert_loc, which_vert) </em>
<pre>
type(location_type)     :: <em class=code>set_location</em>
real(r8), intent(in)    :: <em class=code>lon</em>
real(r8), intent(in)    :: <em class=code>lat</em>
real(r8), intent(in)    :: <em class=code>vert_loc</em>
integer, intent(in)     :: <em class=code>which_vert</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Returns a location type with the input longitude and latitude (input
in degrees) and the vertical location of type specified by which_vert.
</P>
<TABLE width=100% border=0 summary="" cellpadding=3>
<TR><TD valign=top><em class=code>set_location&nbsp;&nbsp;</em></TD>
    <TD>A location type</TD></TR>
<TR><TD valign=top><em class=code>lon&nbsp;&nbsp;</em></TD>
    <TD>Longitude in degrees</TD></TR>
<TR><TD valign=top><em class=code>lat&nbsp;&nbsp;</em></TD>
    <TD>Latitude in degrees</TD></TR>
<TR><TD valign=top><em class=code>vert_loc&nbsp;&nbsp;</em></TD>
    <TD>Vertical location consistent with which_vert</TD></TR>
<TR><TD valign=top><em class=code>which_vert&nbsp;&nbsp;</em></TD>
    <TD>The vertical location type</TD></TR>
</TABLE>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="write_location"></A>
<br>
<div class=routine>
<em class=call>call write_location(file, loc
     <em class=optionalcode>[,fform]</em>) </em>
<pre>
integer,               intent(in)      :: <em class=code> file </em>
type(location_type),   intent(in)      :: <em class=code> loc </em>
character(len=*), optional, intent(in) :: <em class=optionalcode> fform </em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
   Given an integer IO channel of an open file and a location, writes the
   location to this file. The fform argument controls whether write is "FORMATTED"
   or "UNFORMATTED" with default being formatted.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>
<TR><TD valign=top><em class=code>file</em></TD>
    <TD>the unit number of the open file.</TD></TR>
<TR><TD valign=top><em class=code>loc</em></TD>
    <TD>location type to be written. </TD></TR>
<TR><TD valign=top><em class=optionalcode>fform</em></TD>
    <TD>Format specifier (FORMATTED or UNFORMATTED). </TD></TR>
</TABLE>

<P>
   Eventually, a more general file descriptor type 
   should replace the use of the integer unit number.
</P>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="get_dist"></A>
<br>
<div class=routine>
<em class=call> var = get_dist( loc1, loc2, kind1, kind2, no_vert)</em>
<pre>
real(r8)                            :: <em class=code> get_dist </em>
type(location_type),     intent(in) :: <em class=code> loc1, loc2 </em>
integer, optional,       intent(in) :: <em class=optionalcode> kind1, kind2 </em>
logical, optional                   :: <em class=optionalcode> no_vert </em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Returns the distance between two locations. If horiz_only is set to true
just computes great circle distance on sphere. If horiz_only is false, then
computes an ellipsoidal distance with the horizontal component as above and
the vertical distance determined by the types of the locations and the 
normalization constants set by the namelist for the different vertical 
coordinate types. The vertical normalization gives the vertical distance
that is equally weighted as a horizontal distance of 1 radian. If no_vert
is present, it overrides the value in the namelist and controls whether
vertical distance is included or not.
<br><br>
The kind arguments are not used by the default location code, but
are available to any user-supplied distance routines which want to
do specialized calculations based on the types associated with each
of the two locations.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>loc1 &nbsp;&nbsp;</em></TD>
    <TD>first location.</TD></TR>

<TR><TD valign=top><em class=code>loc2</em></TD>
    <TD>second location.</TD></TR>

<TR><TD valign=top><em class=code>kind1</em></TD>
    <TD>DART kind associated with the first location.</TD></TR>

<TR><TD valign=top><em class=code>kind2</em></TD>
    <TD>DART kind associated with the second location.</TD></TR>

<TR><TD valign=top><em class=code>no_vert</em></TD>
    <TD>If true, no vertical component to distance. If false, vertical
         component is included.</TD></TR>

<TR><TD valign=top><em class=code>var</em></TD>
    <TD>distance between loc1 and loc2.</TD></TR>

</TABLE>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<!--kdr ifile is locfile in ../oned/location_mod.* -->

<A NAME="read_location"></A>
<br>
<div class=routine>
<em class=call> var = read_location(ifile
<em class=optionalcode>[,fform]</em>) </em>
<pre>
type(location_type)                    :: <em class=code>read_location</em>
integer, intent(in)                    :: <em class=code>ifile</em>
character(len=*), optional, intent(in) :: <em class=optionalcode>fform</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Reads a location_type from a file open on channel ifile using format
fform (default is formatted).
</P>
<TABLE width=100% border=0 summary="" cellpadding=3>
<TR><TD valign=top><em class=code>read_location&nbsp;&nbsp;</em></TD>
    <TD>Returned location type read from file</TD></TR>
<TR><TD valign=top><em class=code>ifile&nbsp;&nbsp;</em></TD>
    <TD>Integer channel opened to a file to be read</TD></TR>
<TR><TD valign=top><em class=optionalcode>fform&nbsp;&nbsp;</em></TD>
    <TD>Optional format specifier (FORMATTED or UNFORMATTED)</TD></TR>
</TABLE>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="interactive_location"></A>
<br>
<div class=routine>
<em class=call> call interactive_location(location
<em class=optionalcode>[,set_to_default]</em>) </em>
<pre>
type(location_type), intent(out) :: <em class=code>location</em>
logical, optional, intent(in)    :: <em class=optionalcode>set_to_default</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Use standard input to define a location type. With set_to_default true 
get one with all elements set to 0.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>
<TR><TD valign=top><em class=code>location&nbsp;&nbsp;</em></TD>
    <TD>Location created from standard input</TD></TR>
<TR><TD valign=top><em class=optionalcode>set_to_default&nbsp;&nbsp;</em></TD>
    <TD>If true, sets all elments of location type to 0</TD></TR>
</TABLE>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="set_location_missing"></A>
<br>
<div class=routine>
<em class=call> var = set_location_missing() </em>
<pre>
type(location_type), intent(in) :: <em class=code>set_location_missing</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Returns a location with all elements set to missing values defined in 
types module. 
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>
<TR><TD valign=top><em class=code>set_location_missing&nbsp;&nbsp;</em></TD>
    <TD>A location with all elements set to missing values</TD></TR>
</TABLE>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="vert_is_undef"></A>
<br>
<div class=routine>
<em class=call> var = vert_is_undef(loc) </em>
<pre>
logical                         :: <em class=code>vert_is_undef</em>
type(location_type), intent(in) :: <em class=code>loc</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Returns true if which_vert has no vertical location (undefined), else false.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>
<TR><TD valign=top><em class=code>vert_is_undef&nbsp;&nbsp;</em></TD>
    <TD>Returns true if vertical coordinate is not applicable.</TD></TR>
<TR><TD valign=top><em class=code>loc&nbsp;&nbsp;</em></TD>
    <TD>A location type</TD></TR>
</TABLE>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="vert_is_surface"></A>
<br>
<div class=routine>
<em class=call> var = vert_is_surface(loc) </em>
<pre>
logical                         :: <em class=code>vert_is_surface</em>
type(location_type), intent(in) :: <em class=code>loc</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Returns true if which_vert is for surface, else false.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>
<TR><TD valign=top><em class=code>vert_is_surface&nbsp;&nbsp;</em></TD>
    <TD>Returns true if vertical coordinate type is surface</TD></TR>
<TR><TD valign=top><em class=code>loc&nbsp;&nbsp;</em></TD>
    <TD>A location type</TD></TR>
</TABLE>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="vert_is_pressure"></A>
<br>
<div class=routine>
<em class=call> var = vert_is_pressure(loc) </em>
<pre>
logical                         :: <em class=code>vert_is_pressure</em>
type(location_type), intent(in) :: <em class=code>loc</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Returns true if which_vert is for pressure, else false.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>
<TR><TD valign=top><em class=code>vert_is_pressure&nbsp;&nbsp;</em></TD>
    <TD>Returns true if vertical coordinate type is pressure</TD></TR>
<TR><TD valign=top><em class=code>loc&nbsp;&nbsp;</em></TD>
    <TD>A location type</TD></TR>
</TABLE>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="vert_is_level"></A>
<br>
<div class=routine>
<em class=call> var = vert_is_level(loc) </em>
<pre>
logical                         :: <em class=code>vert_is_level</em>
type(location_type), intent(in) :: <em class=code>loc</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Returns true if which_vert is for level, else false.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>
<TR><TD valign=top><em class=code>vert_is_level&nbsp;&nbsp;</em></TD>
    <TD>Returns true if vertical coordinate type is level</TD></TR>
<TR><TD valign=top><em class=code>loc&nbsp;&nbsp;</em></TD>
    <TD>A location type</TD></TR>
</TABLE>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="vert_is_height"></A>
<br>
<div class=routine>
<em class=call> var = vert_is_height(loc) </em>
<pre>
logical                         :: <em class=code>vert_is_height</em>
type(location_type), intent(in) :: <em class=code>loc</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Returns true if which_vert is for height, else false.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>
<TR><TD valign=top><em class=code>vert_is_height&nbsp;&nbsp;</em></TD>
    <TD>Returns true if vertical coordinate type is height</TD></TR>
<TR><TD valign=top><em class=code>loc&nbsp;&nbsp;</em></TD>
    <TD>A location type</TD></TR>
</TABLE>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="query_location"></A>
<br>
<div class=routine>
<em class=call> var = query_location(loc
<em class=optionalcode>[,attr]</em>) </em>
<pre>
real(r8), intent(out)                  :: <em class=code>query_location</em>
type(location_type), intent(in)        :: <em class=code>loc</em>
character(len=*), optional, intent(in) :: <em class=optionalcode>attr</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Returns the value of which_vert, latitude, longitude, or vertical location from
a location type as selected by the string argument attr. If attr is not present
or if it is 'WHICH_VERT', the value of which_vert is converted to real and 
returned. Otherwise, attr='LON' returns longitude, attr='LAT' returns latitude
and attr='VLOC' returns the vertical location. 
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>
<TR><TD valign=top><em class=code>query_location&nbsp;&nbsp;</em></TD>
    <TD>Returns longitude, latitude, vertical location, or which_vert 
        (converted to real)</TD></TR>
<TR><TD valign=top><em class=code>loc&nbsp;&nbsp;</em></TD>
    <TD>A location type</TD></TR>
<TR><TD valign=top><em class=optionalcode>attr&nbsp;&nbsp;</em></TD>
    <TD>Selects 'WHICH_VERT', 'LON', 'LAT' or 'VLOC'</TD></TR>
</TABLE>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="equal"></A>
<br>
<div class=routine>
<em class=call> loc1 == loc2</em>
<pre>
type(location_type), intent(in) :: <em class=code>loc1, loc2</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
 Returns true if the two location types have identical values, 
 else false.
</P>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="not_equal"></A>
<br>
<div class=routine>
<em class=call>loc1 /= loc2</em>
<pre>
type(location_type), intent(in) :: <em class=code>loc1, loc2</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
 Returns true if the two location types 
 do NOT have identical values, else false.
</P>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="get_close_obs_init"></A>
<br>
<div class=routine>
<em class=call> call get_close_obs_init(gc, num, obs)</em>
<pre>
type(get_close_type),             intent(inout) :: <em class=code>gc</em>
integer,                          intent(in)    :: <em class=code>num</em>
type(location_type), dimension(:) intent(in)    :: <em class=code>obs</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Initialize storage for efficient identification of locations close
to a given location. Allocates storage for keeping track of which 'box'
each observation in the list is in.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>
<TR><TD valign=top><em class=code>gc&nbsp;&nbsp;</em></TD>
    <TD>Structure that contains data to efficiently find locations 
        close to a given location.</TD></TR>
<TR><TD valign=top><em class=code>num&nbsp;&nbsp;</em></TD>
    <TD>The number of locations in the list.</TD></TR>
<TR><TD valign=top><em class=code>obs&nbsp;&nbsp;</em></TD>
    <TD>The locations of each element in the list, 
        not used in 1D implementation.</TD></TR>
</TABLE>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="get_close_obs"></A>
<br>
<div class=routine>
<em class=call>call get_close_obs(gc, base_obs_loc, base_obs_kind, obs, 
     obs_kind, num_close, close_ind, dist) </em>
<pre>
type(get_close_type),              intent(in)  :: <em class=code>gc</em>
type(location_type),               intent(in)  :: <em class=code>base_obs_loc</em>
integer,                           intent(in)  :: <em class=code>base_obs_kind</em>
type(location_type), dimension(:), intent(in)  :: <em class=code>obs</em>
integer, dimension(:),             intent(in)  :: <em class=code>obs_kind</em>
integer,                           intent(out) :: <em class=code>num_close</em>
integer,  dimension(:),            intent(out) :: <em class=code>close_ind</em>
real(r8), dimension(:),            intent(out) :: <em class=code>dist</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Given a single location and a list of other locations, returns the indices
of all the locations close to the single one along with the number of
these and the distances for the close ones.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>
<TR><TD valign=top><em class=code>gc&nbsp;&nbsp;</em></TD>
    <TD>Structure to allow efficient identification of 
        locations close to a given location.</TD></TR>
<TR><TD valign=top><em class=code>base_obs_loc&nbsp;&nbsp;</em></TD>
    <TD>Single given location.</TD></TR>
<TR><TD valign=top><em class=code>base_obs_kind&nbsp;&nbsp;</em></TD>
    <TD>Kind of the single location.</TD></TR>
<TR><TD valign=top><em class=code>obs&nbsp;&nbsp;</em></TD>
    <TD>List of observations from which close ones are to be found.</TD></TR>
<TR><TD valign=top><em class=code>obs_kind&nbsp;&nbsp;</em></TD>
    <TD>Kind associated with observations in obs list.</TD></TR>
<TR><TD valign=top><em class=code>num_close&nbsp;&nbsp;</em></TD>
    <TD>Number of observations close to the given location.</TD></TR>
<TR><TD valign=top><em class=code>close_ind&nbsp;&nbsp;</em></TD>
    <TD>Indices of those locations that are close.</TD></TR>
<TR><TD valign=top><em class=code>dist&nbsp;&nbsp;</em></TD>
    <TD>Distance between given location and the 
        close ones identified in close_ind.</TD></TR>
</TABLE>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="get_close_maxdist_init"></A>
<br>
<div class=routine>
<em class=call> call get_close_maxdist_init(gc,maxdist) </em>
<pre>
type(get_close_type), intent(inout) :: <em class=code>gc</em>
real(r8), intent(in)                :: <em class=code>maxdist</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Sets the threshhold distance. 
Anything closer that this is deemed to be close.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>
<TR><TD valign=top><em class=code>gc&nbsp;&nbsp;</em></TD>
    <TD>Data for efficiently finding close locations.</TD></TR>
<TR><TD valign=top><em class=code>maxdist&nbsp;&nbsp;</em></TD>
    <TD>Anything closer than this distance is a close location.</TD></TR>
</TABLE>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="get_close_type"></A>
<br>
<div class=type>
<pre>
type get_close_type
   private
   integer  :: num
   real(r8) :: maxdist
   integer, pointer :: lon_offset(:, :)
   integer, pointer :: obs_box(:)
   integer, pointer :: count(:, :)
   integer, pointer :: start(:, :)
end type get_close_type
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Provides a structure for doing efficient computation of close locations.
Doesn't do anything in the 1D implementation except provide appropriate
stubs.
</P>

<TABLE border=0 cellpadding=3 width=100%>
<TR><TH align=left>Component   </TH>
    <TH align=left>Description </TH></TR>
<TR><TD valign=top> num            </TD>
    <TD>Number of observations in list</TD></TR>
<TR><TD valign=top> maxdist            </TD>
    <TD>Threshhold distance. Anything closer is close.</TD></TR>
<TR><TD valign=top> lon_offset</TD>
    <TD>Dimensioned nlon by nlat. For a given offset in longitude boxes and difference
        in latitudes, gives max distance from base box to a point in offset box.</TD></TR>
<TR><TD valign=top> obs_box</TD>
    <TD>Dimensioned num. Gives index of what box each observation is in.</TD></TR>
<TR><TD valign=top> count </TD>
    <TD>Dimensioned nlon by nlat. Number of obs in each box.</TD></TR>
<TR><TD valign=top> start </TD>
    <TD>Dimensioned nlon by nlat. Index in straight storage list 
        where obs in each box start.</TD></TR>
</TABLE>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="vert_constants"></A>
<br>
<div class=routine>
<pre>
<em class=call>integer, parameter :: VERTISUNDEF    = -2</em>
<em class=call>integer, parameter :: VERTISSURFACE  = -1</em>
<em class=call>integer, parameter :: VERTISLEVEL    =  1</em>
<em class=call>integer, parameter :: VERTISPRESSURE =  2</em>
<em class=call>integer, parameter :: VERTISHEIGHT   =  3</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Constant parameters used to differentiate vertical types.
</P>

</div>
<br>

<!--=============== DESCRIPTION OF A PUBLIC CONSTANT =================-->

<A NAME="LocationDims"></A>
<br>
<div class=routine>
<pre>
<em class=call>integer, parameter :: LocationDims = 3</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Contains the number of real values in a location type. Useful for 
output routines that must deal transparently with many different
location modules.
</P>

</div>
<br>

<!--=============== DESCRIPTION OF A PUBLIC CONSTANT =================-->

<A NAME="LocationName"></A>
<br>
<div class=routine>
<pre>
<em class=call>character(len=129), parameter :: LocationName = "loc3Dsphere"</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
A parameter set to "loc3Dsphere" used to identify this location module
in netCDF output metadata.
</P>

</div>
<br>

<!--=============== DESCRIPTION OF A PUBLIC CONSTANT =================-->

<A NAME="LocationLName"></A>
<br>
<div class=routine>
<pre>
<em class=call>character(len=129), parameter :: LocationLName = <br>
       "threed sphere locations: lon, lat, lev or pressure"</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
A parameter set to "threed sphere locations: lon, lat, lev or pressure" used 
to identify this location module in netCDF output long name metadata.
</P>

</div>
<br>

<!--=============== DESCRIPTION OF A PUBLIC CONSTANT =================-->

<A NAME="horiz_dist_only"></A>
<br>
<div class=routine>
<pre>
<em class=call>logical :: horiz_dist_only</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
This is a namelist variable that determines whether distance computation
is horizontal only or not.
</P>

</div>
<br>

<!--==================================================================-->
<!--=================== DESCRIPTION OF A NAMELIST  ===================-->
<!--==================================================================-->

<A NAME="Namelist"></A>
<HR>
<H2>NAMELIST</H2>
<P>We adhere to the F90 standard of starting a namelist with an ampersand
'&amp;' and terminating with a slash '/' for all our namelist input.
Consider yourself forewarned that character strings that contain a '/' must be
enclosed in quotes to prevent them from prematurely terminating the namelist.
The namelist declaration (i.e. what follows) has a different syntax, naturally.
</P>
<div class=namelist>
<pre>
<em class=call>namelist / location_nml / </em> &amp;
   horiz_dist_only, vert_normalization_pressure, vert_normalization_height, &amp;
   vert_normalization_level, approximate_distance, nlon, nlat, output_box_info
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Items in this namelist either control the way in which distances 
are computed and/or influence the code performance.
<br><br>
If <em>horiz_distance_only</em> is .false.
then the appropriate normalization constant determines the relative impact of
vertical and horizontal separation.  Since only a single localization
distance is specified, and the vertical scales might have very different
distance characteristics, the vert_normalization_xxx values can be used
to scale the vertical appropriately to control the desired influence 
of observations in the vertical.
<br><br>
For search efficiency all locations are pre-binned. The surface of the
sphere is divided up into <em>nlon</em> by <em>nlat</em> boxes and the
index numbers of all items (both state vector entries and observations)
are stored in the appropriate box.  
To locate all points close to a given location, only the locations
listed in the boxes within the search radius must be checked.  
<!--   Does this really clarify anything?  is it right?
This speeds up the computations, for example, when localization controls
which state vector items are impacted by any given observation.  The search
radius is the localization distance and only those state vector items
in boxes closer than the radius to the observation location are processed.
-->
<br><br>
The default values have given good performance on many of our
existing model runs, but for tuning purposes the box counts
have been added to the namelist to allow adjustment.  
By default the code prints some summary information about how full
the average box is, how many are empty, and how many items were in the
box with the largest count.  
The namelist value <em>output_box_info</em> can be set to .true. to
get even more information about the box statistics.
The best performance will be obtained somewhere between two extremes;
the worst extreme is all the
points are located in just a few boxes.  This degenerates into a (slow)
linear search through the index list.  The other extreme is a large
number of empty or sparsely filled boxes.  The overhead of creating,
managing, and searching a long list of boxes will impact performance.
The best performance lies somewhere in the middle, where each box
contains a reasonable number of values, more or less evenly
distributed across boxes. 
The absolute numbers for best performance will certainly
vary from case to case.
<br><br>
For latitude, the <em>nlat</em> boxes are distributed evenly across the
actual extents of the data. (Locations are in radians, so the
maximum limits are the poles at -PI/2 and +PI/2).   
For longitude, 
the code automatically determines if the data is spread around more
than half the sphere, and if so, the boxes are
distributed evenly across the entire sphere (longitude range 0 to 2*PI).  
If the data spans less than half the sphere in longitude, 
the actual extent of the data is determined (including correctly
handling the cyclic boundary at 0) and the boxes are 
distributed only within the data extent.
This simplifies the actual distance calculations 
since the distance from the minimum longitude box to the
maximum latitude box cannot be shorter going the other way around the sphere.
<!-- (Computing distances going over the poles still must be considered.) -->
In practice, for a global model the boxes are evenly distributed
across the entire surface of the sphere.  
For local or regional models, the boxes
are distributed only across the the extent of the local grid.
<br><br>
This namelist is read in a file called <em class=file>input.nml</em> .
</P>

<TABLE border=0 cellpadding=3 width=100%>
<TR><TH align=left>Contents    </TH>
    <TH align=left>Type        </TH>
    <TH align=left>Description </TH></TR>
<TR><!--contents--><TD valign=top>horiz_dist_only</TD>
    <!--  type  --><TD valign=top>logical</TD>
    <!--descript--><TD>Only compute horizontal distance component?
                 Default: true</TD></TR>
<TR><!--contents--><TD valign=top>vert_normalization_pressure</TD>
    <!--  type  --><TD valign=top>real(r8)</TD>
    <!--descript--><TD>How many pascals should be equivalent distance to one 
                       radian? Default: 100000.0</TD></TR>
<TR><!--contents--><TD valign=top>vert_normalization_height</TD>
    <!--  type  --><TD valign=top>real(r8)</TD>
    <!--descript--><TD>How many geopotential meters should be equal 
                       to one radian?  Default: 10000.0</TD></TR>
<TR><!--contents--><TD valign=top>vert_normalization_level</TD>
    <!--  type  --><TD valign=top>real(r8)</TD>
    <!--descript--><TD>How many model levels should be equal to one radian? 
                Default: 20.0</TD></TR>
<TR><!--contents--><TD valign=top>approximate_distance</TD>
    <!--  type  --><TD valign=top>logical</TD>
    <!--descript--><TD> If true, uses a table lookup for fast approximate
           computation of distances on sphere. Distance computation can be
           a first order cost for some spherical problems, so this can increase
           speed significantly at a loss of some precision. Default: .false.
                </TD></TR>
<TR><!--contents--><TD valign=top>nlon</TD>
    <!--  type  --><TD valign=top>integer</TD>
    <!--descript--><TD> Number of boxes (bins) created in the longitude 
           direction.  Must be an odd number.   (See discussion above for more
           information about this item.)
           Default: 71 </TD></TR>
<TR><!--contents--><TD valign=top>nlat</TD>
    <!--  type  --><TD valign=top>integer</TD>
    <!--descript--><TD> Number of boxes (bins) created in the latitude 
           direction.  (See discussion above for more
           information about this item.)
           Default: 36 </TD></TR>
<TR><!--contents--><TD valign=top>output_box_info</TD>
    <!--  type  --><TD valign=top>logical</TD>
    <!--descript--><TD> If true, print more details about the
           distribution of locations across the array of boxes.
           Default: .false. </TD></TR>
</TABLE>

</div>
<br>

<!--==================================================================-->
<!-- Describe the Files Used by this module.                          -->
<!--==================================================================-->

<A NAME="FilesUsed"></A>
<HR>
<H2>FILES</H2>
<TABLE border=0 >
<TR><TH>filename</TH>
    <TH>purpose</TH></TR>
<TR><TD>input.nml</TD>
    <TD>to read the location_mod namelist</TD></TR>
</TABLE>

<!--==================================================================-->
<!-- Cite references, if need be.                                     -->
<!--==================================================================-->

<A NAME="References"></A>
<HR>
<H2>REFERENCES</H2>
<ol>
<li> none </li>
</ol>

<!--==================================================================-->
<!-- Describe all the error conditions and codes.                     -->
<!--==================================================================-->

<A NAME="Errors"></A>
<HR>
<H2>ERROR CODES and CONDITIONS</H2>
<div class=errors>
<TABLE border=1 cellspacing=1 cellpadding=10 width=100%>
<TR><TH>Routine</TH><TH>Message</TH><TH>Comment</TH></TR>

<TR><!-- routine --><TD VALIGN=top>initialize_module</TD>
    <!-- message --><TD VALIGN=top> nlon must be odd </TD>
    <!-- comment --><TD VALIGN=top>Tuning parameter for number of longitude boxes
                        must be odd for algorithm to function.</TD>
</TR>

<TR><!-- routine --><TD VALIGN=top>get_dist</TD>
    <!-- message --><TD VALIGN=top>Dont know how to compute vertical distance 
                    for unlike vertical coordinates</TD>
    <!-- comment --><TD VALIGN=top>Need same which_vert for distances.</TD>
</TR>

<TR><!-- routine --><TD VALIGN=top>set_location</TD>
    <!-- message --><TD VALIGN=top>longitude (#) is not within range [0,360]</TD>
    <!-- comment --><TD VALIGN=top>Is it really a longitude?</TD>
</TR>
<TR><!-- routine --><TD VALIGN=top>set_location</TD>
    <!-- message --><TD VALIGN=top>latitude (#) is not within range [-90,90]</TD>
    <!-- comment --><TD VALIGN=top>Is it really a latitude?</TD>
</TR>
<TR><!-- routine --><TD VALIGN=top>set_location</TD>
    <!-- message --><TD VALIGN=top>which_vert (#) must be one of 1, 2, or 3</TD>
    <!-- comment --><TD VALIGN=top>Vertical coordinate type restricted to:<BR>
               -1 = surface value <BR>
                1 = level <BR>
                2 = pressure <BR>
                3 = height <BR></TD>
</TR>
<TR><!-- routine --><TD VALIGN=top>read_location</TD>
    <!-- message --><TD VALIGN=top>Expected location header "loc3d" in input file, got ___</TD>
    <!-- comment --><TD VALIGN=top>Vertical coordinate confusion involving NetCDF file.</TD>
</TR>
<TR><!-- routine --><TD VALIGN=top>nc_write_location</TD>
    <!-- message --><TD VALIGN=top>Various NetCDF-f90 interface error messages</TD>
    <!-- comment --><TD VALIGN=top>From one of the NetCDF calls in nc_write_location</TD>
</TR>

</TABLE>
</div>

<H2>KNOWN BUGS</H2>
<P>
The Hawaii and Workshop versions of this module had an error in the
approximate distance computation. The available values in the lookup
table for cosine were insufficient for some cases. This manifested 
itself as potential errors, most commonly for computing distances 
near the poles. For relatively small horizontal localizations, this 
problem only occurred for locations very near the pole.
</P>

<!--==================================================================-->
<!-- Describe Future Plans.                                           -->
<!--==================================================================-->

<A NAME="FuturePlans"></A>
<HR>
<H2>FUTURE PLANS</H2>
<P>
Need to provide more efficient algorithms for getting close observations
and document the nlon and nlat choices and their impact on cost.
</P>

<!--==================================================================-->
<!-- PrivateComponents                                                -->
<!--==================================================================-->

<A NAME="PrivateComponents"></A>
<HR>
<H2>PRIVATE COMPONENTS</H2>
<P>
N/A
</P>

<!--==================================================================-->
<!-- Legalese & Metadata                                              -->
<!--==================================================================-->

<A NAME="Legalese"></A>
<HR>
<H2>Terms of Use</H2>

<P>
DART software - Copyright &#169; 2004 - 2010 UCAR.<br>
This open source software is provided by UCAR, "as is",<br>
without charge, subject to all terms of use at<br>
<a href="http://www.image.ucar.edu/DAReS/DART/DART_download">
http://www.image.ucar.edu/DAReS/DART/DART_download</a>
</P>

<TABLE border=0 cellpadding=0 width=100% summary="">
<TR><TD valign=top>Contact:       </TD><TD> DART core group   </TD></TR>
<TR><TD>Revision:      </TD><TD> $Revision$ </TD></TR>
<TR><TD>Source:        </TD><TD> $URL$ </TD></TR>
<TR><TD>Change Date:   </TD><TD> $Date$ </TD></TR>
<TR><TD valign=top>Change&nbsp;history:&nbsp;</TD><TD> try "svn&nbsp;log" or "svn&nbsp;diff" </TD></TR>
</TABLE>

<!--==================================================================-->

</BODY>
</HTML>
