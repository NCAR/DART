<!--
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!                                                                       !!
!!                   GNU General Public License                          !!
!!                                                                       !!
!! This file is part of the Data Assimilation Research Testbed (DART).   !!
!!                                                                       !!
!! DART is free software; you can redistribute it and/or modify          !!
!! it and are expected to follow the terms of the GNU General Public     !!
!! License as published by the Free Software Foundation.                 !!
!!                                                                       !!
!! DART is distributed in the hope that it will be useful,               !!
!! but WITHOUT ANY WARRANTY; without even the implied warranty of        !!
!! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         !!
!! GNU General Public License for more details.                          !!
!!                                                                       !!
!! You should have received a copy of the GNU General Public License     !!
!! along with DART; if not, write to:                                    !!
!!          Free Software Foundation, Inc.                               !!
!!          59 Temple Place, Suite 330                                   !!
!!          Boston, MA  02111-1307  USA                                  !!
!! or see:                                                               !!
!!          http://www.gnu.org/licenses/gpl.txt                          !!
!!                                                                       !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-->

<HTML>
<TITLE>module assim_model_mod</TITLE>
<link rel=stylesheet type=text/css href=../doc/html/doc.css>
<BODY>

<DIV ALIGN=CENTER>
<A HREF="#Interface">INTERFACE</A> / 
<A HREF="#PublicEntities">PUBLIC COMPONENTS</A> / 
<A HREF="#Namelist">NAMELIST</A> / 
<A HREF="#FilesUsed">FILES</A> /
<A HREF="#References">REFERENCES</A> /
<A HREF="#Errors">ERRORS</A> /
<A HREF="#KnownBugs">BUGS</A> /
<A HREF="#FuturePlans">PLANS</A> /
<A HREF="#PrivateComponents">PRIVATE COMPONENTS</A>
</DIV>

<!--==================================================================-->

<H1>MODULE assim_model_mod</H1>
<A NAME="HEADER"></A>
<TABLE summary="">
   <TR><TD>Contact:       </TD><TD> Jeff Anderson                </TD></TR>
   <TR><TD>Reviewers:     </TD><TD> &nbsp;                       </TD></TR>
   <TR><TD>Revision:      </TD><TD> $Revision$             </TD></TR>
   <TR><TD>Release Name:  </TD><TD> $Name$                       </TD></TR>
   <TR><TD>Change Date:   </TD><TD> $Date$ </TD></TR>
   <TR><TD>Change history:</TD><TD> see CVS log                  </TD></TR>
</TABLE>

<!--==================================================================-->

<A NAME="OVERVIEW"></A>
<HR>
<H2>OVERVIEW</H2>

<P>
   This module acts as an intermediary between DART compliant models
   and the filter. At one time the assim_model_type, which combines a
   state vector and a time_type, was envisioned as being fundamental to 
   how DART views model states. This paradigm is gradually being abandoned
   so that model state vectors and times are handled as separate
   data types. It is important to call static_init_assim_model before 
   using routines in assim_model_mod. Interfaces to work with model
   time stepping, restart files, and computations about the locations
   of model state variables and the distance between observations and
   state variables. Many of the interfaces are passed through nearly directly
   to the model_mod.
</P>

<!--==================================================================-->

<A NAME="OTHER MODULES USED"></A>
<BR><HR><BR>
<H2>OTHER MODULES USED</H2>
<PRE>
types_mod
location_mod (model dependent choice)
time_manager_mod
utilities_mod
model_mod
</PRE>

<!--==================================================================-->
<!--Note to authors. The first row of the table is different.         -->


<A NAME="Interface"></A>
<BR><HR><BR>
<H2>PUBLIC INTERFACE</H2>

<TABLE>
<TR><TD><em class=call>use assim_model_mod, only : </em></TD>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine42">adv_1step</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine31">aget_closest_state_time_to</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine5" >aget_initial_condition</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine29">aoutput_diagnostics</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine30">aread_state_restart</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyypubtype1" >assim_model_type</A> </TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine32">awrite_state_restart</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine41">close_restart</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine11">copy_assim_model</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine20">end_assim_model</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine44">ens_mean_for_model</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine28">finalize_diag_output</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine45">get_close_maxdist_init</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine46">get_close_obs</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine47">get_close_obs_init</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine4" >get_closest_state_time_to</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine24">get_diag_input_copy_meta_data</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine43">get_initial_condition</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine3" >get_model_size</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine10">get_model_state_vector</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine9" >get_model_time</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine38">get_model_time_step</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine6" >get_state_meta_data</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine25">init_assim_model</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine22">init_diag_input</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine2" >init_diag_output</A> </TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine23">input_diagnostics</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine13">interpolate</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine35">nc_append_time</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine37">nc_get_tindex</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine36">nc_write_calendar_atts</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyypubtype2" >netcdf_file_type</A> </TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine39">open_restart_read</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine40">open_restart_write</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine19">output_diagnostics</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine34">pert_model_state</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine18">read_state_restart</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine16">set_model_state_vector</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine15">set_model_time</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine1" >static_init_assim_model</A> </TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine17">write_state_restart</A></TD></TR>
</TABLE>

<H3 class=indent1>NOTES</H3>

<P>
Optional namelist interface 
<A HREF="#Namelist"> <em class=code>&#38;assim_model_nml</em> </A>
may be read from file <em class=file>input.nml</em>.
</P>

<!--==================================================================-->
<!-- Declare all public entities ...                                  -->
<!-- duplicate public routines template as many times as necessary    -->
<!-- make sure you replace all yyyroutine?? strings                   -->
<!--==================================================================-->

<A NAME="PublicEntities"></A>
<BR><HR><BR>
<H2>PUBLIC COMPONENTS</H2>
<BR>

<!--=================== DESCRIPTION OF A LOCAL TYPE ==================-->

<A NAME="yyypubtype1"></A>
<BR><HR><BR>
<div class=type><pre>
<em class=call>type assim_model_type</em>
   private
   real(r8), pointer   :: state_vector(:) 
   type(time_type)     :: time
   integer             :: model_size
   integer             :: copyID
end type assim_model_type
</pre></div>

<H3 class=indent1>Description</H3>

<P>
This type is used to represent both the state and time of a state
from a model.
</P>

<TABLE border=0 cellpadding=3 width=100%>
<TR><TH align=left>Component   </TH>
    <TH align=left>Description </TH></TR>
<TR><TD valign=top> state_vector                       </TD>
    <TD>A one dimensional representation of the model state vector. </TD></TR>
<TR><TD valign=top> time                       </TD>
    <TD>The time of the model state. </TD></TR>
<TR><TD valign=top> model_size                       </TD>
    <TD>Size of the model state vector. </TD></TR>
<TR><TD valign=top> copyID                       </TD>
    <TD>Not used in present implementation.</TD></TR>
</TABLE>
<!--=================== DESCRIPTION OF A LOCAL TYPE ==================-->

<A NAME="yyypubtype2"></A>
<BR><HR><BR>
<div class=type><pre>
<em class=call>type netcdf_file_type</em>
   integer             :: ncid
   integer             :: Ntimes
   integer             :: NtimesMAX
   real(r8), pointer   :: rtimes(:)
   type(time_type), pointer :: times(:)
   character(len = 80)      :: fname
end type netcdf_file_type
</pre></div>

<H3 class=indent1>Description</H3>

<P>
Basically, we want to keep a local mirror of the unlimited dimension
coordinate variable (i.e. time) because dynamically querying it
causes unacceptable performance degradation over "long" integrations.
</P>

<TABLE border=0 cellpadding=3 width=100%>
<TR><TH align=left>Component        </TH>
    <TH align=left>Description      </TH></TR>
<TR><TD valign=top> ncid            </TD>
    <TD>The netcdf file unit id.    </TD></TR>
<TR><TD valign=top> Ntimes          </TD>
    <TD>The current working length. </TD></TR>
<TR><TD valign=top> NtimesMAX       </TD>
    <TD>Allocated length.           </TD></TR>
<TR><TD valign=top> rtimes          </TD>
    <TD>Times as real (r8).         </TD></TR>
<TR><TD valign=top> times           </TD>
    <TD>Times as time_types.        </TD></TR>
<TR><TD valign=top> fname           </TD>
    <TD>Netcdf file name.           </TD></TR>
</TABLE>

<!--===================== DESCRIPTION OF SUBROUTINE =====================-->

<A NAME="yyyroutine1"></A>
<P></P><HR><P></P>
<div class=routine>
<em class=call>call static_init_assim_model() </em>
<pre>
</pre></div>

<H3 class=indent1>Description</H3>

<P>
   Initializes the assim_model class. Must be called before any other 
   assim_model_mod interfaces are used. Also calls the static initialization
   for the underlying model.
</P>

<H3 class=indent1>Notes</H3>

<!--===================== DESCRIPTION OF FUNCTION =====================-->

<A NAME="yyyroutine2"></A>
<P></P><HR><P></P>
<div class=routine>
<em class=call> ncFileID = init_diag_output(FileName, global_meta_data, 
   copies_of_field_per_time, meta_data_per_copy) </em>
<pre>
integer                                        :: <em class=code> init_diag_output </em>
character (len = *)                            :: <em class=code> FileName </em>
character (len = *)                            :: <em class=code> global_meta_data </em>
integer, intent(in)                            :: <em class=code> copies_of_field_per_time </em>
character (len = *), intent(in), &
          dimension(copies_of_field_per_time)  :: <em class=code> meta_data_per_copy </em>
</pre></div>

<H3 class=indent1>Description</H3>

<P>
   Initializes a netCDF file for output of state space diagnostics. A handle to 
   the channel on which the file is opened is returned.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>FileName &nbsp; &nbsp; </em></TD>
    <TD>Name of file to open.</TD></TR>

<TR><TD valign=top><em class=code>global_meta_data</em></TD>
    <TD>Global metadata that describes the contents of this file.</TD></TR>

<TR><TD valign=top><em class=code>copies_of_field_per_time</em></TD>
    <TD> Number of copies of data to be written at each time. For instance,
         these could be the prior ensemble members, prior ensemble mean, 
         prior ensemble spread, posterior ensemble members, posterior
         spread and mean, etc..</TD></TR>
<TR><TD valign=top><em class=code>meta_data_per_copy</em></TD>
    <TD> Metadata describing each of the copies.</TD></TR>

<TR><TD valign=top><em class=code>ncFileID</em></TD>
    <TD>Channel number on which file is opened.</TD></TR>

</TABLE>

<BR>

<!--===================== DESCRIPTION OF FUNCTION =====================-->

<A NAME="yyyroutine3"></A>
<P></P><HR><P></P>
<div class=routine>
<em class=call> var = get_model_size() </em>
<pre>
integer                               :: <em class=code>get_model_size </em>
</pre></div>

<H3 class=indent1>Description</H3>

<P>
  Returns the size of the model state vector. 
  This is a direct pass through to the model_mod.   
</P>

<BR>

<!--===================== DESCRIPTION OF FUNCTION =====================-->

<A NAME="yyyroutine4"></A>
<P></P><HR><P></P>
<div class=routine>
<em class=call> var = get_closest_state_time_to(assim_model, time) </em>
<pre>
type(time_type)                                   :: <em class=code> get_closest_state_time_to </em>
type(assim_model_type), intent(in)                :: <em class=code> assim_model </em>
type(time_type), intent(in)                       :: <em class=code> time</em>
</pre></div>

<H3 class=indent1>Description</H3>

<P>
  Returns the closest time that a model is capable of advancing a given state to a 
  specified time. For instance, what is the closest time to 12GMT 01 January, 2004
  that a model state at 00GMT 01 January, 2004 can be advanced?  If the model time
  is past the time, the model time is returned (new feature in releases after Hawaii).
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>assim_model &nbsp; &nbsp; </em></TD>
    <TD>A model state vector and time that might be advanced.</TD></TR>

<TR><TD valign=top><em class=code>time</em></TD>
    <TD>A time that one would like to get close to with the model.</TD></TR>

<TR><TD valign=top><em class=code>var</em></TD>
    <TD>The closest time to which the model can be advanced is returned.</TD></TR>

</TABLE>

<BR>

<!--==================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->

<!--kdr this was misnamed get_initial condition,and was missing the time variable -->
<!--    Also note that description in code is wrong; it's the same as get_initial_condition! -->
<!--    And I think that x should not be inout, but out only  YES -->
<!--    FIX in code and tell Jeff  -->


 <A NAME="yyyroutine5"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call aget_initial_condition(time,x) </em>
 <pre>
 type(time_type), intent(out) :: <em class=code>time</em>
 type(r8), intent(out) :: <em class=code>x</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
 Reads an initial time and state vector from a restart format file
 into a real time and real array, which are put into an assim_model_type.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>time&nbsp; &nbsp; </em></TD>
     <TD>Contains time of input state vector on return</TD></TR>
 <TR><TD valign=top><em class=code>x&nbsp; &nbsp; </em></TD>
     <TD>Contains state of input state vector on return</TD></TR>
 </TABLE>
 <BR>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE ======================-->
 <A NAME="yyyroutine6"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call get_state_meta_data() </em>
 <pre>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
SEE model_mod for arguments and description. 
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 </TABLE>
 <BR>

 <!--================================================================-->
 
 <!--============= DESCRIPTION OF A FUNCTION ========================-->
<A NAME="yyyroutine9"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> var = get_model_time(assim_model) </em>
 <pre>
 type(time_type)                    :: <em class=code>get_model_time</em>
 type(assim_model_type), intent(in) :: <em class=code>assim_model</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
 Returns time from an assim_model type.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>get_model_time&nbsp; &nbsp; </em></TD>
     <TD>Time from assim_model</TD></TR>
 <TR><TD valign=top><em class=code>assim_model&nbsp; &nbsp; </em></TD>
     <TD>Assim_model type from which to extract time</TD></TR>
 </TABLE>
 <BR>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A FUNCTION ========================-->
<A NAME="yyyroutine10"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> var = get_model_state_vector(assim_model) </em>
 <pre>
 real(r8), dimension(model_size)    :: <em class=code>get_model_state_vector</em
 >
 type(assim_model_type), intent(in) :: <em class=code>assim_model</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
 Returns the state vector component from an assim_model_type.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>get_model_state_vector&nbsp; &nbsp; </em></TD
 >
     <TD>Returned state vector</TD></TR>
 <TR><TD valign=top><em class=code>assim_model&nbsp; &nbsp; </em></TD>
     <TD>Input assim_model_type</TD></TR>
 </TABLE>
 <BR>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
<A NAME="yyyroutine11"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call copy_assim_model(model_out,model_in) </em>
 <pre>
 type(assim_model_type), intent(out) :: <em class=code>model_out</em>
 type(assim_model_type), intent(in)  :: <em class=code>model_in</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Copies one assim_model_type to another.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>model_out&nbsp; &nbsp; </em></TD>
     <TD>Copy</TD></TR>
 <TR><TD valign=top><em class=code>model_in&nbsp; &nbsp; </em></TD>
     <TD>Copy</TD></TR>
 </TABLE>
 <BR>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
<A NAME="yyyroutine13"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call interpolate(x,location,loctype,obs_vals,istatus) </em>
 <pre>
 real(r8), intent(in), dimension(:) :: <em class=code>x</em>
 type(location_type), intent(in)    :: <em class=code>location</em>
 integer, intent(in)                :: <em class=code>loctype</em>
 real(r8), intent(out)              :: <em class=code>obs_vals</em>
 integer, intent(out)               :: <em class=code>istatus</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Interpolates a given model state variable type to a location given
the model state vector. Nearly direct call to model_interpolate in
model_mod.  See model_mod for the error return values in istatus.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>x&nbsp; &nbsp; </em></TD>
     <TD>Model state vector.</TD></TR>
 <TR><TD valign=top><em class=code>location&nbsp; &nbsp; </em></TD>
     <TD>Location to which to interpolate.</TD></TR>
 <TR><TD valign=top><em class=code>loctype&nbsp; &nbsp; </em></TD>
     <TD>Type of variable to interpolate.</TD></TR>
 <TR><TD valign=top><em class=code>obs_vals&nbsp; &nbsp; </em></TD>
     <TD>Returned interpolated value.</TD></TR>
 <TR><TD valign=top><em class=code>istatus&nbsp; &nbsp; </em></TD>
     <TD>Returned as 0 if all is well, else various errors.</TD></TR>
 </TABLE>
 <BR>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
<A NAME="yyyroutine15"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call set_model_time(assim_model,time) </em>
 <pre>
 type(assim_model_type), intent(inout) :: <em class=code>assim_model</em>
 type(time_type), intent(in)           :: <em class=code>time</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
 Sets the time in an assim_model_type.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>assim_model&nbsp; &nbsp; </em></TD>
     <TD>Set the time in this assim_model_type.</TD></TR>
 <TR><TD valign=top><em class=code>time&nbsp; &nbsp; </em></TD>
     <TD>Set to this time</TD></TR>
 </TABLE>
 <BR>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
<A NAME="yyyroutine16"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call set_model_state_vector(assim_model,state) </em>
 <pre>
 type(assim_model_type), intent(inout) :: <em class=code>assim_model</em>
 real(r8), dimension(:), intent(in)    :: <em class=code>state</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
 Set the state in an assim_model_type.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>assim_model&nbsp; &nbsp; </em></TD>
     <TD>Set the state vector part of this.</TD></TR>
 <TR><TD valign=top><em class=code>state&nbsp; &nbsp; </em></TD>
     <TD>The state vector to be inserted.</TD></TR>
 </TABLE>
 <BR>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
<A NAME="yyyroutine17"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call write_state_restart(assim_model,funit<em class=optionalcode>[,target_time]</em>) </em>
 <pre>
 type(assim_model_type), intent(in)    :: <em class=code>assim_model</em>
 integer, intent(in)                   :: <em class=code>funit</em>
 type(time_type), optional, intent(in) :: <em class=code>target_time</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Writes a restart from an assim_model_type with an optional target_time.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>assim_model&nbsp; &nbsp; </em></TD>
     <TD>Write a restart from this assim_model_type.</TD></TR>
 <TR><TD valign=top><em class=code>funit&nbsp; &nbsp; </em></TD>
     <TD>Integer file unit id open for output of restart files.</TD></TR>
 <TR><TD valign=top><em class=code>target_time&nbsp; &nbsp; </em></TD>
     <TD>If present, put this target time at the front of the restart file.</TD></TR>
 </TABLE>
 <BR>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
<A NAME="yyyroutine18"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call read_state_restart(assim_model,funit<em class=optionalcode>[,target_time]</em>) </em>
 <pre>
 type(assim_model_type), intent(out)    :: <em class=code>assim_model</em>
 integer, intent(in)                    :: <em class=code>funit</em>
 type(time_type), optional, intent(out) :: <em class=code>target_time</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Read a state restart file into assim_model_type. Optionally read a prepended
target time.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>assim_model&nbsp; &nbsp; </em></TD>
     <TD>Read the time and state vector from restart into this.</TD></TR>
 <TR><TD valign=top><em class=code>funit&nbsp; &nbsp; </em></TD>
     <TD>File id that has been opened for reading restart files.</TD></TR>
 <TR><TD valign=top><em class=code>target_time&nbsp; &nbsp; </em></TD>
     <TD>If present, read a target time from the front of the file into this.</TD></TR>
 </TABLE>
 <BR>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
<A NAME="yyyroutine19"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call output_diagnostics(ndFileID,state,copy_index) </em>
 <pre>
 type(netcdf_file_type), intent(inout) :: <em class=code>ndFileID</em>
 type(assim_model_type), intent(in)    :: <em class=code>state</em>
 integer, optional, intent(in)         :: <em class=code>copy_index</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Writes one copy of the state time and vector to a netCDF file.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>ndFileID&nbsp; &nbsp; </em></TD>
     <TD>An identifier for a netCDFF file</TD></TR>
 <TR><TD valign=top><em class=code>state&nbsp; &nbsp; </em></TD>
     <TD>State vector and time</TD></TR>
 <TR><TD valign=top><em class=code>copy_index&nbsp; &nbsp; </em></TD>
     <TD>Which copy of state is to be output</TD></TR>
 </TABLE>
 <BR>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
<A NAME="yyyroutine20"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call end_assim_model() </em>
 <pre>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Called to clean-up at end of assim_model use. For now just passes through
to model_mod.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 </TABLE>
 <BR>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
<A NAME="yyyroutine23"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call input_diagnostics(file_id,state,copy_index) </em>
 <pre>
 integer, intent(in)                   :: <em class=code>file_id</em>
 type(assim_model_type), intent(inout) :: <em class=code>state</em>
 integer, intent(out)                  :: <em class=code>copy_index</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Used to read in a particular copy of the state vector from an open
state diagnostics file.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>file_id&nbsp; &nbsp; </em></TD>
     <TD>Integer descriptor (channel number) for a diagnostics file being read.</TD></TR>
 <TR><TD valign=top><em class=code>state&nbsp; &nbsp; </em></TD>
     <TD>Assim_model_type to read in data.</TD></TR>
 <TR><TD valign=top><em class=code>copy_index&nbsp; &nbsp; </em></TD>
     <TD>Which copy of state to be read.</TD></TR>
 </TABLE>
 <BR>

 <!--================================================================-->

 <!--============= DESCRIPTION OF A FUNCTION ========================-->
<A NAME="yyyroutine22"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> var = init_diag_input(file_name, global_meta_data, model_size, 
 copies_of_field_per_time) </em>
 <pre>
 integer                       :: <em class=code>init_diag_input</em>
 character(len=*), intent(in)  :: <em class=code>file_name</em>
 character(len=*), intent(out) :: <em class=code>global_meta_data</em>
 integer, intent(out)          :: <em class=code>model_size</em>
 integer, intent(out)          :: <em class=code>copies_of_field_per_time</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Opens a state diagnostic file and reads the global meta data, model size, and
number of data copies.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>init_diag_input&nbsp; &nbsp; </em></TD>
     <TD>Returns the unit number on which the file is open.</TD></TR>
 <TR><TD valign=top><em class=code>file_name&nbsp; &nbsp; </em></TD>
     <TD>File name of state diagnostic file.</TD></TR>
 <TR><TD valign=top><em class=code>global_meta_data&nbsp; &nbsp; </em></TD>
     <TD>Global metadata string from file.</TD></TR>
 <TR><TD valign=top><em class=code>model_size&nbsp; &nbsp; </em></TD>
     <TD>Size of model.</TD></TR>
 <TR><TD valign=top><em class=code>copies_of_field_per_time&nbsp; &nbsp; </em></TD>
     <TD>Number of copies of the state vector at each time.</TD></TR>
 </TABLE>
 <BR>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
<A NAME="yyyroutine25"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call init_assim_model(state) </em>
 <pre>
 type(assim_model_type), intent(inout) :: <em class=code>state</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
 Creates storage for an assim_model_type.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>state&nbsp; &nbsp; </em></TD>
     <TD>An assim_model_type that needs storage created.</TD></TR>
 </TABLE>
 <BR>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
<A NAME="yyyroutine24"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call get_diag_input_copy_meta_data(file_id,model_size_out,
 num_copies,location,meta_data_per_copy) </em>
 <pre>
 integer, intent(in)                                         :: <em class=code>file_id</em>
 integer, intent(in)                                         :: <em class=code>model_size_out</em>
 integer, intent(in)                                         :: <em class=code>num_copies</em>
 type(location_type), dimension(model_size_out), intent(out) :: <em class=code>location</em>
 character(len = *), dimension(num_copies)                   :: <em class=code>meta_data_per_copy</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Reads meta-data describing state vectors in a state diagnostics file.
Given the file, the model_size, and the number of copies, returns the
locations of each state variable and the text description of each copy.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>file_id&nbsp; &nbsp; </em></TD>
     <TD>Integer channel open to state diagostic file being read</TD></TR>
 <TR><TD valign=top><em class=code>Model_size_out&nbsp; &nbsp; </em></TD>
     <TD>model size</TD></TR>
 <TR><TD valign=top><em class=code>num_copies&nbsp; &nbsp; </em></TD>
     <TD>Number of copies of state in file</TD></TR>
 <TR><TD valign=top><em class=code>location&nbsp; &nbsp; </em></TD>
     <TD>Returned locations for state vector</TD></TR>
 <TR><TD valign=top><em class=code>meta_data_per_copy&nbsp; &nbsp; </em></TD>
     <TD>Meta data describing what is in each copy of state vector</TD></TR>
 </TABLE>
 <BR>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A FUNCTION ========================-->
<A NAME="yyyroutine28"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> var = finalize_diag_output(ncFileID) </em>
 <pre>
 integer                               :: <em class=code>finalize_diag_output</em>
 type(netcdf_file_type), intent(inout) :: <em class=code>ncFileID</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Used to complete writing on and open netcdf file. An error return is provided
for passing to the netcdf error handling routines.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>finalize_diag_output&nbsp; &nbsp; </em></TD>
     <TD>Returns an error value.</TD></TR>
 <TR><TD valign=top><em class=code>ncFileID&nbsp; &nbsp; </em></TD>
     <TD>Netcdf file id of an open file.</TD></TR>
 </TABLE>
 <BR>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
<A NAME="yyyroutine30"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call aread_state_restart(model_time,model_state,funit 
     <em class=optionalcode>[,target_time]</em>) </em>
 <pre>
 type(time_type), intent(out)           :: <em class=code>model_time</em>
 real(r8), dimension(:), intent(out)    :: <em class=code>model_state</em>
 integer, intent(in)                    :: <em class=code>funit</em>
 type(time_type), optional, intent(out) :: <em class=code>target_time</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Reads a model time and state, and optionally a prepended target time,
from a state restart file.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>model_time&nbsp; &nbsp; </em></TD>
     <TD>Returned time of model state</TD></TR>
 <TR><TD valign=top><em class=code>model_state&nbsp; &nbsp; </em></TD>
     <TD>Returned model state.</TD></TR>
 <TR><TD valign=top><em class=code>funit&nbsp; &nbsp; </em></TD>
     <TD>Channel open for reading a state restart file.</TD></TR>
 <TR><TD valign=top><em class=code>target_time&nbsp; &nbsp; </em></TD>
     <TD>If present, this time is read from the front of the restart file.</TD></TR>
 </TABLE>
 <BR>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A FUNCTION ========================-->
<A NAME="yyyroutine31"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> var = aget_closest_state_time_to (model_time, time) </em>
 <pre>
 type(time_type)             :: <em class=code>aget_closest_state_time_to</em>
 type(time_type), intent(in) :: <em class=code>model_time</em>
 type(time_type), intent(in) :: <em class=code>time</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
 Computes the closest time to which a model can advance given
the current model time and a target time. If the target time is earlier
than the model time, the model time is returned (new feature in post Hawaii
releases).
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>aget_closest_state_time_to&nbsp; &nbsp; </em>
 </TD>
     <TD>The closest model accessible time to time.</TD></TR>
 <TR><TD valign=top><em class=code>model_time&nbsp; &nbsp; </em></TD>
     <TD>The current time of the model state.</TD></TR>
 <TR><TD valign=top><em class=code>time&nbsp; &nbsp; </em></TD>
     <TD>The time we want to get close to.</TD></TR>
 </TABLE>
 <BR>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
<A NAME="yyyroutine29"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call aoutput_diagnostics(ncFileID,model_time,model_state,copy_index) </em>
 <pre>
 type(netcdf_file_type), intent(inout) :: <em class=code>ncFileID</em>
 type(time_type), intent(in)           :: <em class=code>model_time</em>
 real(r8), dimension(:), intent(in)    :: <em class=code>model_state</em>
 integer, optional, intent(in)         :: <em class=code>copy_index</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
 Write a state vector to a state diagnostics netcdf file.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>ncFileID&nbsp; &nbsp; </em></TD>
     <TD>Unit for a state vector netcdf file open for output.</TD></TR>
 <TR><TD valign=top><em class=code>model_time&nbsp; &nbsp; </em></TD>
     <TD>The time of the state to be output</TD></TR>
 <TR><TD valign=top><em class=code>model_state&nbsp; &nbsp; </em></TD>
     <TD>A model state vector to be output.</TD></TR>
 <TR><TD valign=top><em class=code>copy_index&nbsp; &nbsp; </em></TD>
     <TD>Which copy of state vector is to be written, default is copy 1</TD></TR>
 </TABLE>
 <BR>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
<A NAME="yyyroutine32"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call awrite_state_restart(model_time,model_state,funit
     <em class=optionalcode>[,target_time]</em>) </em>
 <pre>
 type(time_type), intent(in)           :: <em class=code>model_time</em>
 real(r8), dimension(:), intent(in)    :: <em class=code>model_state</em>
 integer, intent(in)                   :: <em class=code>funit</em>
 type(time_type), optional, intent(in) :: <em class=code>target_time</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Writes a model time and state vector to a restart file and optionally
prepends a target time.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>model_time&nbsp; &nbsp; </em></TD>
     <TD>Time of model state.</TD></TR>
 <TR><TD valign=top><em class=code>model_state&nbsp; &nbsp; </em></TD>
     <TD>Model state vector.</TD></TR>
 <TR><TD valign=top><em class=code>funit&nbsp; &nbsp; </em></TD>
     <TD>Channel of file open for restart output.</TD></TR>
 <TR><TD valign=top><em class=code>target_time&nbsp; &nbsp; </em></TD>
     <TD>If present, time to be prepended to state time / vector.</TD></TR>
 </TABLE>
 <BR>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
<A NAME="yyyroutine34"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call pert_model_state() </em>
 <pre>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
 Passes through to pert_model_state in model_mod. See model_mod
documentation for arguments and details.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 </TABLE>
 <BR>

 <!--================================================================-->
<!--============= DESCRIPTION OF A FUNCTION ========================-->
<A NAME="yyyroutine35"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> var = nc_append_time(ncFileID,time) </em>
 <pre>
 integer                               :: <em class=code>nc_append_time</em>
 type(netcdf_file_type), intent(inout) :: <em class=code>ncFileID</em>
 type(time_type), intent(in)           :: <em class=code>time</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
 Appends the time to the time coordinate variable of the netcdf file.
The new lenght of the time variable is returned. Requires that time is
a coordinate variable AND it is the unlimited dimension.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>nc_append_time&nbsp; &nbsp; </em></TD>
     <TD>Returns new length of time variable.</TD></TR>
 <TR><TD valign=top><em class=code>ncFileID&nbsp; &nbsp; </em></TD>
     <TD>Points to open netcdf file.</TD></TR>
 <TR><TD valign=top><em class=code>time&nbsp; &nbsp; </em></TD>
     <TD>The next time to be added to the file.</TD></TR>
 </TABLE>
 <BR>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A FUNCTION ========================-->
<A NAME="yyyroutine36"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> var = nc_write_calendar_atts(ncFileID,TimeVarID) </em>
 <pre>
 integer                            :: <em class=code>nc_write_calendar_atts</em>
 type(netcdf_file_type), intent(in) :: <em class=code>ncFileID</em>
 integer, intent(in)                :: <em class=code>TimeVarID</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
 Sets up the metadata for the appropriate calendar being used in the
time manager an writes it to a netcdf file.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>nc_write_calendar_atts&nbsp; &nbsp; </em></TD>
     <TD>Returns a netcdf error code.</TD></TR>
 <TR><TD valign=top><em class=code>ncFileID&nbsp; &nbsp; </em></TD>
     <TD>Netcdf file id pointing to a file open for writing.</TD></TR>
 <TR><TD valign=top><em class=code>TimeVarID&nbsp; &nbsp; </em></TD>
     <TD>The index of the time variable in the netcdf file.</TD></TR>
 </TABLE>
 <BR>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A FUNCTION ========================-->
<A NAME="yyyroutine37"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> var = nc_get_tindex(ncFileID,statetime) </em>
 <pre>
 integer                               :: <em class=code>nc_get_tindex</em>
 type(netcdf_file_type), intent(inout) :: <em class=code>ncFileID</em>
 type(time_type), intent(in)           :: <em class=code>statetime</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Returns the index of a time from the time variable in a netcdf file. This
function has been replaced with more efficient approaches and may be
deleted from future releases.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>nc_get_tindex&nbsp; &nbsp; </em></TD>
     <TD>The index of the time in the netcdf file.</TD></TR>
 <TR><TD valign=top><em class=code>ncFileID&nbsp; &nbsp; </em></TD>
     <TD>File id for an open netcdf file.</TD></TR>
 <TR><TD valign=top><em class=code>statetime&nbsp; &nbsp; </em></TD>
     <TD>The time to be found in the netcdf file.</TD></TR>
 </TABLE>
 <BR>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A FUNCTION ========================-->
<A NAME="yyyroutine38"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> var = get_model_time_step() </em>
 <pre>
 type(time_type) :: <em class=code>get_model_time_step</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
 This passes through to model_mod. See model_mod documentation for
arguments and details.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>get_model_time_step&nbsp; &nbsp; </em></TD>
     <TD>Returns time step of model.</TD></TR>
 </TABLE>
 <BR>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A FUNCTION ========================-->
<A NAME="yyyroutine39"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> var = open_restart_read(file_name) </em>
 <pre>
 integer                      :: <em class=code>open_restart_read</em>
 character(len=*), intent(in) :: <em class=code>file_name</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
 Opens a restart file for readig.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>open_restart_read&nbsp; &nbsp; </em></TD>
     <TD>Returns a file descriptor (channel number).</TD></TR>
 <TR><TD valign=top><em class=code>file_name&nbsp; &nbsp; </em></TD>
     <TD>Name of restart file to be open for reading.</TD></TR>
 </TABLE>
 <BR>

 <!--================================================================-->
<!--============= DESCRIPTION OF A FUNCTION ========================-->
<A NAME="yyyroutine40"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> var = open_restart_write(file_name) </em>
 <pre>
 integer                      :: <em class=code>open_restart_write</em>
 character(len=*), intent(in) :: <em class=code>file_name</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
 Open a restart file for writing.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>open_restart_write&nbsp; &nbsp; </em></TD>
     <TD>Returns a file descriptor (channel) for a restart file.</TD></TR>
 <TR><TD valign=top><em class=code>file_name&nbsp; &nbsp; </em></TD>
     <TD>File name of restart file to be opened.</TD></TR>
 </TABLE>
 <BR>

 <!--================================================================-->
<!--============= DESCRIPTION OF A SUBROUTINE =======================-->
<A NAME="yyyroutine41"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call close_restart(file_unit) </em>
 <pre>
 integer, intent(in) :: <em class=code>file_unit</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
 Closes a restart file.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>file_unit&nbsp; &nbsp; </em></TD>
     <TD>File descriptor (channel number) of open restart file.</TD></TR>
 </TABLE>
 <BR>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
<A NAME="yyyroutine42"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call adv_1step() </em>
 <pre>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
 Advances a model by one step. Pass through to model_mod. See model_mod
documentation for arguments and details.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 </TABLE>
 <BR>

 <!--================================================================-->
<!--============= DESCRIPTION OF A SUBROUTINE =======================-->
<A NAME="yyyroutine43"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call get_initial_condition(x) </em>
 <pre>
 type(assim_model_type), intent(out) :: <em class=code>x</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
 Obtains an initial condition from models that support this option.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>x&nbsp; &nbsp; </em></TD>
     <TD>assim_model into which an initial model state can be written.</TD></TR>
 </TABLE>
 <BR>

 <!--================================================================-->
<!--============= DESCRIPTION OF A SUBROUTINE =======================-->
<A NAME="yyyroutine44"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call ens_mean_for_model(ens_mean) </em>
 <pre>
 type(r8), intent(in) :: <em class=code>ens_mean(:)</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
 An array of length model_size containing the ensemble means.
 This is a direct pass through to the model_mod.   
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>ens_mean&nbsp; &nbsp; </em></TD>
     <TD>Array of length model_size containing the mean for each 
         entry in the state vector.</TD></TR>
 </TABLE>
 <BR>

 <!--================================================================-->
<!--============= DESCRIPTION OF A SUBROUTINE =======================-->
<A NAME="yyyroutine45"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call get_close_maxdist_init(gc, maxdist) </em>
 <pre>
 type(get_close_type), intent(inout) :: <em class=code>gc</em>
 type(r8), intent(in)                :: <em class=code>maxdist</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
 Sets the threshold distance.  Anything closer than this is deemed to
 be close.
 This is a direct pass through to the model_mod, which in turn can pass 
 through to the location_mod.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>gc&nbsp; &nbsp; </em></TD>
     <TD>Data for efficiently finding close locations.</TD></TR>
 <TR><TD valign=top><em class=code>maxdist&nbsp; &nbsp; </em></TD>
     <TD>Anything closer than this distance is a close location.</TD></TR>
 </TABLE>
 <BR>

 <!--================================================================-->
<!--============= DESCRIPTION OF A SUBROUTINE =======================-->
<A NAME="yyyroutine46"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call get_close_obs(gc, base_obs_loc, base_obs_kind, obs,
                 obs_kind, num_close, close_ind, dist) </em>
 <pre>
 type(get_close_type),             intent(in)  :: <em class=code>gc</em>
 type(location_type),              intent(in)  :: <em class=code>base_obs_loc</em>
 integer,                          intent(in)  :: <em class=code>base_obs_kind</em>
 type(location_type),              intent(in)  :: <em class=code>obs(:)</em>
 integer,                          intent(in)  :: <em class=code>obs_kind(:)</em>
 integer,                          intent(out) :: <em class=code>num_close</em>
 integer,                          intent(out) :: <em class=code>close_ind(:)</em>
 real(r8),             optional,   intent(out) :: <em class=code>dist(:)</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
 Given a single location and a list of other locations, returns the
 indices of all the locations close to the single one along with the
 number of these and the distances for the close ones.
 The observation kinds are passed in to allow more sophisticated 
 distance computations to be done if needed.
 This is a direct pass through to the model_mod, which in turn can pass 
 through to the location_mod.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>gc&nbsp; &nbsp; </em></TD>
     <TD>Data for efficiently finding close locations.</TD></TR>
 <TR><TD valign=top><em class=code>base_obs_loc&nbsp; &nbsp; </em></TD>
     <TD>Single given location.</TD></TR>
 <TR><TD valign=top><em class=code>base_obs_kind&nbsp; &nbsp; </em></TD>
     <TD>Kind of the single location.</TD></TR>
 <TR><TD valign=top><em class=code>obs&nbsp; &nbsp; </em></TD>
     <TD>List of observations from which close ones are to be found.</TD></TR>
 <TR><TD valign=top><em class=code>obs_kind&nbsp; &nbsp; </em></TD>
     <TD>Kind associated with observations in obs list.</TD></TR>
 <TR><TD valign=top><em class=code>num_close&nbsp; &nbsp; </em></TD>
     <TD>Number of observations close to the given location.</TD></TR>
 <TR><TD valign=top><em class=code>close_ind&nbsp; &nbsp; </em></TD>
     <TD>Indices of those locations that are close.</TD></TR>
 <TR><TD valign=top><em class=code>dist&nbsp; &nbsp; </em></TD>
     <TD>Distance between given location and the close ones 
         identified in close_ind.</TD></TR>
 </TABLE>
 <BR>

 <!--================================================================-->
<!--============= DESCRIPTION OF A SUBROUTINE =======================-->
<A NAME="yyyroutine47"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call get_close_obs_init(gc, num, obs) </em>
 <pre>
 type(get_close_type), intent(inout) :: <em class=code>gc</em>
 integer, intent(in)                 :: <em class=code>num</em>
 type(location_type), intent(in)     :: <em class=code>obs(:)</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
 Initialize storage for efficient identification of locations close to a 
 given location.  Allocates storage for keeping track of which 'box' each 
 observation in the list is in.
 This is a direct pass through to the model_mod, which in turn can pass 
 through to the location_mod.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>gc&nbsp; &nbsp; </em></TD>
     <TD>Data for efficiently finding close locations.</TD></TR>
 <TR><TD valign=top><em class=code>num&nbsp; &nbsp; </em></TD>
     <TD>The number of locations in the list.</TD></TR>
 <TR><TD valign=top><em class=code>obs&nbsp; &nbsp; </em></TD>
     <TD>The location of each element in the list, not used 
         in 1D implementation.</TD></TR>
 </TABLE>
 <BR>

 <!--================================================================-->
<!--=================== DESCRIPTION OF A NAMELIST  ===================-->

<A NAME="Namelist"></A>
<BR><HR><BR>
<H2>NAMELIST</H2>
<P>We adhere to the F90 standard of starting a namelist with an ampersand 
'&' and terminating with a slash '/'.
</P>
<div class=namelist><pre>
<em class=call>namelist / assim_model_nml / </em> &
    write_binary_restart_files
</pre></div>

<H3 class=indent1>Discussion</H3>

<P>This namelist is read in a file called <em class=file>input.nml</em>
</P>

<TABLE border=0 cellpadding=3 width=100%>
<TR><TH align=left>Contents    </TH>
    <TH align=left>Type        </TH>
    <TH align=left>Description </TH></TR>
<TR><!--contents--><TD valign=top>write_binary_restart_files</TD>
    <!--  type  --><TD>logical                         </TD>
    <!--descript--><TD> Are output state restart files ascii (false) or 
                        unformatted (true)? Default is true.
</TABLE>

<!--==================================================================-->
<!-- Describe the Files Used by this module.                          -->
<!--==================================================================-->

<!--kdr; Should these files be listed as "used by this module"? -->
<!--     What about diagnostics files? -->
<A NAME="FilesUsed"></A>
<BR><HR><BR>
<H2>FILES</H2>
<UL><LI>filter_restart specified in DART/filter/filter.nml: restart_in_filename
    <LI>filter_restart specified in DART/filter/filter.nml: restart_out_filename
    <LI>assim_model_mod.nml in input.nml
</UL>

<!--==================================================================-->
<!-- Cite references, if need be.                                     -->
<!--==================================================================-->

<A NAME="References"></A>
<BR><HR><BR>
<H2>REFERENCES</H2>

<!--==================================================================-->
<!-- Describe all the error conditions and codes.                     -->
<!-- Putting a <BR> after the synopsis creates a nice effect.         -->
<!--==================================================================-->

<A NAME="Errors"></A>
<HR>
<H2>ERROR CODES and CONDITIONS</H2>
<div class="errors">
<TABLE border=1 cellspacing=1 cellpadding=10 width=100%>
<TR><TH>Routine</TH><TH>Message</TH><TH>Comment</TH></TR>

<TR><!-- routine --><TD VALIGN=top>init_diag_output</TD>
    <!-- message --><TD VALIGN=top>Compiler does not support required kinds of variables.</TD>
    <!-- comment --><TD VALIGN=top>NetCDF-f90 interface function byteSizeOK returned FALSE</TD>
</TR>

<TR><!-- routine --><TD VALIGN=top>init_diag_output and various nc_XXX</TD>
    <!-- message --><TD VALIGN=top>various NetCDF-f90 messages</TD>
    <!-- comment --><TD VALIGN=top>Returned by one of the NetCDF calls in this subroutine. 
      Consult the NetCDF manual. </TD>
</TR>
<TR><!-- routine --><TD VALIGN=top>get_diag_input_copy_meta_data</TD>
    <!-- message --><TD VALIGN=top>expected to read "locat" got ...</TD> 
    <!-- comment --><TD VALIGN=top>The header of the metadata for the copies of the data 
                        in diagnostic input file is not = 'locat'</TD>
</TR>
<TR><!-- routine --><TD VALIGN=top>set_model_state_vector</TD>
    <!-- message --><TD VALIGN=top>state vector has length # 
                      model size (#) does not match.</TD>
    <!-- comment --><TD VALIGN=top>Check your model resolution and fields included in the state vector.</TD>
</TR>
<TR><!-- routine --><TD VALIGN=top>aread_state_restart</TD>
    <!-- message --><TD VALIGN=top>read error is : # </TD>
    <!-- comment --><TD VALIGN=top>Unable to read model state from assim_model_state_ic# file. 
                        # is error condition retured by read statement.</TD>
</TR>
<TR><!-- routine --><TD VALIGN=top>open_restart_read</TD>
    <!-- message --><TD VALIGN=top>OPEN status was #</TD>
    <!-- comment --><TD VALIGN=top>Failed to open file listed for reason #.</TD>
</TR>
<TR><!-- routine --><TD VALIGN=top>aoutput_diagnostics</TD>
    <!-- message --><TD VALIGN=top>model time (d,s) (#,#) is index # in ncFileID # </TD>
    <!-- comment --><TD VALIGN=top>Time index for file listed is < 0 </TD>
</TR>
<TR><!-- routine --><TD VALIGN=top>ainput_diagnostics</TD>
    <!-- message --><TD VALIGN=top>expected "copy", got _____'</TD>
    <!-- comment --><TD VALIGN=top>Trying to read diagnostic state output header.</TD>
</TR>
<TR><!-- routine --><TD VALIGN=top>nc_append_time</TD>
    <!-- message --><TD VALIGN=top>"time" expected to be rank-1</TD>
    <!-- comment --><TD VALIGN=top>ndims /= 1 <BR>
      The time array of the NetCDF file should be 1-dimensional</TD>
</TR>
<TR><!-- routine --><TD VALIGN=top>nc_append_time</TD>
    <!-- message --><TD VALIGN=top>unlimited dimension expected to be slowest-moving</TD>
    <!-- comment --><TD VALIGN=top>dimids(1) /= unlimitedDimID</TD>
</TR>
<TR><!-- routine --><TD VALIGN=top>nc_append_time</TD>
    <!-- message --><TD VALIGN=top>time mirror and netcdf file time dimension out-of-sync</TD>
    <!-- comment --><TD VALIGN=top>lngth /= ncFileId%Ntimes</TD>
</TR>
<TR><!-- routine --><TD VALIGN=top>nc_append_time</TD>
    <!-- message --><TD VALIGN=top>various NetCDF-f90 error messages</TD>
    <!-- comment --><TD VALIGN=top>Returned from one of the NetCDF calls in this subroutine.
      Consult the NetCDF manual. </TD>
</TR>
<TR><!-- routine --><TD VALIGN=top>nc_get_tindex</TD>
    <!-- message --><TD VALIGN=top>trouble deep ... can go no farther. Stopping.</TD>
    <!-- comment --><TD VALIGN=top>timeindex < -1</TD>
</TR>
<TR><!-- routine --><TD VALIGN=top>nc_get_tindex</TD>
    <!-- message --><TD VALIGN=top>Model time preceeds earliest netCDF time.</TD>
    <!-- comment --><TD VALIGN=top>Time of current assim_model is earlier than all the times 
     on the NetCDF file to which the state is to be written by aoutput_diagnostics.</TD>
</TR>
<TR><!-- routine --><TD VALIGN=top>nc_get_tindex</TD>
    <!-- message --><TD VALIGN=top>subsequent netCDF time (days, seconds) # # </TD>
    <!-- comment --><TD VALIGN=top>Time of current assim_model is in the midst of the times 
     on the NetCDF file to which the state is to be written by aoutput_diagnostics,
     but doesn't match any of them.  Very bad.</TD>
</TR>
<TR><!-- routine --><TD VALIGN=top>nc_get_tindex</TD>
    <!-- message --><TD VALIGN=top>various NetCDF-f90 error messages</TD>
    <!-- comment --><TD VALIGN=top>Returned from one of the NetCDF calls in this subroutine.
      Consult the NetCDF manual. </TD>
</TR>
<TR><!-- routine --><TD VALIGN=top>nc_write_calendar_atts</TD>
    <!-- message --><TD VALIGN=top>various NetCDF-f90 error messages</TD>
    <!-- comment --><TD VALIGN=top>Returned from one of the NetCDF calls in this subroutine.
      Consult the NetCDF manual. </TD>
</TR>
</TR> -->
</TABLE>
</div>

<!--==================================================================-->
<!-- Describe the bugs.                                               -->
<!--==================================================================-->

<A NAME="KnownBugs"></A>
<BR><HR><BR>
<H2>KNOWN BUGS</H2>
<P>
</P>

<!--==================================================================-->
<!-- Descibe Future Plans.                                            -->
<!--==================================================================-->

<A NAME="FuturePlans"></A>
<BR><HR><BR>
<H2>FUTURE PLANS</H2>
<P>
</P>

<!--==================================================================-->
<!-- Have not fleshed out this part yet ... ha ha ha                  -->
<!--==================================================================-->

<A NAME="PrivateComponents"></A>
<BR><HR><BR>
<H2>PRIVATE COMPONENTS</H2>



<!--==================================================================-->

<HR>
</BODY>
</HTML>
