<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<HTML>
<HEAD>
<TITLE>module model_mod (GCOM)</TITLE>
<link rel="stylesheet" type="text/css" href="../../doc/html/doc.css" />
<link href="../../doc/images/dart.ico" rel="shortcut icon" />
</HEAD>
<BODY>
<A NAME="TOP"></A>

<H1>MODULE model_mod (GCOM)</H1>

<table border=0 summary="" cellpadding=5>
<tr>
    <td valign=middle>
    <img src="../../doc/images/Dartboard7.png" alt="DART project logo" height=70 />
    </td>
    <td>
       <P>Jump to <a href="../index.html">DART Documentation Main Index</a><br />
          <small><small>version information for this file: <br />
          <!-- version tag follows, do not edit -->
          $Id$</small></small>
       </P></td>
</tr>
</table>

<A HREF="#Namelist">NAMELIST</A> /
<A HREF="#Interface">INTERFACES</A> /
<A HREF="#FilesUsed">FILES</A> /
<A HREF="#References">REFERENCES</A> /
<A HREF="#Errors">ERRORS</A> /
<A HREF="#FuturePlans">PLANS</A> /
<A HREF="#PrivateComponents">PRIVATE COMPONENTS</A> /
<A HREF="#Legalese">TERMS OF USE</A>

<H2>Overview</H2>

<P>
This is the DART interface to the 
<a href="http://www.csrc.sdsu.edu/research_reports/CSRCR2010-02.pdf">General Curvilinear Ocean Model (GCOM)</a>.
The interface was developed in early 2015 through a collaboration between 
San Diego State University and NCAR. The GCOM code is under active development
and several modifications were made to the code to support netCDF I/O, a
more robust time management system, and translations from the conceptual 
grid to a physical lat/lon/depth space required to locate real observations.
The GCOM source code is <strong>not</strong> distributed with DART and 
must be obtained from SDSU.
<br /><br />
<strong>It is strongly recommended that you read and work through the
<a href="http://www.image.ucar.edu/DAReS/DART/DART_Starting.php#tutorial_simple">DART tutorial</a>
long before you start working with GCOM/DART or any other model!</strong>
<br /><br />
There are many routines in the DART interface that are under development and
are expected to change as GCOM evolves. Since this is an experimental 
configuration, it is strongly suggested that you become familiar with
all the public interface routines in <em class=file>model_mod.f90</em>.
<br /><br />
There are at least two areas that <strong>need to be improved</strong> 
before meaningful results can be achieved.
</P>
<ol><li>
    <em class=code>model_interpolate()</em> routine. This is the workhorse
    routine to calculate the forward observation operator. Given the fully
    curvilinear GCOM grid, it is challenging to find the voxel that contains
    the observation in question. Traditionally, the DART forward operators
    linearly interpolate within a bounding voxel. While there is no formal theory
    that indicates this is "the right" solution, it does avoid the problems of
    extrapolation. The current algorithm in  
    <em class=file>models/GCOM/model_mod.f90</em>:<em class=code>model_interpolate()</em>
    employs a nearest-neighbor 
    inverse-distance-weighted algorithm which <em>does not prevent extrapolation</em>.
    Furthermore, given the grid spacing, it is possible to have all the 
    nearest neighbors consist of the levels at one horizontal location.
    Like I said - this needs work.
    <br /><br />
    There are (potentially many) routines in 
    <em class=file>model_mod.f90</em> that are borrowed from the DART/POP
    interface. These are not currently used and are left in the code strictly
    in the hopes they will be useful to whomever decides to fix 
    <em class=code>model_interpolate()</em>.</li>
<li style="list-style: none"><br /></li>    
<li>The generation of the initial ensemble. A proper initial ensemble can be 
    created in many ways, and can be created incorrectly in many more! A proper
    ensemble has sufficient spread to encompass our uncertainty in our 
    knowledge of the system. A single state may be perturbed by the 
    addition of some sort of noise and then the model typically has to run
    for some length of time to stabilize from the shock - or you can use a
    'climatological' ensemble.<br /><br />
    <ol><li>Perturbing a single state requires knowlege of what kind of 
    noise to add to whatever state variables are important and running 
    GCOM till such time as a stable solution is achieved. The current 
    solution in 
    <em class=file>models/GCOM/model_mod.f90</em>:
    <em class=code>pert_model_state()</em> is totally inadequate. It uses 
    random noise from the same distribution for all variables at all depths.
    This cannot be a good thing to do.</li>
    <li style="list-style: none"><br /></li>    
    <li>Using a climatological ensemble has typically meant that you use the
    model state for the same day-of-year from a multi-year run. This does 
    not exist (to my knowledge) for GCOM. It may be sufficient to use model
    states that are not that widely separated. How widely separated is 
    not clear.</li>
    <li style="list-style: none"><br /></li>    
    </ol>
    Both methods have their drawbacks. The main goal is to get an ensemble that
    the model can tolerate (some models numerically fail with improper states)
    and have enough ensemble spread such that the observations fall within
    the solution space of the model. If the observations and model states 
    are too far apart, the observation may be rejected. This is the root 
    cause of filter divergence and can lead to the ensemble of model states 
    totally ignoring the information from the observations. The DART diagnostics
    will provide insight into whether or not the ensemble spread is sufficient
    for a good assimilation. Pay particular attention to the number of observations
    being rejected and how the RMSE and spread evolve through time.
</li>
</ol>
<P>
The GCOM <em class=code>model_mod</em> is an experimental interface under
active development. There are <strong>many</strong> routines that issue
warnings begging the user to confirm the result. Once these have been confirmed,
please send word back to me (Tim c/o  dart@ucar.edu) and I will happily incorporate
your comments and suggestions after our group performs our due dilligence
and has a 'code review'. The GCOM code has not undergone our group code review.
It will surely be improved when it does. Until then, I have tried to identify and
call attention to parts of the code that could use oversight.
</P>

<H2>Important scripts.</H2>
<P>The scripts are heavily internally documented and are 
<strong>absolutely not</strong> "black-box" solutions. They will need to be modified
and customized for your machine, filesystem, etc. Please browse them to understand
the big picture and then go back and re-read them to fully grasp what is going on.
</P>
<TABLE border=0 cellpadding=5 width=100% summary='script description'>
<THEAD align=left>
<TR><TH> Script </TH>
    <TH> Description </TH> </TR>
</THEAD>
<TBODY valign=top>

<TR><TD><a href="shell_scripts/run_perfect_model_obs.csh">run_perfect_model_obs.csh</a></TD>
    <TD>runs a single instance of GCOM to harvest synthetic observations for an OSSE or
        "perfect model" experiment. It requires a single GCOM state as input 
         <strong>and</strong> an <em class=file>obs_seq.in</em> that contains the
        locations and type of the observations desired. See the section on 
        <a href="http://www.image.ucar.edu/DAReS/DART/DART_Observations.php#obs_synthetic"> Creating a synthetic observation sequence</a>. 
        That example uses the lorenz_63 model as the example, but the steps are 
        identical for any model. <em class=program>run_perfect_model_obs.csh</em> 
        is written to be very similar to the script used for an assimilation 
        experiment (<em class=program>run_filter.csh</em>) because many of the 
        same steps are required.
        <br />
    </TD>
</TR>

<TR><TD><a href="shell_scripts/run_filter.csh">run_filter.csh</a></TD>
    <TD>runs an ensemble of GCOM states for an assimilation, i.e.  
        "filtering" experiment. It requires an ensemble of GCOM states as input 
         <strong>and</strong> an <em class=file>obs_seq.out</em> that contains the
        observations to be used in the assimilation. As always, the observation
        sequence file generally determines the length of the experiment. These
        should be configured to run in the time allowed in whatever cluster you
        are running on.
        <br />
    </TD>
</TR>

<TR><TD><a href="shell_scripts/advance_model.csh">advance_model.csh</a></TD>
    <TD>is responsible for advancing the GCOM state from the current time to 
        some arbitrary time in the future. The future time is determined by
        the specification of the assimilation 'time step' and the time of the
        next observation (or set of observations) to be assimilated.
        <br />
    </TD>
</TR>

<TR><TD><a href="shell_scripts/Split_netCDF_by_time.csh">Split_netCDF_by_time.csh</a></TD>
    <TD>is a utility to create many <em class=file>gcom_restart_????.nc</em>
        files from a single <em class=file>gcom_restart.nc</em> file that has
        multiple time steps. Each time step is extracted and is used to create
        a single file. The <em class=code>time</em> variable in ALL of the files
        is then overwritten with a single time that is specified in the script.
        This time <strong>must match</strong> the starting time in the GCOM
        <em class=file>param.dat</em><em class=code>Start_Time</em> specification.
        This is intended to be an example of how to create a 'climatological'
        ensemble. To be useful, the time steps in the source 
        <em class=file>gcom_restart.nc</em> file should be 'widely separated'.  
        <br />
    </TD>
</TR>

</TABLE>

<H2>Pertinent details of the GCOM time management.</H2>

<P>
talk about the relationship between param.dat, the time in the gcom_restart.nc
file, the time in the dart_ics file and observations.</P>

<A NAME="vert_normalization_height"></A>
<H2>Discussion of <em class=code>vert_normalization_height</em> 
with respect to grid spacing.</H2>

<P>The relationship between 
<em class=file>input.nml</em><em class=code>&amp;location_nm:vert_normalization_height</em>,
<em class=code>&amp;assim_tools_nml:cutoff</em>, and the grid spacing is complicated.
The <em class=code>vert_normalization_height</em> is crucial with respect to the 
definition of what is within the localization radius or not.  It also has an 
impact on what gridcells contribute to the application of the 
forward observation operator.
<em><strong>The bottom line</strong></em> is that the default 
<em class=code>vert_normalization_height</em> 
should never be taken for granted.<br />
Test it and see if you like what gridcells are being used for the interpolation.<br />
Test it and see if you like what is happening to the innovations.
<br />
<br />
The <em class=code>model_interpolate()</em> code simply looks for the 
<strong>N</strong> nearest neighbors. When the horizontal grid SPACING is 
several kilometers and the vertical layers are on the order of tens of meters, 
and the vertical scale is not exaggerated (1&nbsp;km in the horizontal =~ 1&nbsp;km 
in the vertical) then ALL the nearest neighbors come from the same horizontal 
location and the N closest vertical layers are used. This felt really wrong to me, 
so I stretched the vertical exaggeration by choosing a 
<em class=code>vert_normalization_height</em> so that I got the N nearest 
neighbors from the 'same' vertical level.
<br />
<br />
In a high-res seamount case, for example, the horizontal spacing is closer to 50m, 
and the vertical layers are tens of meters apart. In this case, if there is 
NO vertical exaggeration, the N nearest neighbors can come from locations 
horizontally nearby as well as vertically - a much more natural representation.
<br />
<br />
However, that same vertical exaggeration is used in the distance calculation 
to determine what is in the localization radius.  Consequently, anyplace the 
grid is 'warped' in lat/lon space (i.e. the physical space), what is 'close' 
strongly depends on the vertical exaggeration as well as the degree of warping. 
So - it is quite possible - and quite accurate - to have gridcells that are not 
consecutively indexed to have distances that are not consecutive (hard to phrase, actually).
</P>

<TABLE border=0 cellpadding=5 width=100% summary='impact of vert_normalization_height and cutoff'>
<tr><td><img src="../../doc/images/gcom_local_grid_seamount.png" alt="seamount grid" height=400 /></td>
    <td>
What I mean is that if I put an observation EXACTLY at lonindex = 64, 
latindex = 16, levelindex = 10 (which is a bit on the side of the seamount case) 
and have a large vertical exaggeration (<em class=code>vert_normalization_height = 500</em>) ... 
it is entirely possible that 63,13,10 is closer than 64,15,10.  
This also causes the increments (the innovations) to appear to be 'noncontiguous', 
resulting in a peculiarly spotted field of innovations. 
The image to the left is an example of the few gridcells in a region that is
minimally warped.
</td>
</tr>
</table>

<P>
The following are diagnostics from a seamount case that had horizontal grid spacing about 50m and vertical
spacing in the 10's of meters range. I assimilated a single U_CURRENT_COMPONENT observation 
<strong>exactly</strong> on gridcell (64,16,10). With a <em class=code>vert_normalization_height = 500</em>
(a lot of vertical exaggeration), the 12 nearest neighbors all came from the same 'level'.
<strong>BUT</strong> I had to go to a <em class=code>cutoff = 0.000160</em> 
(a half-width of more than a kilometer!) to get any other gridcell to be within the cutoff 
radius - take a look at the following table of the 12 closest gridcells and the image to the lower left.
</P>
<pre> want interpolation of DART KIND          51 at   242.644923789000        32.5995745035500       -897.902750000000
rank dartindex         distance                 state_value     i  j  k    longitude (deg)   latitude (deg)    depth (meters)
 1   29455     2.120369787642344E-009 -5.352092637616289E-004   64 16 10   242.644923789000  32.5995745035500  -897.902750000000
 2   29552      62.6446256260277      -5.357401041928145E-004   64 17 10   242.644921565000  32.6001383024000  -897.902750000000
 3   29163      427.726339190069       0.436345399286287        63 13 10   242.644486434000  32.5978818510000  -897.872750000000
 4   29358      646.030429510927       9.731683813766100E-002   64 15 10   242.644926013000  32.5990107046500  -897.953250000000
 5   29649      655.078905333592       9.731683491462780E-002   64 18 10   242.644919341000  32.6007021012000  -897.953250000000
 6   29261      1809.16058305424       0.235254445079926        64 14 10   242.644928236500  32.5984469057000  -898.044500000000
 7   29746      1814.57536902641       0.235254439486291        64 19 10   242.644917117000  32.6012659000000  -898.044500000000
 8   29260      2708.85231830169       0.230943788947948        63 14 10   242.644484207500  32.5984456500000  -897.690250000000
 9   29745      2712.47153313136       0.230943783326527        63 19 10   242.644473074500  32.6012646441500  -897.690250000000
10   29164      3277.61800100468       0.434373030719604        64 13 10   242.644930460000  32.5978831067000  -898.159750000000
11   29456      3698.99441002118       1.246747080155530E-002   65 16 10   242.645367823500  32.5995757577500  -898.193250000000
12   29553      3699.52485671758       1.246747443816500E-002   65 17 10   242.645365602500  32.6001395566500  -898.193250000000</pre>

<P>
When I use <em class=code>vert_normalization_height = 6370000.0</em> (no exaggeration) the following 
are the N nearest neighbors and a <em class=code>cutoff = 0.000010</em> (a half-width of about 64 meters), 
results in the localization impacting a few neighboring gridcells - see the image on the lower right.
</P>

<pre> want interpolation of DART KIND          51 at   242.644923789000        32.5995745035500       -897.902750000000
rank dartindex         distance                 state_value     i  j  k    longitude (deg)   latitude (deg)    depth (meters)
 1   29455     2.120369787642344E-009 -5.352092637616289E-004   64 16 10   242.644923789000  32.5995745035500  -897.902750000000
 2   26351      12.8905509873473       3.258895970186345E-003   64 16  9   242.644923789000  32.5995745035500  -910.801000000000
 3   32559      13.7795200415402      -7.998252407111866E-003   64 16 11   242.644923789000  32.5995745035500  -884.115000000000
 4   23247      25.0055651719358       1.724938025585966E-003   64 16  8   242.644923789000  32.5995745035500  -922.923250000000
 5   35663      28.5696864642526      -1.753079675342877E-002   64 16 12   242.644923789000  32.5995745035500  -869.316000000000
 6   20143      36.4514789835257      -6.322428483856149E-003   64 16  7   242.644923789000  32.5995745035500  -934.376000000000
 7   29456      41.5656234744980       1.247075979010545E-002   65 16 10   242.645367823500  32.5995757577500  -898.193250000000
 8   29454      41.5669355887254      -1.132022111991248E-002   63 16 10   242.644479754500  32.5995732478000  -897.462750000000
 9   26350      43.3876021687945      -7.750119021557372E-003   63 16  9   242.644479754500  32.5995732478000  -910.354750000000
10   26352      43.6058582826109       1.610037073839844E-002   65 16  9   242.645367823500  32.5995757577500  -911.096000000000
11   32560      43.7001510110454       5.433125010459082E-003   65 16 11   242.645367823500  32.5995757577500  -884.400750000000
12   32558      43.9274327567607      -1.881031848668287E-002   63 16 11   242.644479754500  32.5995732478000  -883.681500000000</pre>


<TABLE border=0 cellpadding=5 width=100% summary='impact of vert_normalization_height and cutoff'>
<TR><TH colspan=2>Innovations from a single observation.</TH></TR>
<TR><TH><em class=code>vert_normalization_height = 500.0</em><br/>
        <em class=code>cutoff = 0.000160</em></TH>
    <TH><em class=code>vert_normalization_height = 6370000.0</em><br/>
        <em class=code>cutoff = 0.000010</em></TH>
</TR>
<TR>
<TD><img src="../../doc/images/gcom_cutoff_0.000160_height_500.u.pdf" alt="cutoff 0.000160 height 500" width=100% />
<TD><img src="../../doc/images/gcom_cutoff_0.000010_height_6370000.u.pdf" alt="cutoff 0.000010 height 6370000" width=100% />
</TR>

</TABLE>


<!--=====================================================================-->
<!--===================== DESCRIPTION OF A NAMELIST =====================-->
<!--=====================================================================-->

<A NAME="Namelist"></A>
<div class="top">[<a href="#">top</a>]</div><hr />
<H2>NAMELIST</H2>
<P>
This namelist is read from the file <em class=file>input.nml</em>.
Namelists start with an ampersand
'&amp;' and terminate with a slash '/'.
Character strings that contain a '/' must be
enclosed in quotes to prevent them from 
prematurely terminating the namelist.
The values shown here are the default values.
</P>

<div class=namelist>
<pre>
&amp;model_nml 
   gcom_restart_file            = 'gcom_restart.nc'
   gcom_geometry_file           = 'gcom_geometry.nc'
   output_state_vector          = .false.
   assimilation_period_days     = 1
   assimilation_period_seconds  = 0
   model_perturbation_amplitude = 0.2
   debug                        = 0
   gcom_variables = 'u', 'KIND_U_CURRENT_COMPONENT', 'NA',  'NA', 'UPDATE',
                    'v', 'KIND_V_CURRENT_COMPONENT', 'NA',  'NA', 'UPDATE',
                    'w', 'KIND_W_CURRENT_COMPONENT', 'NA',  'NA', 'UPDATE',
                    'p', 'KIND_PRESSURE',            '0.0', 'NA', 'UPDATE'
  /</pre>
</div>

<br />

<div>
<TABLE border=0 cellpadding=3 width=100% summary='namelist description'>
<THEAD align=left>
<TR><TH> Item </TH>
    <TH> Type </TH>
    <TH> Description </TH> </TR>
</THEAD>
<TBODY valign=top>

<TR><TD>gcom_restart_file</TD>
    <TD>character(len=256)</TD>
    <TD>this is the filename of the GCOM restart file. The DART scripts resolve
        linking the specific GCOM restart files to this generic name. This file
        provides the elements used to make up the DART state vector.
        </TD>
</TR>

<TR><TD>gcom_geometry_file</TD>
    <TD>character(len=256)</TD>
    <TD>this is the filename of the GCOM geometry file.
        The GCOM developers have not decided on having the geometry in a file 
        separate from the restart file. As implemented, this is simply a link
        to the <em class=file>gcom_restart.nc</em> file.
        </TD>
</TR>


<TR><TD>output_state_vector</TD>
    <TD>logical</TD>
    <TD>If <em class=code>.true.</em>, write the state vector as a 1D array 
        to the DART diagnostic output files. If <em class=code>.false.</em>,
        break up state vector into variables before writing to the output files.
        </TD>
</TR>

<TR><TD>assimilation_period_days, <br />
        assimilation_period_seconds</TD>
    <TD>integer</TD>
    <TD>Combined, these specify the width of the assimilation window.
        The current model time is used as the center time of the
        assimilation window. All observations in the assimilation window
        are assimilated. BEWARE: if you put observations that occur before
        the beginning of the assimilation_period, DART will error out because
        it cannot move the model 'back in time' to process these observations.
        DART can only advance the model in whole multiples of the assimilation
        window. The assimilation window must be compatible with how GCOM is
        configured by the <em class=code>Stop_Time_sec</em> and 
        <em class=code>Writeout_freq</em> in <em class=file>param.dat</em>.
        </TD>
</TR>

<TR><TD>model_perturbation_amplitude</TD>
    <TD>real(r8)</TD>
    <TD>This specifies the variance of the zero-mean gaussian noise used
        by the <em class=code>pert_model_state()</em> routine when creating
        an ensemble by perturbing a single model state.
    </TD>
</TR>

<TR><TD>debug</TD>
    <TD>integer</TD>
    <TD>Set to 0 (zero) for minimal output. Successively higher values
       generate successively more output. 9 is the last useful value.
       After I test a block, I will frequently leave the test in and
       set the debug level to 99. Those blocks are well tested but
       might be needed again under new model configurations. They generally
       produce too much output to be used in a production setting.
       </TD>
</TR>

</TBODY>
</TABLE>
</div>

<P><!-- make sure the 'top' is aligned correctly --></P>

<!--==================================================================-->

<A NAME="Interface"></A>
<div class="top">[<a href="#">top</a>]</div><hr />
<H2>OTHER MODULES USED</H2>
<PRE>
common/types_mod
time_manager/time_manager_mod
location/threed_sphere/location_mod
utilities/utilities_mod
obs_kind/obs_kind_mod
[null,]mpi_utilities/mpi_utilities_mod
random_seq/random_seq_mod
sort/sort_mod
typesizes (from the netCDF installation)
netcdf    (from the netCDF installation)
</PRE>

<!--==================================================================-->
<!-- Declare all public entities ...                                  -->
<!-- duplicate public routines template as many times as necessary    -->
<!-- make sure you replace all yyyroutine?? strings                   -->
<!--==================================================================-->
<!--Note to authors. The first row of the table is different.         -->
<!--==================================================================-->

<div class="top">[<a href="#">top</a>]</div><hr />
<H2>PUBLIC INTERFACES</H2>

<TABLE summary='list of required public interfaces'>
<TR><TD><em class=call>use model_mod, only : </em></TD>
                   <TD><A HREF="#get_model_size">get_model_size</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#adv_1step">adv_1step</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_state_meta_data">get_state_meta_data</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#model_interpolate">model_interpolate</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_model_time_step">get_model_time_step</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#static_init_model">static_init_model</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#end_model">end_model</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#init_time">init_time</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#init_conditions">init_conditions</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#nc_write_model_atts">nc_write_model_atts</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#nc_write_model_vars">nc_write_model_vars</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#pert_model_state">pert_model_state</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_close_maxdist_init">get_close_maxdist_init</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_close_obs_init">get_close_obs_init</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_close_obs">get_close_obs</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#ens_mean_for_model">ens_mean_for_model</A></TD></TR>
</TABLE>

<P>
   A note about documentation style.
   Optional arguments are enclosed in brackets
   <em class=optionalcode>[like this]</em>.
</P>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="get_model_size"></A>
<br />
<div class=routine>
<em class=call>model_size = get_model_size( )</em>
<pre>
integer :: <em class=code>get_model_size</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Returns the length of the model state vector.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>model_size</em></TD>
    <TD>The length of the model state vector.</TD></TR>

</TABLE>

</div>
<br />

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="adv_1step"></A>
<br />
<div class=routine>
<em class=call>call adv_1step(x, time)</em>
<pre>
real(r8), dimension(:), intent(inout) :: <em class=code>x</em>
type(time_type),        intent(in)    :: <em class=code>time</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Since GCOM is not advanced as a subroutine, this is simply a stub.
Should DART attempt to advance GCOM (<em class=code>async&nbsp;=&nbsp;0</em>).
<em class=code>adv_1step()</em> will cause a fatal error with a 
very clear message that DART cannot advance GCOM as a subroutine.
<em class=code>adv_1step()</em>
is only called if the namelist parameter
<em class=code>async&nbsp;=&nbsp;0 </em> in <em class=program>perfect_model_obs</em> or 
<em class=program>filter</em> or if the program 
<em class=program>integrate_model</em> is to be used to 
advance the model state as a separate executable.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>x</em></TD>
    <TD>State vector of length model_size.</TD></TR>

<TR><TD valign=top><em class=code>time&nbsp;&nbsp;&nbsp;</em></TD>
    <TD>Specifies time of the initial model state.</TD></TR>

</TABLE>

</div>
<br />

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="get_state_meta_data"></A>
<br />
<div class=routine>
<em class=call>call get_state_meta_data (index_in, location, 
                          <em class=optionalcode>[,&nbsp;var_type]</em> )</em>
<pre>
integer,             intent(in)  :: <em class=code>index_in</em>
type(location_type), intent(out) :: <em class=code>location</em>
integer, optional,   intent(out) :: <em class=optionalcode> var_type </em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Given an integer index into the state vector structure, returns the
associated location. A second intent(out) optional argument 
returns the generic kind of this item, e.g. KIND_U_CURRENT_COMPONENT,
KIND_DENSITY, KIND_SALINITY ... 
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>index_in&nbsp;&nbsp;&nbsp;</em></TD>
    <TD>Index of state vector element about which information is requested.</TD></TR>

<TR><TD valign=top><em class=code>location</em></TD>
    <TD>The location of state variable element.</TD></TR>

<TR><TD valign=top><em class=optionalcode>var_type</em></TD>
    <TD>The generic DART kind of the state variable element.</TD></TR>

</TABLE>

</div>
<br />

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="model_interpolate"></A>
<br />
<div class=routine>
<em class=call>call model_interpolate(x, location, itype, obs_val, istatus)</em>
<pre>
real(r8), dimension(:), intent(in)  :: <em class=code>x</em>
type(location_type),    intent(in)  :: <em class=code>location</em>
integer,                intent(in)  :: <em class=code>itype</em>
real(r8),               intent(out) :: <em class=code>obs_val</em>
integer,                intent(out) :: <em class=code>istatus</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Given a state vector, a location, and a DART KIND
interpolates the model state variable field to that location for
the DART KIND in question and returns 
the value in <em class=code>obs_val</em>.
This is the basis of all the forward observation operator code.
As of 30 April 2015 (r7876) the following is still true:
</P>
<blockquote>
The <em class=code>model_interpolate()</em> desperately needs work.
The nearest-neighbor algorithm currently in place is woefully inadequate
because it allows for extrapolation, and may (correctly) identify all 
the nearest neighbors as being in the same 'column'. The more correct
procedure would be to interpolate for the horizontal location at the layer below, 
again for the horizontal location at the layer above, and then 
vertically interpolate to the layer of interest. When someone codes that up,
PLEASE send me the code! Seriously! -- Tim -- P.S. It has to work for the 
fully curvilinear grid - and I don't mean just the easy case when its not 
actually curvilinear!</blockquote>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>x</em></TD>
    <TD>A model state vector.</TD></TR>

<TR><TD valign=top><em class=code>location&nbsp;&nbsp;&nbsp;</em></TD>
    <TD>Location to which to interpolate.</TD></TR>

<TR><TD valign=top><em class=code>itype</em></TD>
    <TD>Kind of state field to be interpolated.</TD></TR>

<TR><TD valign=top><em class=code>obs_val</em></TD>
    <TD> The interpolated value from the model.</TD></TR>

<TR><TD valign=top><em class=code>istatus</em></TD>
    <TD>Integer value returning 0 for success.
        Other values can be defined for various failures.
        Negative values are reserved for DART.</TD></TR>

</TABLE>

</div>
<br />

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="get_model_time_step"></A>
<br />
<div class=routine>
<em class=call>var = get_model_time_step()</em>
<pre>
type(time_type) :: <em class=code>get_model_time_step</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Returns the minimum amount of time that the model should be advanced.
This is not the dynamical timestep of the model, but rather some multiple
of the file output frequency. DART stops GCOM to get the new prior
for an assimilation cycle - <em class=code>get_model_time_step()</em>
is used to determine the forecast length.  The value  returned by 
<em class=code>get_model_time_step()</em> is set by 
<em class=file>input.nml</em><em class=code>&amp;model_nml</em> variables
<em class=code>assimilation_period_days</em> and 
<em class=code>assimilation_period_seconds</em>.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>var&nbsp;&nbsp;&nbsp;</em></TD>
    <TD>Smallest forecast length possible with GCOM.</TD></TR>

</TABLE>

</div>
<br />

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="static_init_model"></A>
<br />
<div class=routine>
<em class=call>call static_init_model()</em>
</div>

<div class=indent1>
<!-- Description -->

<P>
Called to do one-time initialization of the model.
<em class=code>static_init_model()</em> reads the DART 
<em class=file>input.nml</em> to determine what variables will be used
to create the DART state, what GCOM files to use to read the
GCOM grid and state, etc.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>
</TABLE>

</div>
<br />

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="end_model"></A>
<br />
<div class=routine>
<em class=call>call end_model()</em>
</div>

<div class=indent1>
<!-- Description -->

<P>
Deallocates the geometry variables from the model intialization. 
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>
</TABLE>

</div>
<br />

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="init_time"></A>
<br />
<div class=routine>
<em class=call>call init_time(time)</em>
<pre>
type(time_type), intent(out) :: <em class=code>time</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
DART/GCOM is not configured to start up from arbitrary initial conditions
so <em class=code>init_time()</em> is not supported.
Should <em class=code>init_time()</em> be called, it will error out.
Companion interface to <em class=code>init_conditions()</em>.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>time&nbsp;&nbsp;&nbsp;</em></TD>
    <TD>Initial model time.</TD></TR>

</TABLE>

</div>
<br />

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="init_conditions"></A>
<br />
<div class=routine>
<em class=call>call init_conditions(x)</em>
<pre>
real(r8), dimension(:), intent(out) :: <em class=code>x</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
DART/GCOM is not configured to start up from arbitrary initial conditions
so <em class=code>init_conditions()</em> is not supported.
<em class=code>init_conditions()</em> is only called if the namelist 
parameter <em class=code>start_from_restart = .false.</em>.
Should <em class=code>init_conditions()</em> be called, it will error out.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>x&nbsp;&nbsp;&nbsp;</em></TD>
    <TD>Initial conditions for state vector.</TD></TR>

</TABLE>

</div>
<br />

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="nc_write_model_atts"></A>
<br />
<div class=routine>
<em class=call>ierr = nc_write_model_atts(ncFileID)</em>
<pre>
integer             :: <em class=code>nc_write_model_atts</em>
integer, intent(in) :: <em class=code>ncFileID</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
This routine is used to create the DART diagnostic files.
It writes the model-specific attributes and metadata to a netCDF file, 
but NOT the model state vector. Basically, all the static data is
written to the netCDF file in <em class=code>nc_write_model_atts()</em>
and all the dynamic data is written (as it is created) in
<em class=code>nc_write_model_vars()</em>.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>ncFileID&nbsp;&nbsp;&nbsp;</em></TD>
    <TD>Integer file descriptor to previously-opened netCDF file.</TD></TR>

<TR><TD valign=top><em class=code>ierr</em></TD>
    <TD>Returns a 0 for successful completion.</TD></TR>

</TABLE>

</div>
<br />

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="nc_write_model_vars"></A>
<br />
<div class=routine>
<em class=call>ierr = nc_write_model_vars(ncFileID, statevec, copyindex, timeindex)</em>
<pre>
integer                            :: <em class=code>nc_write_model_vars</em>
integer,                intent(in) :: <em class=code>ncFileID</em>
real(r8), dimension(:), intent(in) :: <em class=code>statevec</em>
integer,                intent(in) :: <em class=code>copyindex</em>
integer,                intent(in) :: <em class=code>timeindex</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
<em class=code>nc_write_model_vars()</em>.
writes the model-specific state vector (data) to a netCDF file.
As the state vector evolves with every assimilation,
the new state is appended to the netCDF file contents. 
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>ncFileID</em></TD>
    <TD>file descriptor to previously-opened netCDF file.</TD></TR>

<TR><TD valign=top><em class=code>statevec</em></TD>
    <TD>A model state vector.</TD></TR>

<TR><TD valign=top><em class=code>copyindex&nbsp;&nbsp;&nbsp;</em></TD>
    <TD>Integer index of copy to be written. Each ensemble member has 
        a unique index, as does the ensemble mean, spread, inflation ...</TD></TR>

<TR><TD valign=top><em class=code>timeindex</em></TD>
    <TD>The timestep counter for the given state.</TD></TR>

<TR><TD valign=top><em class=code>ierr</em></TD>
    <TD>Returns 0 for normal completion.</TD></TR>

</TABLE>

</div>
<br />

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="pert_model_state"></A>
<br />
<div class=routine>
<em class=call>call pert_model_state(state, pert_state, interf_provided)</em>
<pre>
real(r8), dimension(:), intent(in)  :: <em class=code>state</em>
real(r8), dimension(:), intent(out) :: <em class=code>pert_state</em>
logical,                intent(out) :: <em class=code>interf_provided</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
<em class=code>pert_model_state()</em> perturbs a single model state to 
create a new state. This is used to generate initial conditions for spinning 
up ensembles. <em>This routine needs work.</em> It currently simply adds zero 
mean gaussian noise to the input state without respect to the dynamic range 
of the variable in question or whether or not GCOM can tolerate the 
resulting state. The variance is set by
<em class=file>input.nml</em><em class=code>&amp;model_nml:model_perturbation_amplitude</em>.
<br />
<br />
<em class=code>pert_model_state()</em> is called when <em class=file>input.nml</em><em class=code>&amp;filter_nml</em>
<a href="../../filter/filter.html#Namelist">start_from_restart&nbsp;=&nbsp;.false.</a>&nbsp;.
<br />
In this case, a single restart file <strong>must exist</strong> and is specified in 
<em class=file>input.nml</em><em class=code>&amp;filter_nml</em>
<a href="../../filter/filter.html#Namelist">restart_in_file_name</a>&nbsp;.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>state</em></TD>
    <TD>State vector to be perturbed.</TD></TR>

<TR><TD valign=top><em class=code>pert_state</em></TD>
    <TD>Perturbed state vector.</TD></TR>

<TR><TD valign=top><em class=code>interf_provided&nbsp;&nbsp;&nbsp;</em></TD>
    <TD>Since <em class=code>pert_model_state()</em> actually creates a new
        perturbed state, <em class=code>interf_provided&nbsp;=&nbsp;.true.</em>.
        A value of <em class=code>.false.</em> would indicate that the
        default DART method should be used.</TD></TR>

</TABLE>

</div>
<br />

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="get_close_maxdist_init"></A>
<br />
<div class=routine>
<em class=call>call get_close_maxdist_init(gc, maxdist)</em>
<pre>
type(get_close_type), intent(inout) :: <em class=code>gc</em>
real(r8),             intent(in)    :: <em class=code>maxdist</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
In distance computations any two locations closer than the
given <em class=code>maxdist</em> will be considered close
by the <em class=code>get_close_obs()</em> routine.
Pass-through to the 3D Sphere locations module. See
<A HREF="../../location/threed_sphere/location_mod.html#get_close_maxdist_init">
get_close_maxdist_init()</A> for the documentation of this subroutine.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>gc</em></TD>
    <TD>The get_close_type which stores precomputed information
        about the locations to speed up searching.</TD></TR>

<TR><TD valign=top><em class=code>maxdist&nbsp;&nbsp;&nbsp;</em></TD>
    <TD>Anything closer than <em class=code>maxdist</em> radians will be 
        considered close.</TD></TR>

</TABLE>

</div>
<br />

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="get_close_obs_init"></A>
<br />
<div class=routine>
<em class=call>call get_close_obs_init(gc, num, obs)</em>
<pre>
type(get_close_type), intent(inout) :: <em class=code>gc</em>
integer,              intent(in)    :: <em class=code>num</em>
type(location_type),  intent(in)    :: <em class=code>obs(num)</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Precomputes information to accelerate the distance computations 
done by <em class=code>get_close_obs()</em>.
Pass-through to the 3D Sphere locations module. See
<A HREF="../../location/threed_sphere/location_mod.html#get_close_obs_init">
get_close_obs_init()</A> for the documentation of this subroutine.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>gc</em></TD>
    <TD>The get_close_type which stores precomputed information
        about the locations to speed up searching</TD></TR>

<TR><TD valign=top><em class=code>num</em></TD>
    <TD>The number of items in the third argument</TD></TR>

<TR><TD valign=top><em class=code>obs&nbsp;&nbsp;&nbsp;</em></TD>
    <TD>A list of locations which will be part
        of the subsequent distance computations</TD></TR>

</TABLE>

</div>
<br />

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="get_close_obs"></A>
<br />
<div class=routine>
<em class=call>call get_close_obs(gc, base_obs_loc, base_obs_kind,
  obs, obs_kind, num_close, close_ind
  <em class=optionalcode>[,&nbsp;dist]</em>) </em>
<pre>
type(get_close_type), intent(in)  :: <em class=code>gc</em>
type(location_type),  intent(in)  :: <em class=code>base_obs_loc</em>
integer,              intent(in)  :: <em class=code>base_obs_kind</em>
type(location_type),  intent(in)  :: <em class=code>obs(:)</em>
integer,              intent(in)  :: <em class=code>obs_kind(:)</em>
integer,              intent(out) :: <em class=code>num_close</em>
integer,              intent(out) :: <em class=code>close_ind(:)</em>
real(r8), optional,   intent(out) :: <em class=optionalcode>dist(:)</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Given a location and kind, compute the distances to all other locations 
in the <em class=code>obs</em> list.  The return values are the number
of items which are within maxdist of the base, the index numbers in the 
original obs list, and optionally the distances.  The <em class=code>gc</em>
contains precomputed information to speed the computations.
<br />
<br />
If distances are desired, "Dry" grid cells are modified to be far away 
from everything so they are not candidates for calculations. When it is 
confirmed that GCOM will never support a grid with dry grid cells, 
this may simply be a pass-through to the default 
<em class=code>get_close_obs()</em>.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>gc</em></TD>
    <TD>The <em class=code>get_close_type</em> which stores precomputed information
        about the locations to speed up searching</TD></TR>

<TR><TD valign=top><em class=code>base_obs_loc</em></TD>
    <TD>Reference location.  The distances will be computed
        between this location and every other location in the <em class=code>obs</em> list</TD></TR>

<TR><TD valign=top><em class=code>base_obs_kind&nbsp;&nbsp;&nbsp;</em></TD>
    <TD>The kind of <em class=code>base_obs_loc</em></TD></TR>

<TR><TD valign=top><em class=code>obs</em></TD>
    <TD>Compute the distance between the <em class=code>base_obs_loc</em> and each
        of the locations in this list</TD></TR>

<TR><TD valign=top><em class=code>obs_kind</em></TD>
    <TD>The corresponding kind of each item in the <em class=code>obs</em> list</TD></TR>

<TR><TD valign=top><em class=code>num_close</em></TD>
    <TD>The number of items from the <em class=code>obs</em> list
        which are within <em class=code>maxdist</em> of the base location</TD></TR>

<TR><TD valign=top><em class=code>close_ind</em></TD>
    <TD>The list of index numbers from the <em class=code>obs</em> list 
        which are within <em class=code>maxdist</em> of the base location</TD></TR>

<TR><TD valign=top><em class=optionalcode>dist</em></TD>
    <TD>If present, return the distance between each entry
        in the <em class=code>close_ind</em> list and the base location.  If not
        present, all items in the <em class=code>obs</em> list which are closer
        than <em class=code>maxdist</em> will be added to the list but the overhead
        of computing the exact distances will be skipped.</TD></TR>

</TABLE>

</div>
<br />

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="ens_mean_for_model"></A>
<br />
<div class=routine>
<em class=call>call ens_mean_for_model(ens_mean)</em>
<pre>
real(r8), dimension(:), intent(in) :: <em class=code>ens_mean</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
A model-size vector with the means of the ensembles for each of
the state vector items. The <em class=code>ens_mean</em> is updated 
after each model advance.
This is a stub for GCOM.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>ens_mean&nbsp;&nbsp;&nbsp;</em></TD>
    <TD>State vector containing the ensemble mean.</TD></TR>

</TABLE>

</div>
<P><!-- make sure the 'top' is aligned correctly --></P>

<!--==================================================================-->
<!-- list of all optional public interfaces                           -->
<!--==================================================================-->

<div class="top">[<a href="#">top</a>]</div><hr />
<H2>PUBLIC INTERFACES - Optional</H2>

<TABLE summary="list of all optional public interfaces">
<TR><TD><em class=call>use model_mod, only : </em></TD>
                   <TD><A HREF="#get_gcom_restart_filename">get_gcom_restart_filename</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#gcom_file_to_dart_vector">gcom_file_to_dart_vector</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#dart_vector_to_gcom_file">dart_vector_to_gcom_file</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#DART_get_var">DART_get_var</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#write_gcom_timeinfo">write_gcom_timeinfo</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#test_interpolation">test_interpolation</A></TD></TR>
</TABLE>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="get_gcom_restart_filename"></A>
<br />
<div class=routine>
<em class=call>call get_gcom_restart_filename( filename )</em>
<pre>
character(len=*), intent(out) :: <em class=code>filename</em>
</pre>
</div>
<div class=indent1>
<!-- Description -->
<P>
provides access to the name of the GCOM restart file to routines outside the
scope of this module.
</P>
<TABLE width=100% border=0 cellspacing=10 cellpadding=3 summary="">
<TBODY valign=top>
<TR><TD><em class=code>filename</em></TD>
    <TD>The name of the GCOM restart file.</TD></TR>
</TABLE>
</div>
<br />

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="gcom_file_to_dart_vector"></A>
<br />
<div class=routine>
<em class=call>call gcom_file_to_dart_vector(filename, state_vector, state_time)</em>
<pre>
character(len=*), intent(out)   :: <em class=code>filename</em>
real(r8),         intent(inout) :: <em class=code>state_vector(:)</em>
type(time_type),  intent(out)   :: <em class=code>state_time</em>
</pre>
</div>
<div class=indent1>
<!-- Description -->
<P>
Reads the current time and state variables from a GCOM netCDF
restart/output file and packs them into a DART state vector.
This MUST happen in the same fashion as the metadata arrays are built.
The variables are specified by <em class=code>model_nml:gcom_variables</em>.
If there are multiple times in the file of origin, only the LAST time is used.
<br />
<br />
</P>
<TABLE width=100% border=0 cellspacing=10 cellpadding=3 summary="">
<TBODY valign=top>
<TR><TD><em class=code>filename</em></TD>
    <TD>The name of the GCOM restart file. This is usually a static name
        that comes from the model namelist and the scripting usually
        successively links the unique filename to the static name.</TD></TR>
<TR><TD><em class=code>state_vector</em></TD>
    <TD>The DART state vector.</TD></TR>
<TR><TD><em class=code>restart_time</em></TD>
    <TD>The valid time of the GCOM state.</TD></TR>
</TABLE>
</div>
<br />

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="dart_vector_to_gcom_file"></A>
<br />
<div class=routine>
<em class=call>call dart_vector_to_gcom_file(state_vector, filename, statedate)</em>
<pre>
real(r8),         intent(in) :: <em class=code>state_vector(:)</em>
character(len=*), intent(in) :: <em class=code>filename</em>
type(time_type),  intent(in) :: <em class=code>statedate</em>
</pre>
</div>
<div class=indent1>
<!-- Description -->
<P>
<em class=code>dart_vector_to_gcom_file()</em> updates the GCOM restart file 
with the posterior state from the assimilation. Only those variables with the
<em class=code>UPDATE</em> specification in the 
<em class=code>&amp;model_nml:gcom_variables</em> input will be updated in the 
GCOM restart file. If there are any physical limits for these variables, they
are applied at this time.
<br /><br />
Some GCOM variables may be useful to include in the DART state
for the purpose of the forward observation operator are diagnostic 
quantities and are not used for subsequent model advances.
These diagnostic variables do not have to be updated.
</P>
<TABLE width=100% border=0 cellspacing=10 cellpadding=3 summary="">
<TBODY valign=top>
<TR><TD><em class=code>state_vector</em></TD>
    <TD>The DART state vector containing the state modified by the assimilation.</TD></TR>
<TR><TD><em class=code>filename</em></TD>
    <TD>The name of the GCOM restart file. <strong>The contents of some of the
        variables will be overwritten with new values.</strong></TD></TR>
<TR><TD><em class=code>statedate</em></TD>
    <TD>The valid time and date of the DART state.
        This time must match one of the times in the GCOM restart file.
        Only the variables at the matching time index are updated.
        </TD></TR>
</TABLE>
</div>
<br />


<!--===================== DESCRIPTION OF A ROUTINE =====================-->


<A NAME="DART_get_var"></A>
<br />
<div class=routine>
<em class=call>call DART_get_var(ncid, varname, datmat)</em>
<pre>
integer,                    intent(in)  :: <em class=code>ncid</em>
character(len=*),           intent(in)  :: <em class=code>varname</em>
real(r8), dimension(:),     intent(out) :: <em class=code>datmat</em> -or-
real(r8), dimension(:,:),   intent(out) :: <em class=code>datmat</em> -or-
real(r8), dimension(:,:,:), intent(out) :: <em class=code>datmat</em>
</pre>
</div>
<div class=indent1>
<!-- Description -->
<P>
Reads a 1D, 2D, or 3D variable of 'any' type from a netCDF file and processes
and applies the offset/scale/FillValue attributes correctly.
</P>
<TABLE width=100% border=0 cellspacing=10 cellpadding=3 summary="">
<TBODY valign=top>
<TR><TD><em class=code>ncid</em></TD>
    <TD>The netCDF file identifier to an open file.
        ncid is the output from a nf90_open() call.</TD></TR>
<TR><TD><em class=code>varname</em></TD>
    <TD>The name of the netCDF variable of interest.
        The variables can be integers, floats, or doubles. </TD></TR>
<TR><TD><em class=code>datmat</em></TD>
    <TD>The shape of datmat must match the shape of the
        netCDF variable. Only 1D, 2D, or 3D variables are currently
        supported.</TD></TR>
</TABLE>
</div>
<br />


<!--===================== DESCRIPTION OF A ROUTINE =====================-->


<A NAME="write_gcom_timeinfo"></A>
<br />
<div class=routine>
<em class=call>call write_gcom_timeinfo(current_time, forecast_stop_time)</em>
<pre>
type(time_type), intent(in) :: <em class=code>current_time</em>
type(time_type), intent(in) :: <em class=code>forecast_stop_time</em>
</pre>
</div>
<div class=indent1>
<!-- Description -->
<P>
Writes the time information necessary to correctly start and stop a GCOM
execution to a file (<em class=file>dart_gcom_timeinfo.txt</em>) that can 
then be used to update the GCOM <em class=file>param.dat</em> file.
<em class=file>dart_gcom_timeinfo.txt</em> has the same information in 
two formats - one if reading by a namelist, one for the historical GCOM
format.
<br />
<br />
<em class=program>advance_model.csh</em> reads from 
<em class=file>dart_gcom_timeinfo.txt</em> and updates 
<em class=file>param.dat</em>.
</P>
<TABLE width=100% border=0 cellspacing=10 cellpadding=3 summary="">
<TBODY valign=top>
<TR><TD><em class=code>current_time</em></TD>
    <TD>the current time of the model state.
        </TD></TR>
<TR><TD><em class=code>forecast_stop_time</em></TD>
    <TD>The time needed for the next assimilation.
        </TD></TR>
</TABLE>
</div>
<br />


<!--===================== DESCRIPTION OF A ROUTINE =====================-->


<A NAME="test_interpolation"></A>
<br />
<div class=routine>
<em class=call>call test_interpolation(test_casenum)</em>
<pre>
integer, intent(in) :: <em class=code>test_casenum</em>
</pre>
</div>
<div class=indent1>
<!-- Description -->
<P>
This is a stub routine that contains commented-out code to assist in
developing a better <em class=code>model_interpolate()</em> routine.
</P>
<TABLE width=100% border=0 cellspacing=10 cellpadding=3 summary="">
<TBODY valign=top>
<TR><TD><em class=code>test_casenum</em></TD>
    <TD>The identifier for which test to run.</TD></TR>
</TABLE>
</div>
<br />

<P><!-- make sure the 'top' is aligned correctly --></P>

<!--==================================================================-->
<!-- Describe the Files Used by this module.                          -->
<!--==================================================================-->

<A NAME="FilesUsed"></A>
<div class="top">[<a href="#">top</a>]</div><hr />
<H2>FILES</H2>

<TABLE width=100% border=0 cellspacing=10 cellpadding=3 summary="">
<TBODY valign=top>
<TR><TH align=left>filename</TH>
    <TH align=left>purpose</TH></TR>
<TR><TD>param.dat</TD>
    <TD>GCOM control file modified to control starting and stopping.</TD></TR>
<TR><TD>input.nml</TD>
    <TD>to read the model_mod namelist</TD></TR>
<TR><TD>gcom_restart.nc</TD>
    <TD>both read and modified by the GCOM model_mod</TD></TR>
<TR><TD>gcom_geometry.nc</TD>
    <TD>read by the GCOM model_mod for metadata purposes.</TD></TR>
<TR><TD>dart_log.out</TD>
    <TD>the run-time diagnostic output</TD></TR>
<TR><TD>dart_log.nml</TD>
    <TD>the record of all the namelists actually USED -
        contains the default values</TD></TR>
</TABLE>

<P><!-- make sure the 'top' is aligned correctly --></P>

<!--==================================================================-->
<!-- Cite references, if need be.                                     -->
<!--==================================================================-->

<A NAME="References"></A>
<div class="top">[<a href="#">top</a>]</div><hr />
<H2>REFERENCES</H2>
<ol>
<li> none at this time </li>
</ol>

<!--==================================================================-->
<!-- Describe all the error conditions and codes.                     -->
<!--==================================================================-->

<A NAME="Errors"></A>
<div class="top">[<a href="#">top</a>]</div><hr />
<H2>ERROR CODES and CONDITIONS</H2>
<P>
The GCOM <em class=code>model_mod</em> is an experimental interface under
active development. There are <strong>many</strong> routines that issue
warnings begging the user to confirm the result. Once these have been confirmed,
please send word back to me (Tim c/o  dart@ucar.edu) and I will happily incorporate
your comments and suggestions after our group performs our due dilligence
and has a 'code review'. The GCOM code has not undergone our group code review.
It will surely be improved when it does. Until then, I have tried to identify and
call attention to parts of the code that could use oversight. As such,
I will not attempt to list ALL of the error conditions here - just the ones I 
believe to be the most likely or perhaps are not perfectly clear from
the error message issued at runtime.
</P>

<div class=errors>
<TABLE border=1 cellspacing=1 cellpadding=3 width=100% summary="error situations">
<TR><TH>Routine</TH>
    <TH>Message</TH>
    <TH>Comment</TH></TR>
<TR><!-- routine --><TD> nc_write_model_atts<br />
                                    nc_write_model_vars</TD>
    <!-- message --><TD>Various netCDF-f90 interface error messages</TD>
    <!-- comment --><TD>From one of the netCDF calls in the named routine</TD>
    </TR>

<TR><!-- routine --><TD>init_conditions</TD>
    <!-- message --><TD>'WARNING!!  GCOM model has no built-in default state'...</TD>
    <!-- comment --><TD>GCOM cannot run with 'start_from_restart = .false.'</TD>
    </TR>

<TR><!-- routine --><TD>init_time</TD>
    <!-- message --><TD>'WARNING!!  GCOM model has no built-in default time'...</TD>
    <!-- comment --><TD>GCOM cannot run with 'start_from_restart = .false.'</TD>
    </TR>

<TR><!-- routine --><TD>adv_1step</TD>
    <!-- message --><TD>'GCOM model cannot be called as a subroutine; async cannot = 0'</TD>
    <!-- comment --><TD>GCOM is supported as a standalone executable.</TD>
    </TR>

<TR><!-- routine --><TD>parse_variable_table</TD>
    <!-- message --><TD>'input.nml &amp;model_nml:gcom_variables not fully specified'</TD>
    <!-- comment --><TD>GCOM is supported as a standalone executable.</TD>
    </TR>

<TR><!-- routine --><TD>fill_progvar</TD>
    <!-- message --><TD>'&amp;model_nml state_variable input error for ...'</TD>
    <!-- comment --><TD>The minimum and maximum values for the input 
                        variable are inconsistent.</TD>
    </TR>

<TR><!-- routine --><TD>gcom_file_to_dart_vector</TD>
    <!-- message --><TD>'no support for units of ...'</TD>
    <!-- comment --><TD>The time coordinate variable in the gcom_restart.nc file
                        uses a syntax that is not supported.</TD>
    </TR>

<TR><!-- routine --><TD>gcom_file_to_dart_vector</TD>
    <!-- message --><TD>'no support for data array of dimension ...'</TD>
    <!-- comment --><TD>DART/GCOM supports variables up to 3 dimensions for any
                        single time.  It would be easy to support variables of
                        higher dimensions, I do not believe GCOM currently has 
                        anything higher than 3 dimensions.</TD>
    </TR>

</TABLE>
</div>


<H2>KNOWN BUGS</H2>
<P>
none at this time
</P>

<!--==================================================================-->
<!-- Describe Future Plans.                                           -->
<!--==================================================================-->

<A NAME="FuturePlans"></A>
<div class="top">[<a href="#">top</a>]</div><hr />
<H2>FUTURE PLANS</H2>
<ol><li> As mentioned several times ... the entire DART/GCOM project will undergo
    a thorough code review once the interfaces to the GCOM code base have
    stabilized.</li>
<li>The <em class=code>model_interpolate()</em> routine must be rewritten.
    </li>
<li>The <em class=code>pert_model_state()</em> routine must be rewritten.
    </li>
<li>All routines with the comment 'FIXME' should be tested and fixed if necessary.
    </li>
<li>A parallel GCOM model advance is not yet supported.
    The <em class=program>run_filter.csh</em> script will need to be
    rewritten.
    </li>
</ol>

<!--==================================================================-->
<!-- PrivateComponents                                                -->
<!--==================================================================-->

<A NAME="PrivateComponents"></A>
<div class="top">[<a href="#">top</a>]</div><hr />
<H2>PRIVATE COMPONENTS</H2>
<P>
N/A
</P>

<!--==================================================================-->
<!-- Legalese & Metadata                                              -->
<!--==================================================================-->

<A NAME="Legalese"></A>
<div class="top">[<a href="#">top</a>]</div><hr />
<H2>Terms of Use</H2>

<P>
DART software - Copyright 2004 - 2013 UCAR.<br />
This open source software is provided by UCAR, "as is",<br />
without charge, subject to all terms of use at<br />
<a href="http://www.image.ucar.edu/DAReS/DART/DART_download">
http://www.image.ucar.edu/DAReS/DART/DART_download</a>
</P>

<TABLE border=0 cellpadding=0 width=100% summary="">
<TR><TD valign=top>Contact:       </TD><TD> Tim Hoar </TD></TR>
<TR><TD valign=top>Revision:      </TD><TD> $Revision$ </TD></TR>
<TR><TD valign=top>Source:        </TD><TD> $URL$ </TD></TR>
<TR><TD valign=top>Change Date:   </TD><TD> $Date$ </TD></TR>
<TR><TD valign=top>Change&nbsp;history:&nbsp;</TD><TD> try "svn&nbsp;log" or "svn&nbsp;diff" </TD></TR>
</TABLE>

<!--==================================================================-->

</BODY>
</HTML>
