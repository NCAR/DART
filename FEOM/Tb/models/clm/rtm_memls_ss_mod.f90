! This code is not protected by the DART copyright agreement.
!
! DART $Id$

module rtm_memls_ss_mod

use types_mod, only : digits12

implicit none
private

public :: ss_model

logical :: debug = .false.

contains

SUBROUTINE SS_MODEL(CTRL,FREQ,TETAD,Y,TB_UBC,AUX_INS,TB_OUT)

! -----------------------------------------------------------------------------
!
!     SOIL AND SNOW RADIATIVE TRANSFER MODEL
!
!     FORTRAN 90 VERSION OF MEMLS PROGRAM (ORIGINALLY WRITTEN IN MATLAB BY 
!     WIESMANN AND MATZLER TO COMPUTE BRIGHTNESS TEMPERATURES OF N-LAYERED 
!     SNOWPACKS) INTEGRATED WITH A SOIL RADIATIVE TRANSFER SCHEME.  THIS 
!     VERSION OF THE CODE IS SET UP TO PERFORM CALCULATIONS BASED ON DATA FROM
!     A SINGLE SNOWPACK AT THE FREQUENCIES AND ANGLES SPECIFIED IN THE INPUTS.  
!     IF THE NUMBER OF LAYERS SPECIFIED IN CTRL(1) IS ZERO, THEN THIS CODE
!     WILL COMPUTE THE BARE SOIL BRIGHTNESS TEMPERATURE
!
!     IN THE CURRENT VERSION, EACH SNOWPACK MUST HAVE THE SAME NUMBER OF LAYERS.
!
! ----------------------------------------------------------------------------
!
!     DESCRIPTION OF INPUTS AND OUTPUTS (SEE JOURNAL ENTRY 19 SEP 05)
!
!     THE CTRL VECTOR SPECIFIES NINE OVERALL RUN CONTROLS, NOT ALL OF WHICH 
!     ARE USED IN THIS MODEL.  CTRL=(N_LYRS, N_AUX_INS, N_SNOW_INS, N_FREQ)
!     THE FREQ AND TETAD VECTORS SPECIFY AT WHICH FREQUENCIES CALCULATIONS 
!       ARE TO BE DONE.
!     THE Y ARRAY SPECIFIES SNOW INPUTS.  THERE IS ONE ROW FOR EACH SNOW
!       LAYER SPECIFIED IN CTRL(1), ONE COLUMN SPECIFIED FOR EACH SNOW
!       VARIABLE,IN ORDER: LAYER THICKNESS [M], LAYER DENSITY [KG/M3],
!       LAYER *specific* GRAIN DIAMETER [M], LAYER LIQUID WATER CONTENT [FRAC],
!       LAYER TEMPERATURE [K].
!     THE TB_UBC ARRAY SPECIFIES THE UPPER BOUNDARY CONDITION BRIGHTNESS
!       TEMPERATURE (SKY, VEGETATION, COSMIC).  IT HAS TWO ROWS (FOR H AND V
!       POLARIZATION) AND CTRL(4) COLUMNS: ONE FOR EACH FREQUENCY.
!     THE AUX_INS ARRAY SPECIFIES SOME AUXILIARY INPUTS.  THESE INCLUDE (IN 
!       ORDER): N_LYRS, SOIL TEMPERATURE [K], SOIL SATURATION [FRAC], SOIL
!       POROSITY [FRAC], AND THE CONSTANT OF PROPORTIONALITY BETWEEN THE 
!       GRAIN SIZE AND THE CORRELATION LENGTH.
!
!     THE TB_OUT ARRAY CONTAINS THE CALCULATED BRIGHTNESS TEMPERATURE OUTPUTS
!       AT EACH POLARIZATION (ROWS) AND FREQUENCY (COLUMNS).
!
!     *modified 2 July 2013 by Ally Toure to use specific grain diameter instead of
!     measured grain diameter.
!            
! ----------------------------------------------------------------------------
!
!     1.DESCRIPTION.  THE CODE IS A TRANSLATION OF THE MEMLS2 CODE RECEIVED 
!     THROUGH CORRESPONDENCE WITH MATZLER AND A SOIL RADIATIVE TRANSFER
!     MODEL RECEIVED THROUGH CORRESPONDENCE WITH PULLIAINEN SOMETIME IN 2003.
!     THE MEMLS CODE USES THE GROUND REFLECTIVITY AND THE SNOWPACK DATA TO 
!     COMPUTE THE BRIGHTNESS TEMPERATURE OF THE SNOWPACK. THE CODE WAS 
!     TRANSLATED TO FORTRAN IN ORDER  TO SAVE COMPUTATION TIME IN A DATA 
!     ASSIMILATION SCHEME IN WHICH MILLIONS OF CALLS MUST BE MADE TO THE 
!     RADIATIVE TRANSFER MODEL .  IN TESTS, ONE HUNDRED BRIGHTNESS TEMPERATURE
!     CALCULATIONS TOOK TEN TIMES LESS PROCESSOR TIME IN THIS FORTRAN VERSION 
!     THAN IN THE ORIGINAL MATLAB.  EXTENSIVE VERIFICATION WAS PERFORMED USING
!     SNOWPIT DATA FOR NINE DAYS IN ONE WINTER DURING THE CLPX PROGRAM AS WELL
!     AS 3-LAYER SNOWMODEL RESULTS FROM THE MODIFIED SAST (SUN ET AL, 99 IN 
!     IN JGR) + SSIB MODEL RUN AT MAMMOTH MOUNTAIN, TO ENSURE THAT THE FORTRAN
!     CODE PRODUCES IDENTICAL RESULTS AS THE MATLAB CODE.
!
!     2. MODIFICATION.  THE MAIN CHANGE MADE TO THE MEMLS CODE IN THE 
!     TRANSLATION PROCESS WAS THAT THE VAN POLDER APPROXIMATION (EFFECTIVE 
!     MIXING THEORY) WAS  NO LONGER BEING USED IN THE MATLAB CODES WHEN I 
!     RECEIVED THEM.  IN FACT, THE REAL PART OF THE SNOW DIELECTRIC WAS USED 
!     INSTEAD IN SEVERAL SUBROUTINES. THIS WAS SLIGHTLY INCONSISTENT WITH THE 
!     PAPERS, SO (FOLLOWING MATZLER'S ADVICE VIA EMAIL) I WROTE A NEW 'POLDER' 
!     SUBROUTINE WHICH USES THE NEWTON-RAPHSON APPROXIMATION TO SOLVE FOR THE 
!     SNOW EFFECTIVE PERMITTIVITY - SEE MATZLER'S 1996 PAPER IN IEEE FOR THE 
!     EQUATIONS AND THE SUBROUTINE COMMENTS BELOW.  ACCORDING TO COMPARISON 
!     WITH THE SNOWPIT DATA RESULTS, THE EFFECT OF USING THE SNOW DIELECTRIC 
!     INSTEAD OF EFFECTIVE PERMITTIVITY ON THE BRIGHTNESS TEMPREATURE WAS 
!     MINIMAL (~0.1 DEGREE).  HOWEVER, BECAUSE I COULD NOT TEST WITH A MORE 
!     EXTENSIVE DATASET, I LEFT THE SLIGHTLY MORE COMPUTATIONALLY EXPENSIVE 
!     EFFECTIVE PERMITTIVITY CALCULATION IN PLACE FOR THE SAKE OF INTERNAL 
!     CONSISTENCY.
!
!     ANOTHER CHANGE THAT I MADE TO MEMLS WAS TO SET UP THE PROGRAM TO PASS IN 
!     SNOW GRAIN DIAMETER SINCE THIS IS USUALLY WHAT IS MEASUSRED IN SNOWPITS 
!     AND MODELED BY PROGNOSTIC EQUATIONS IN SNOW MODELS.  THE CONSTANT OF 
!     PROPORTIONALITY BETWEEN THE GRAIN DIAMETER AND THE CORRELATION LENGTH (SEE
!     MATLZER, 2002 IN JOURNAL OF GLACIOLOGY) IS ALSO PASSED IN.  
!
!     A THIRD CHANGE I MADE TO MEMLS WAS TO USE A SWITCH TO DETERMINE WHETHER 
!     THE BORN APPROXIMATION OR THE EMPIRICAL SCATTERING COEFFICIENT WOULD BE 
!     USED.  IF THE MAXIMUM CORRELATION LENGTH IN THE SNOWPACK IS GREATER THAN 
!     0.33 MM, THE BORN APPROXIMATION IS USED; OTHERWISE, THE EMPIRICAL FORMULA
!     IS USED.
!
!     HISTORY
!       1.0  - ORIGINAL TRANSLATION - MD 11/2005          
!       2.0  - ADDED SUPPORT FOR SUCCESSIVE COHERENT LAYERS - MD & JG 4/2011

IMPLICIT NONE

! 0.  PRELIMINARIES
!  A. DECLARATIONS
!   0.INPUTS AND OUTPUTS

INTEGER,INTENT(IN) :: CTRL(4)
REAL,   INTENT(IN) :: AUX_INS(5),TB_UBC(2,CTRL(4)),FREQ(CTRL(4)),TETAD(CTRL(4))
REAL,   INTENT(IN) :: Y(CTRL(1),CTRL(3))
REAL,   INTENT(OUT):: TB_OUT(2,CTRL(4))

!   1.FOR PART 1
REAL, DIMENSION(:), ALLOCATABLE :: SNOWDATA,TI,WIFR,ROIKG,DI,GDI,&
ROI,GDIMM,PCI,EPSI,EPSII,GAI,NS,TEI,DEI,SIH,SIV
REAL,DIMENSION(:), ALLOCATABLE :: XNUM,XROI,XEPSI,XEPSII,XTEI,&
XSIH,XSIV,XDI,XDEI,XTI,XPCI,XWIFR,XGAI
REAL,DIMENSION(:), ALLOCATABLE :: RROI,REPSI,REPSII,RTEI,RSIH,&
RSIV,RDI,RDEI,RTI,RPCI,RWIFR,RGAI
REAL :: GND_SIG,GND_EPS,MJU0,EPS0,PI,TGS,SNGDPCI,TSKYH,&
TSKYV,SASTPOROS,TETA,SOILSATURATION,GND_TEMP,GND_MV,MAXPCI,&
VEG_HEIGHT,VEG_TEMP,MG,S,NDL_THK,NDL_LGTH,NDL_NUM,T0,P0,MOIST0
INTEGER :: SCCHO,I,NUM,NFREQ,K,RNUM,MONTH,VEG_SWITCH,ATM_SWITCH
!   2.FOR PART 2
REAL :: EPS_T,TETAD_SOIL,EPS_B
COMPLEX, DIMENSION(:), ALLOCATABLE :: EPSR
COMPLEX :: EPS_UPPER
REAL :: KSIG,S0H,S0V

!   3.FOR PART 3
REAL,DIMENSION(:),ALLOCATABLE :: GBIH,GBIV,GS6,GA2I,TSCAT,&
  RSIHLONG,RSIVLONG
!   4.FOR PART 4
REAL,DIMENSION(:),ALLOCATABLE :: RI,TRI,DH,DV
!REAL TSG_H,TSG_V,ESG_H,ESG_V

!   5.FOR PART 5
COMPLEX :: EVEG,ESW
REAL :: TCAN_V,TCAN_H,CAN_LOSS_H,CAN_LOSS_V,EFSG_H,EFSG_V,TFSG_H,&
  TFSG_V,TATM,ATM_TRAN,TAFSG_H,TAFSG_V

integer :: pixel,replicate,rank,meas !dummy arguments for outputting

real, allocatable, dimension(:) :: ice_frac

!  B. CONTROL STATEMENTS 

if ( debug ) then
   write(*,*)'ss_model:    ctrl ',ctrl
   write(*,*)'ss_model:    freq ',freq
   write(*,*)'ss_model:   tetad ',tetad
   write(*,*)'ss_model:       y ',y
   write(*,*)'ss_model:  tb_ubc ',tb_ubc
   write(*,*)'ss_model: aux_ins ',aux_ins
endif

NFREQ=CTRL(4)  ! THIS CODE LOOPS OVER THE NUMBER OF FREQUENCIES FOR ONE SET
               ! OF SNOW PROPERTIES.
!NUM=aux_ins(1) ! NUMBER OF LAYERS IN THE SNOWPACK 
NUM=ctrl(1) ! NUMBER OF LAYERS IN THE SNOWPACK 

!  C. ALLOCATE AND EXTRACT STATEMENTS

ALLOCATE(DI(1:NUM),ROIKG(1:NUM),GDI(1:NUM),WIFR(1:NUM),TI(1:NUM))

DI(   1:NUM)   = Y(1:NUM,1)    ! snow thickness
ROIKG(1:NUM)   = Y(1:NUM,2)    ! snow density
GDI(  1:NUM)   = Y(1:NUM,3)    ! specific grain diameter (need in microns) XX.YYYYE-06
WIFR( 1:NUM)   = Y(1:NUM,4)    ! liquid water fraction
TI(   1:NUM)   = Y(1:NUM,5)    ! snow temperature

GND_TEMP       = AUX_INS(2)    ! Ground temperature
SOILSATURATION = AUX_INS(3)    ! soil saturation
SASTPOROS      = AUX_INS(4)    ! soil porosity (fraction)
SNGDPCI        = AUX_INS(5)    ! proportionality constant

GND_MV=SOILSATURATION*SASTPOROS

! A.1. DEFINE CONSTANTS
! TJH these must be before the bare ground calculation.
MJU0    = 1.2566e-006
GND_SIG = 0.002
GND_EPS = 0
EPS0    = 8.8542e-012
PI      = 3.14159

!  1. CHECK TO MAKE SURE THERE IS SNOW.  OTHERWISE DEAL WITH SOIL ONLY 
!     NOTE: AUX_INS(1) CONTAINS 0 IN THE CASE OF NO SNOW, THOUGH NUM
!     WILL BE 1 TO AVOID INCORRECT ARRAY ALLOCATIONS
IF (AUX_INS(1).EQ.0) THEN
  DO K=1,NFREQ
    ! THERE IS NO SNOWPACK, SO COMPUTE REFLECTIVITY OF GROUND AND OBTAIN
    ! OUTPUT BRIGHTNESS TEMPERATURES
    EPS_T=1.
    TETAD_SOIL=TETAD(K)
    EPS_UPPER=1.0003 !DIELECTRIC PERMITTIVITY OF AIR

    KSIG=REAL(2*PI*FREQ(K)*1E9*(MJU0*EPS0*EPS_UPPER)**0.5)*GND_SIG
    CALL RUFFSOIL(FREQ(K)*1E9,GND_MV,GND_TEMP,KSIG,TETAD_SOIL,&
      EPS_UPPER,S0H,S0V)

    TSKYH=TB_UBC(1,K)
    TSKYV=TB_UBC(2,K)

    TB_OUT(1,K)=(1-S0H)*GND_TEMP+S0H*TSKYH
    TB_OUT(2,K)=(1-S0V)*GND_TEMP+S0V*TSKYV
  END DO

  RETURN !TO MAIN PROGRAM

END IF

! 2. COMPUTE BRIGHTNESS TEMPERATURE OF SNOWPACK AND SOIL

DO K=1,NFREQ

  !  A. PRELIMINARIES 

  !  A.2. ALLOCATE AND UNIT CONVERSION STATEMENTS
  ALLOCATE(ROI(1:NUM),GDIMM(1:NUM),PCI(1:NUM),ice_frac(1:NUM))
  
  ROI  = ROIKG/1000.0
  TETA = TETAD(K)*PI/180.0

  ! ice_frac = snow_density/ice_density
  ice_frac(:) = ROI(:) / 0.917

  ! Original correlation length used GDI as 'measured' grain diameter (Dmax).
  ! Code modified 2 July 2013 to use 'effective' grain diameter. TJH 
  ! FIXME ... there may be a better algorithm for correlation length.

  GDIMM(:) = GDI*1000 ! TJH meters to millimeters

 !PCI(:)   =        GDIMM * SNGDPCI
  PCI(:)   = 0.50 * GDIMM * (1.0 - ice_frac)
 !PCI(:)   = 0.67 * GDIMM * (1.0 - ice_frac)
 !PCI(:)   =        GDIMM * (1.0 - ice_frac)

  !ALLY - FIXME : pseudocode follows
  !if snowdensity>917kg/m3
  !   Set snowdensity = 917
  !   and
  !   Pci =0 %% correlation length
  !endif

  if ( debug ) then
     write(*,*)'ss_model: Specific grain size : GDIMM    ', GDIMM
     write(*,*)'ss_model: Snow density        : ROI      ', ROI
     write(*,*)'ss_model: ice fraction        : ice_frac ', ice_frac
     write(*,*)'ss_model: Correlation length  : PCI      ', PCI
  endif

  deallocate(ice_frac)

  !  A.3. DETERMINE WHICH SCATTERING COEFFICIENT COMPUTATION METHOD TO 
  !  USE THE VALUE OF 0.33 USED HERE FROM PERSONAL CORRESPONDENCE WITH 
  !  MATZLER 

  MAXPCI=MAXVAL(PCI)
  IF (MAXPCI<0.33) THEN
    SCCHO=1 ! USE EMPIRICAL SCATTERING COEFFICIENT FROM W&M 99
  ELSE 
    SCCHO=2 ! USE BORN APPROXIMATION FROM MATZLER AND WIESMANN 99
  ENDIF

!THIS OPTION OUGHT TO BE AUTOMATED:
!DURING MY WORK WITH SSIB3+MEMLS TO MODEL GBMR-7 TB, I NEEDED TO USE SCCHO=2
!SCCHO=2
!IN ORDER TO SAVE TIME FOR THE SYNTHETIC TESTS, HOWEVER, I USED SCCHO=1
  SCCHO=1

  ! B.  COMPUTE RADIATIVE TRANSFER PROPERTIES OF SNOW

  ALLOCATE(EPSI(1:NUM),EPSII(1:NUM),GAI(1:NUM),NS(1:NUM),&
    TEI(1:NUM+1),DEI(1:NUM),SIH(1:NUM),SIV(1:NUM),XROI(1:NUM),&
    XEPSI(1:NUM),XEPSII(1:NUM),XTEI(1:NUM+1),XSIH(1:NUM),&
    XSIV(1:NUM),XDI(1:NUM),XDEI(1:NUM),XTI(1:NUM),XPCI(1:NUM),&
    XWIFR(1:NUM),XGAI(1:NUM))


  CALL RO2EPSD(ROI,TI,FREQ(K),EPSI,EPSII,NUM,pixel,replicate,rank,meas,k)
  CALL MIXMOD(FREQ(K),TI,WIFR,EPSI,EPSII,NUM)
  CALL ABSCOEFF(EPSI,EPSII,TI,FREQ(K),WIFR,GAI,NUM)
  NS=EPSI**0.5
  TEI(1:NUM)=ASIN(SIN(TETA)/NS)
  TEI(NUM+1)=TETA
  CALL PFADI(TEI,DI,DEI,NUM)
  CALL FRESNELC(TEI,EPSI,SIH,SIV,NUM)

  CALL SLRED(NUM,ROI,EPSI,EPSII,TEI,SIH,SIV,DI,DEI,TI,PCI,WIFR,&
    GAI,FREQ(K),RNUM,XROI,XEPSI,XEPSII,XTEI,XSIH,XSIV,XDI,XDEI,&
    XTI,XPCI,XWIFR,XGAI,pixel,replicate,rank,meas)

  ALLOCATE(RROI(RNUM),REPSI(RNUM),REPSII(RNUM),&
    RTEI(RNUM+1),RSIH(RNUM),RSIV(RNUM),RDI(RNUM),&
    RDEI(RNUM),RTI(RNUM),RPCI(RNUM),RWIFR(RNUM),&
    RGAI(RNUM))

  DO I=1,RNUM
    RROI(I)=XROI(I)
    REPSI(I)=XEPSI(I)
    REPSII(I)=XEPSII(I)
    RSIH(I)=XSIH(I)
    RSIV(I)=XSIV(I)
    RDI(I)=XDI(I)
    RDEI(I)=XDEI(I)
    RTI(I)=XTI(I)
    RPCI(I)=XPCI(I)
    RWIFR(I)=XWIFR(I)
    RGAI(I)=XGAI(I)
  END DO
  DO I=1,RNUM+1
    RTEI(I)=XTEI(I)
  END DO

  ! C.  COMPUTE GROUND REFLECTIVITIES

  ALLOCATE(EPSR(1:RNUM))

  EPS_T=1.
  TETAD_SOIL=TETAD(K)

  DO I=RNUM,1,-1
    EPS_B=EPSI(I)
    CALL AOT(EPS_T,EPS_B,TETAD_SOIL)
    EPS_T=EPS_B
  END DO

  EPSR=CMPLX(REPSI,(-1*REPSII)) 
  EPS_UPPER=EPSR(1)

  KSIG=REAL(2*PI*FREQ(K)*1E9*(MJU0*EPS0*EPS_UPPER)**0.5)*GND_SIG
  CALL RUFFSOIL(FREQ(K)*1E9,GND_MV,GND_TEMP,KSIG,TETAD_SOIL,&
    EPS_UPPER,S0H,S0V)

  ! D.  COMPUTE SCATTERING COEFFICIENTS, REFLECTIVITIES AND 
  !     TRANSMISSIVITIES

  DEALLOCATE(RTEI,RDEI) ! BECAUSE THESE ARRAYS WILL CHANGE SIZES
  ALLOCATE(GBIH(RNUM),GBIV(RNUM),GS6(RNUM),GA2I(RNUM),&
    TSCAT(RNUM),RTEI(RNUM),RDEI(RNUM),RSIHLONG(RNUM+1),&
    RSIVLONG(RNUM+1))
     
  CALL SCCOEFF(RROI,RTI,RPCI,FREQ(K),RWIFR,RGAI,SCCHO,GBIH,GBIV,& 
    GS6,GA2I,RNUM,REPSI,REPSII,pixel,replicate,rank,meas)

  CALL PFADC(TETA,RDI,REPSI,GS6,RDEI,RTEI,TSCAT,RNUM)

  RSIHLONG(1)=S0H
  RSIHLONG(2:RNUM+1)=RSIH
  RSIVLONG(1)=S0V
  RSIVLONG(2:RNUM+1)=RSIV
  CALL POLMIX(TSCAT,RSIHLONG,RSIVLONG,RNUM)

  ! E.  COMPUTE BRIGHTNESS TEMPERATURES AND EMISSIVITIES OF SNOWPACK AND 
  !       GROUND

  ALLOCATE(RI(1:RNUM),TRI(1:RNUM),DH(1:RNUM),DV(1:RNUM))

  TSKYH=TB_UBC(1,K)
  TSKYV=TB_UBC(2,K)

  CALL RT(GA2I,GBIH,DEI,RI,TRI,RNUM)
  CALL LAYER(RI,RSIHLONG,TRI,RTI,GND_TEMP,TSKYH,DH,RNUM)

  TB_OUT(1,K)=(1-RSIHLONG(RNUM+1))*DH(RNUM)+RSIHLONG(RNUM+1)*TSKYH
  CALL RT(GA2I,GBIV,RDEI,RI,TRI,RNUM)
  CALL LAYER(RI,RSIVLONG,TRI,TI,GND_TEMP,TSKYV,DV,RNUM)
  TB_OUT(2,K)=(1-RSIVLONG(RNUM+1))*DV(RNUM)+RSIVLONG(RNUM+1)*TSKYV

! CALL EMISSIVITY(GA2I,GBIH,GBIV,RDEI,RSIHLONG,RSIVLONG,GND_TEMP,RTI,&
!   ESG_H,ESG_V,RNUM)
 
  ! F.  DEALLOCATE VARIABLE SPACE

  DEALLOCATE(ROI,GDIMM,PCI,EPSI,& 
    EPSII,GAI,NS,TEI,DEI,SIH,SIV,EPSR,GBIH,GBIV,GS6,GA2I,TSCAT,&
    RSIHLONG,RSIVLONG,RI,TRI,DH,DV)

  DEALLOCATE(RROI,REPSI,REPSII,RTEI,RSIH,RSIV,RDI,RDEI,RTI,RPCI,RWIFR,RGAI,&
    XROI,XEPSI,XEPSII,XTEI,XSIH,XSIV,XDI,XDEI,XTI,XPCI,XWIFR,XGAI)

END DO

END SUBROUTINE SS_MODEL


! -------------------------------------------------------------------------
!
SUBROUTINE ABSCOEFF(EPSI,EPSII,TI,FREQ,WIFR,GAI,NUM)
!
! -------------------------------------------------------------------------
!
!   CODE ORIGINALLY OBTAINED IN MATLAB FROM MATZLER
!
!   COMPUTES THE ABSORPTION COEFFICIENT FROM THE DIELECTRIC PROPERTIES   
!
!
!   [GAI] = ABSCOEFF(EPSI,EPSII,TI,FREQ,WI)
!       GAI:   ABSORPTION COEFFICIENT [M^-1]
!       EPSI:  REAL PART DIEL
!       EPSII: IMAGINARY PART DIEL
!       TI:    PHYSICAL TEMPERATURE
!       FREQ:  FREQUENCY [GHZ]
!       WI:    VOLUMETRIC LIQUID WATER CONTENT
!
!   VERSION HISTORY:
!      1.0    WI 15.7.95
!      1.1    WI 12.11.97 MORE PRECISE FORMULA FOR GAI USED
!      2.0    MD 1 APR 05 TRANSLATED TO FORTRAN FROM MATLAB
!
!   USES: NONE

IMPLICIT NONE

INTEGER, INTENT(IN)  :: NUM
REAL,    INTENT(IN)  :: EPSI(NUM),EPSII(NUM),TI(NUM),FREQ,WIFR(NUM)
REAL,    INTENT(OUT) :: GAI(NUM)

real(digits12) :: C,PI

real(digits12) :: part1,part2
real(digits12) :: numerator,denominator
integer :: i

C  = 2.99793_digits12
PI = 3.14159_digits12

! Must try alternative implementation of following (it over/underflows)
! GAI=((2*PI*10*FREQ)*EPSII)/(C*(EPSI-(EPSII**2/4*EPSI))**0.5)

do i = 1,NUM
   numerator   = 2.0_digits12 * PI * 10.0_digits12 * real(FREQ,digits12) * real(EPSII(i),digits12)
   part1       = (EPSII(i)**2.0/4.0_digits12)*EPSI(i)
   part2       = EPSI(i) - part1
   denominator = C * part2**0.5

   if ( debug ) then
      write(*,*)'abscoeff: i = ',i,' of ',NUM
      write(*,*)'abscoeff:           C ', C
      write(*,*)'abscoeff:        FREQ ', FREQ
      write(*,*)'abscoeff:        EPSI ', EPSI(i)
      write(*,*)'abscoeff:       EPSII ', EPSII(i)
      write(*,*)'abscoeff: numerator   ', numerator
      write(*,*)'abscoeff: part1       ', part1
      write(*,*)'abscoeff: part2       ', part2
      write(*,*)'abscoeff: denominator ', denominator
      write(*,*)'abscoeff: GAI is then ', numerator / denominator
   endif

   GAI(i) = numerator/denominator
enddo

! original form in matlab code: 
! gai = ((2*pi*10*freq).*epsii)./(c.*sqrt(epsi - (epsii.^2./4.*epsi)));

! original form in 32bit fortran code: 
! GAI=((2*PI*10*FREQ)*EPSII)/(C*(EPSI-(EPSII**2/4*EPSI))**0.5)

END SUBROUTINE ABSCOEFF


! -------------------------------------------------------------------------
!
SUBROUTINE AOT(EPS_T,EPS_B,TETAD_SOIL)
!
! -------------------------------------------------------------------------
!
!     CODE ORIGINALLY OBTAINED IN MATLAB FROM PULLIAINEN
!
!     FUNCTION FOR CALCULATING THE ANGLE OF TRANSMISSION 
!     IN THE CASE OF A PLANE BOUNDARY BETWEEN TWO
!     MEDIAS WITH COMPLEX PERMITTIVITIES
!     K. TIGERSTEDT/97
!
!   INPUT PARAMETERS:
!     EPS_T = TOP LAYER EPSILON_R [COMPLEX],
!     EPS_B = BOTTOM LAYER EPSILON_R [COMPLEX]
!     THETAD = INCIDENCE ANGLE [DEG]
!   OUTPUT:
!     KSID   = TRANSMISSION ANGLE IN BOTTOM LAYER [DEG]
!
!   VERSION HISTORY:
!      1.0    KT ?.?.97
!      2.0    MD 1 APR 05 TRANSLATED TO FORTRAN FROM MATLAB

IMPLICIT NONE

REAL, INTENT(IN) :: EPS_T,EPS_B
REAL, INTENT(INOUT) :: TETAD_SOIL
REAL THETA,KSI,PI
COMPLEX NUMERATOR,DENOMINATOR

PI=3.14159
THETA=TETAD_SOIL/180*PI
NUMERATOR=EPS_T**0.5*SIN(THETA)
DENOMINATOR=(EPS_B-EPS_T*(1-COS(THETA)**2))**0.5

KSI=ATAN(REAL(NUMERATOR)/REAL(DENOMINATOR))
TETAD_SOIL=KSI/PI*180

END SUBROUTINE AOT


! -------------------------------------------------------------------------
!
SUBROUTINE BORN(K,VFI,PCIMM,EPSI,EICE,GB6,GC6,GF6,GS6,NUM,pixel,replicate,&
   rank,meas)
!
! -------------------------------------------------------------------------
!
!   CODE ORIGINALLY OBTAINED IN MATLAB FROM MATZLER, MODIFIED BY MIKE... SEE 
!     VERSION HISTORY
!
!   CALCULATES THE SCATTERING COEFFICIENT USING BORN APPROXIMATION       
!
!   [GB6,GC6,GF6,GS6] = BORNA(K,VFI,PCI,EPSI,EICE,EPSEFF,KP)
!       GB6: 6-FLUX BACK SCATTERING COEFFICIENT 
!       GC6: 6-FLUX CROSS SCATTERING COEFFICIENT 
!       GF6: 6-FLUX FORWARD SCATTERING COEFFICIENT 
!       GS6: 6-FLUX SCATTERING COEFFICIENT 
!       K:   WAVE NUMBER
!       VFI: VOLUME FRACTION OF ICE
!       PCI: CORRELATION LENGTH
!       EPSI: DIELECTRIC CONSTANT OF SNOW
!       EICE: DIELECTRIC CONSTANT OF SNOW
!       EPSEFF: EFFECTIVE PERMITTIVITY
!
!   VERSION HISTORY:
!      1.0     WI 27.05.98 
!      2.0     WI 31.03.05.  TRANSLATED TO FORTRAN BY MIKE.  BORNA AND 
!                             BORNSNK COMBINED INTO ONE.  CALL TO POLDER
!                             IS USED TO COMPUTE EFFECTIVE PERMITTIVITY
!      3.0    MD  1 APR 05 TRANSLATED TO FORTRAN FROM MATLAB
!      3.1    MD 22 DEC 11 Added Unity,NegUnity variables to prevent compiler warnings
!
!   USES:
!     
!   COPYRIGHT (C) 1998 BY THE INSTITUTE OF APPLIED PHYSICS, 
!   UNIVERSITY OF BERN, SWITZERLAND

IMPLICIT NONE

INTEGER, INTENT(IN) :: NUM
REAL, INTENT(IN) :: K,VFI(NUM),PCIMM(NUM),EPSI(NUM),EICE
REAL, INTENT(OUT) :: GB6(NUM),GC6(NUM),GF6(NUM),GS6(NUM)
REAL,DIMENSION(:),ALLOCATABLE :: PCI,A,A3,EA,EA3,K1,K3,KP,MUC,AA,XX,BB,BT,BF,&
  BTOT, EPSEFF,NEGMUC
Real,Parameter,Dimension(1) :: Unity=1.,NegUnity=-1.
INTEGER STEPS,ROW,ARG_LENGTH(2),I

integer,intent(in) :: pixel,replicate,rank,meas

ALLOCATE( PCI(NUM),A(NUM),A3(NUM),EA(NUM),EA3(NUM),K1(NUM),K3(NUM),KP(NUM),&
       MUC(NUM),AA(NUM),XX(NUM),BB(NUM),BT(NUM),BF(NUM),BTOT(NUM),&
       EPSEFF(NUM),NEGMUC(NUM) )
  
! 0)  CONSTANTS AND CONVERSION
STEPS=11
PCI=PCIMM*0.001

! 1)  COMPUTE FIELD FACTOR AND DEPOLARIZATION RATIO, FROM BORNSNK
!     'A' AFTER NOTE 10, MATZLER 1997, COMMENT AND CALL FROM BORNSNK
CALL SNOWAO(VFI,A,NUM)

! 2)  COMPUTE EFFECTIVE PERMITTIVITY USING NEW FUNCTION POLDER.M

CALL POLDER(VFI,A,EICE,EPSI,EPSEFF,NUM)

! 3)  COMPUTE KP, THE SQUARED RATIO BETWEEN INTERNAL / EXTERNAL FIELDS
!     THIS CODE ORIGINALLY IN BORNSNK, STARTING AT LINE 41
A3=1-2*A
EA=EPSEFF*(1-A)+A
EA3=EPSEFF*(1-A3)+A3
K1=(EA/(EA+A*(EICE-1)))**2
K3=(EA3/(EA3+A3*(EICE-1)))**2
KP=(2*K1+K3)/3

! 4)  COMPUTE SCATTERING COEFFICIENTS, FROM BORNA, STARTING AT LINE 34

!NOTE: THE NEXT LINE CONSISTENT WITH MATZLER AND WIESMANN 99 PAPER EQUATION (7).
!  BASED ON CORRESPONDENCE WITH MATZLER, EPSEFF=N^2

MUC=((EPSEFF-1)/EPSEFF)**0.5      

AA=2*(PCI*K)**3*K*VFI*(1-VFI)*(EICE-1)**2*KP
XX=PCI*K*EPSI**0.5

! 5)  TRIPLE INTEGRATION 

!  A) BACKWARD SCATTERING
ARG_LENGTH=(/1, NUM/)
NEGMUC=-1.*MUC
!!!CALL INTEGRMUI(XX,MUC,1.,-1.,-1.*MUC,STEPS,NUM,BB,ARG_LENGTH)
!CALL INTEGRMUI(XX,MUC,1.,-1.,NEGMUC,STEPS,NUM,BB,ARG_LENGTH) !Orig: 22 Dec
CALL INTEGRMUI(XX,MUC,1.,NegUnity,NEGMUC,STEPS,NUM,BB,ARG_LENGTH) !MDrev
!  B) TRANSVERSE SCATTERING 
ARG_LENGTH=(/NUM, NUM/)
!CALL INTEGRMUI(XX,MUC,1.,-1.*MUC,MUC,STEPS,NUM,BT,ARG_LENGTH)
CALL INTEGRMUI(XX,MUC,1.,NEGMUC,MUC,STEPS,NUM,BT,ARG_LENGTH)
!  C) FORWARD SCATTERING   
ARG_LENGTH=(/NUM, 1/)
!CALL INTEGRMUI(XX,MUC,1.,MUC,1.,STEPS,NUM,BF,ARG_LENGTH) !Orig: 22 Dec 11
CALL INTEGRMUI(XX,MUC,1.,MUC,Unity,STEPS,NUM,BF,ARG_LENGTH)

! 6)  CALCULATION OF SCATTERING COEFFICIENTS

BTOT=BB+BT+BF
GB6=AA*BB
GC6=0.25*AA*BT
GF6=AA*BF
GS6=AA*BTOT

DEALLOCATE( PCI,A,A3,EA,EA3,K1,K3,KP,MUC,AA,XX,BB,BT,BF,BTOT, EPSEFF,NEGMUC)

END SUBROUTINE BORN


! -------------------------------------------------------------------------
!
SUBROUTINE EMISSIVITY(GA2I,GBIH,GBIV,DEI,SIHLONG,SIVLONG,GND_TEMP,TI,&
                        EH,EV,NUM)
!
! -------------------------------------------------------------------------
!
!  CODE ORIGINALLY OBTAINED IN MATLAB FROM MATZLER, MODIFIED BY MIKE. 
!    SEE VERSION HISTORY
!
!   CALCULATES THE SCATTERING COEFFICIENT USING BORN APPROXIMATION       
!
!       GA2I: ABSORPTION COEFFICIENT
!       GBIH: 2-FLUX SCATTERING COEFFICIENT, H POLARIZATION
!       GBIV: 2-FLUX SCATTERING COEFFICIENT, V POLARIZATION
!       DEI:  EFFECTIVE PATH LENGTH [M]
!       SIHLONG: LAYER INTERFACE REFLECTIVITY, H POLARIZATION
!       SIVLONG: LAYER INTERFACE REFLECTIVITY, V POLARIZATION
!       EH:   EMISSIVITY, H POLARIZATION
!       EV:   EMISSIVITY, V POLARIZATION
!
!   VERSION HISTORY:
!      1.0     MD 1 APR 05 THIS CODE WAS PART OF LMAIN.  I TRANSLATED TO 
!                 FORTRAN FROM MATLAB AND MOVED IT TO A SEPARATE SUBROUTINE.
!                 COMPARE WIESMANN AND MATZLER, 99 EQN (8)
!
!   USES: RT, LAYER
!     
!   COPYRIGHT (C) 1998 BY THE INSTITUTE OF APPLIED PHYSICS, 
!   UNIVERSITY OF BERN, SWITZERLAND

IMPLICIT NONE

INTEGER, INTENT(IN) :: NUM
REAL,INTENT(IN) :: GA2I(NUM),GBIH(NUM),GBIV(NUM),DEI(NUM),&
                     SIHLONG(NUM+1),SIVLONG(NUM+1),GND_TEMP,&
                     TI(NUM)
REAL,INTENT(OUT) :: EH,EV
REAL RI(NUM),TRI(NUM),DH(NUM),DV(NUM),TBH0,TBH100,TBV0,TBV100,TSKY

! HORIZONTAL BRIGHTNESS TEMPERATURES UNDER DIFFERENT TSKY VALS

CALL RT(GA2I,GBIH,DEI,RI,TRI,NUM)

TSKY=0.
CALL LAYER(RI,SIHLONG,TRI,TI,GND_TEMP,TSKY,DH,NUM)
TBH0=(1-SIHLONG(NUM+1))*DH(NUM)+SIHLONG(NUM+1)*TSKY

TSKY=100.
CALL LAYER(RI,SIHLONG,TRI,TI,GND_TEMP,TSKY,DH,NUM)
TBH100=(1-SIHLONG(NUM+1))*DH(NUM)+SIHLONG(NUM+1)*TSKY

! VERTICAL BRIGHTNESS TEMPERATUERS UNDER DIFFERENT TSKY VALS

CALL RT(GA2I,GBIV,DEI,RI,TRI,NUM)

TSKY=0.
CALL LAYER(RI,SIVLONG,TRI,TI,GND_TEMP,TSKY,DV,NUM)
TBV0=(1-SIVLONG(NUM+1))*DV(NUM)+SIVLONG(NUM+1)*TSKY

TSKY=100.
CALL LAYER(RI,SIVLONG,TRI,TI,GND_TEMP,TSKY,DV,NUM)
TBV100=(1-SIVLONG(NUM+1))*DV(NUM)+SIVLONG(NUM+1)*TSKY

! COMPUTE EMISSIVITIES
EH=1-(TBH100-TBH0)/100
EV=1-(TBV100-TBV0)/100

END SUBROUTINE EMISSIVITY


! -------------------------------------------------------------------------
!
SUBROUTINE EPSICE(TI,FREQ,EICE,NUM)
!
! -------------------------------------------------------------------------
!
!   CODE ORIGINALLY OBTAINED IN MATLAB FROM MATZLER
!
!   CALCULATES THE DIELECTRIC PERMITTIVITY OF ICE
!   AFTER HUFFORD, MITZIMA AND MATZLER
!
!   EICE = EPSICE(TI,FREQ)
!      EICE:  DIELECTRIC PERMITTIVITY OF ICE
!      TI:    TEMPERATURE IN K 
!      FREQ:  FREQUENCY IN GHZ
!
!   VERSION HISTORY:
!      1.0    WI 15.7.95
!      2.0    MD 1 APR 05 TRANSLATED TO FORTRAN FROM MATLAB
!   
!   USES: NONE
!
!   COPYRIGHT (C) 1997 BY THE INSTITUTE OF APPLIED PHYSICS, 
!   UNIVERSITY OF BERN, SWITZERLAND

IMPLICIT NONE

integer, intent(in)  :: num
real,    intent(in)  :: ti(num),freq
real,    intent(out) :: eice(num)

real(digits12) :: pp(num),b,b1,b2,db(num),beta(num),alpha(num)

pp    = (300.0_digits12/ti) - 1.0_digits12
b     = 335.25_digits12
B1    = 0.0207_digits12
B2    = 1.16E-11_digits12
db    = exp(-10.02_digits12 + 0.0364_digits12*(ti - 273.0_digits12))
beta  = ((b1*exp(b/ti))/(ti*(exp(b/ti)-1.0_digits12)**2))+b2*freq**2+db
alpha = (0.00504_digits12+0.0062_digits12*pp)*exp(-22.1_digits12*pp)
eice  = alpha/freq+beta*freq

end subroutine epsice


! -------------------------------------------------------------------------
!
SUBROUTINE EPSR(ROI,NUM,EPSI)
!
! -------------------------------------------------------------------------
!
!     CODE ORIGINALLY OBTAINED IN MATLAB FROM MATZLER
!
!   CALCULATES THE DIELECTRIC PERMITTIVITY FOR DRY SNOW FROM 
!   DENSITY .
!
!   EPSI = EPSR(ROI)
!       EPSI:  REAL PART OF DIELECTRIC PERMITTIVITY
!       ROI:   DENSITY G/CM^3
!
!   VERSION HISTORY:
!      1.0    WI 15.7.95
!      1.1    WI 23.9.97 ADDED LOOYENGA FOR SNOW DENSER THAN 0.4 G/CM^3
!      2.0    MD 1 APR 05 TRANSLATED TO FORTRAN FROM MATLAB
!
!   USES:
!       EPSICE
!
!   COPYRIGHT (C) 1997 BY THE INSTITUTE OF APPLIED PHYSICS, 
!   UNIVERSITY OF BERN, SWITZERLAND

IMPLICIT NONE

INTEGER, INTENT(IN)  :: NUM
REAL,    INTENT(IN)  :: ROI(NUM)
REAL,    INTENT(OUT) :: EPSI(NUM)

INTEGER :: I
REAL :: EHB, ESB
REAL,DIMENSION(:),ALLOCATABLE :: VFI

ALLOCATE(VFI(NUM))

VFI=ROI/0.917
EHB=0.99913
ESB=1.4759

DO I=1,NUM
  IF (ROI(I)<=0.4) THEN
    EPSI(I)=1+1.5995*ROI(I)+1.861*ROI(I)**3
  ELSE
    EPSI(I)=((1-VFI(I))*EHB+VFI(I)*ESB)**3
  END IF
END DO   

DEALLOCATE(VFI)

END SUBROUTINE EPSR


! -------------------------------------------------------------------------
!
SUBROUTINE EPSS(MV,T,F,EPSS_VAR)
!
! -------------------------------------------------------------------------
!
!     CODE ORIGINALLY OBTAINED IN MATLAB FROM PULLIAINEN
!
!     FUNCTION FOR CALCULATING EPSILON FOR SOIL USING FREQUENCY,
!     TEMPERATURE AND VOLUMETRIC SOIL MOSITURE. USES EPSW.M FOR
!     DIELECTRICITY OF WATER. 
!
!     BY J. PULLIAINEN (MOD. BY K. TIGERSTEDT) 
! 
!     MV [0..1]
!     T [C]
!     F [HZ]
!
!     NOTE: SOME FINNISH COMMENTS WERE NOT COPIED IN ENTIRETY -MD
!   VERSION HISTORY:
!      1.0    JP ?.?.?
!      1.1    KT ?.?.?
!      2.0    MD 1 APR 05 TRANSLATED TO FORTRAN FROM MATLAB

IMPLICIT NONE

REAL,INTENT(IN) :: MV,T,F
COMPLEX,INTENT(OUT) :: EPSS_VAR
REAL S,CLAY,RHOS,BETA,ALFA,REI,A,B,C,M,IEI_S,A_P,B_P,C_P,IEI_P,&
      DELTA_IEI,INVT,ALF,B_1,B_2,BB,BET_M,BET_DELTA,BET,IEI,SS,EW_R,EW_I
COMPLEX EW,EPSALF

S=0.4                          ! SAND FRACTION
CLAY=0.3                       ! CLAY FRACTION
RHOS=1.1                       ! DRY-MATTER DENSITY

BETA=1.09-0.11*S+0.18*CLAY
ALFA=0.65

IF(T>0)THEN
  CALL EPSW(F,T,EW_R,EW_I)
ELSE
  REI=3.1884+9.1E-4*T          ! MATZLER AND WEGMULLER 1987
  A=0.0026                     ! IMPURE ICE -5 ASTETTA (MATZLER)
  B=0.00023
  C=0.87
  M=F/1E9
  IEI_S=A/M+B*M**C
  A_P=6E-4                     ! PURE ICE -5 ASTETTA (MATZLER)
  B_P=6.5E-5
  C_P=0.7
  IEI_P=A_P/M+B_P*M**C_P
  DELTA_IEI=IEI_S-IEI_P

  ! HUFFORD 1991        
  INVT=300/(T+273)-1
  ALF=(0.00504+0.0062*INVT)*EXP(-22.1*INVT)

  ! (MISHIMA,MATZLER)
  B_1=0.0207
  B_2=1.16E-11
  BB=335
  BET_M=B_1/(T+273)*EXP(BB/(T+273))/(EXP(BB/(T+273))-1)**2+B_2*M**2
  BET_DELTA=EXP(-10.02+0.0364*T)
  BET=BET_M+BET_DELTA
  IEI=ALF/M+BET*M
  SS=10
  IEI=IEI+DELTA_IEI*SS/13
  EW_R=REI
  EW_I=IEI
END IF

EW=CMPLX(EW_R,(-1*EW_I))

EPSALF=1+0.65*RHOS+MV**BETA*(EW**ALFA-1)

EPSS_VAR=EPSALF**(1/ALFA) 

END SUBROUTINE EPSS


! -------------------------------------------------------------------------
!
SUBROUTINE EPSW(F,T,EW_R,EW_I)
!
! -------------------------------------------------------------------------
!
!     CODE ORIGINALLY OBTAINED IN MATLAB FROM PULLIAINEN
!
!     LASKEE PUHTAAN VEDEN EPSILONIN TAAJUUDEN F, 
!     L MP TILAN T FUNKTIONA
!     5.12.89 JPK; 17.2.1993 JP
!    VERSION HISTORY:
!      1.0    JPK 5.12.89 
!      1.1    JP 17.02.93
!      2.0    MD 1 APR 05 TRANSLATED TO FORTRAN FROM MATLAB
!
!     NOTE: ADDITIONAL COMMENTS IN FINNISH NOT COPIED HERE -MD

IMPLICIT NONE

REAL,INTENT(IN) :: F,T
REAL,INTENT(OUT) :: EW_R,EW_I
REAL S,E0,EW_INF,EW0,N,D,ALFA,SIGMA_25,SIGMA_VAR,TW,PI,SIGMA

PI=3.14159
S=0
E0=8.854E12
EW_INF=4.9
EW0=87.74-0.40008*T+9.398E-4*T**2+1.410E-6*T**3
N=0

D=25-T
ALFA=2.033E-2+1.266E-4*D+2.462E-6*D**2-S*(1.849E-5-2.551E-7*D+&
       2.551E-8*D**2)

SIGMA_25=S*(0.182521-1.46192E-3*S+2.09324E-5*S**2-1.28205E-7*S**3)
SIGMA=SIGMA_25*EXP(-D*ALFA)

TW=1/(2*PI)*(1.1109E-10-3.824E-12*T+6.938E-14*T*T-5.096E-16*T*T*T)

EW_R=EW_INF+(EW0-EW_INF)/(1+(2*PI*F*TW)**2)
EW_I=(EW0-EW_INF)*2*PI*F*TW/(1+(2*PI*F*TW)**2)+SIGMA/(2*PI*E0*F)

END SUBROUTINE EPSW


! -------------------------------------------------------------------------
!
SUBROUTINE FRESNELC(TEI,EPSI,SIH,SIV,NUM)
!
! -------------------------------------------------------------------------
!
!     CODE ORIGINALLY OBTAINED IN MATLAB FROM MATZLER
!
!   FRESNEL REFLECTION COEFFICIENTS (ASSUMING EPS'' = 0)
!     (LAYER N+1 IS THE AIR ABOVE THE SNOWPACK)
!
!   [SIH,SIV] = FRESNEL(TEI,ROI)
!       SIH:  INTERFACE REFLECTIVITY AT H POL
!       SIV:  INTERFACE REFLECTIVITY AT V POL
!       TEI:  LOCAL INCIDENCE ANGLE
!       EPSI: REAL PART OF DIELECTRIC PERMITTIVITY
!
!   VERSION HISTORY:
!      1.0    WI 15.7.97
!      2.0    MD 1 APR 05 TRANSLATED TO FORTRAN FROM MATLAB
!   
!   USES:
!       EPSR
!
!
!   COPYRIGHT (C) 1997 BY THE INSTITUTE OF APPLIED PHYSICS, 
!   UNIVERSITY OF BERN, SWITZERLAND

IMPLICIT NONE

INTEGER, INTENT(IN) :: NUM
REAL, INTENT(IN) :: TEI(NUM+1),EPSI(NUM)
!ctvs REAL, INTENT(OUT) :: SIH(NUM-1),SIV(NUM-1)
 REAL, INTENT(OUT) :: SIH(NUM),SIV(NUM)
INTEGER :: I
REAL EPSO,EPSU,TEIN
REAL,DIMENSION(:),ALLOCATABLE:: EPSI_LOCAL

ALLOCATE(EPSI_LOCAL(NUM+1))

EPSI_LOCAL(1:NUM)=EPSI
EPSI_LOCAL(NUM+1)=1

DO I=1,NUM
  EPSO=EPSI_LOCAL(I+1)
  EPSU=EPSI_LOCAL(I)
  TEIN=TEI(I+1)
  SIH(I)=((EPSO**0.5*COS(TEIN)-(EPSU-EPSO*SIN(TEIN)**2)**0.5)/&
          (EPSO**0.5*COS(TEIN)+(EPSU-EPSO*SIN(TEIN)**2)**0.5))**2
  SIV(I)=((EPSU*COS(TEIN)-EPSO**0.5*(EPSU-EPSO*SIN(TEIN)**2)**0.5)/&
          (EPSU*COS(TEIN)+EPSO**0.5*(EPSU-EPSO*SIN(TEIN)**2)**0.5))**2
END DO        

DEALLOCATE(EPSI_LOCAL)

END SUBROUTINE FRESNELC


! -------------------------------------------------------------------------
!
SUBROUTINE FRESNELRC(TEI,EPSI,FH,FV,NUM)
!
! -------------------------------------------------------------------------
!
!     CODE ORIGINALLY OBTAINED IN MATLAB FROM MATZLER
!
!
!   FRESNEL REFLECTION COEFFICIENTS (ASSUMING EPS'' = 0)
!     (LAYER N+1 IS THE AIR ABOVE THE SNOWPACK)
!
!   [FH,FV] = FRESNELRC(TEI,EPSR)
!       FH:   FRESNEL REFLECTION COEFFICIENT AT H POL
!       FV:   FRESNEL REFLECTION COEFFICIENT AT V POL
!       TEI:  LOCAL INCIDENCE ANGLE
!       EPSR: (REAL PART) DIELECTRIC PERMITTIVITY
!
!   VERSION HISTORY:
!      1.0    WI 15.7.95
!      2.0    MD 1 APR 05 TRANSLATED TO FORTRAN FROM MATLAB
!   
!   USES:
!
!
!
!   COPYRIGHT (C) 1997 BY THE INSTITUTE OF APPLIED PHYSICS, 
!   UNIVERSITY OF BERN, SWITZERLAND

IMPLICIT NONE

INTEGER,INTENT(IN) :: NUM
REAL,INTENT(IN) :: TEI(NUM+1),EPSI(NUM+1)
REAL,INTENT(OUT) :: FH(NUM),FV(NUM)
INTEGER N
REAL EPSN,TEIN,SINQ,QEPS,WURZ,WSUB,ND

DO N=1,NUM
  EPSN=EPSI(N)/EPSI(N+1)
  TEIN=TEI(N+1)
  SINQ=SIN(TEIN)**2
  QEPS=SINQ/EPSN
  WURZ=(1-QEPS)**0.5
  WSUB=EPSN-SINQ
  ND=EPSN**0.5
  
  FH(N)=((ND*WURZ-COS(TEIN))/(ND*WURZ+COS(TEIN)))
  FV(N)=((WURZ-ND*COS(TEIN))/(WURZ+ND*COS(TEIN)))
END DO             

END SUBROUTINE FRESNELRC


! -------------------------------------------------------------------------
!
SUBROUTINE GAMMAH(EPSS,THETA,GAMMAH_VAR)
!
! -------------------------------------------------------------------------
!
!     CODE ORIGINALLY OBTAINED IN MATLAB FROM PULLIAINEN
!
!    VERSION HISTORY:
!      1.0    JPK 5.12.89 
!      1.1    JP 17.03.93
!      2.0    MD 1 APR 05 TRANSLATED TO FORTRAN FROM MATLAB
!
!     NOTE: ADDITIONAL FINNISH COMMENTS NOT COPIED HERE

IMPLICIT NONE

REAL,INTENT(IN) :: THETA
COMPLEX,INTENT(IN) :: EPSS      
REAL,INTENT(OUT) :: GAMMAH_VAR
REAL THETA_RAD,PI,COSTHETA
COMPLEX NELIO

PI=3.14159
THETA_RAD=THETA/180*PI
COSTHETA=COS(THETA_RAD)
NELIO=SQRT(EPSS-SIN(THETA_RAD)**2)
GAMMAH_VAR=(ABS((COSTHETA-NELIO)/(COSTHETA+NELIO)))**2

END SUBROUTINE GAMMAH


! -------------------------------------------------------------------------
!
SUBROUTINE GAMMAV(EPSS,THETA,GAMMAV_VAR)
!
! -------------------------------------------------------------------------
!
!     CODE ORIGINALLY OBTAINED IN MATLAB FROM PULLIAINEN
!
!    VERSION HISTORY:
!      1.0    JPK 5.12.89 
!      1.1    JP 17.03.93
!      2.0    MD 1 APR 05 TRANSLATED TO FORTRAN FROM MATLAB
!
!     NOTE: ADDITIONAL FINNISH COMMENTS NOT COPIED HERE

IMPLICIT NONE

REAL,INTENT(IN) :: THETA
COMPLEX,INTENT(IN) :: EPSS      
REAL,INTENT(OUT) :: GAMMAV_VAR
REAL THETA_RAD,PI,COSTHETA
COMPLEX NELIO

PI=3.14159
THETA_RAD=THETA/180*PI
COSTHETA=COS(THETA_RAD)
NELIO=SQRT(EPSS-SIN(THETA_RAD)**2)
GAMMAV_VAR=(ABS((EPSS*COSTHETA-NELIO)/(EPSS*COSTHETA+NELIO)))**2

END SUBROUTINE GAMMAV


! -------------------------------------------------------------------------
!
SUBROUTINE INTEGRFI(XX,MUI,MUO,STEPS,INTEGR,NUM)
!
! -------------------------------------------------------------------------
!
!   CODE ORIGINALLY OBTAINED IN MATLAB FROM MATZLER
!
!   CALCULATES INTEGRATION  OVER INCIDENT DIRECTIONS, MUI
!       FROM MINI TO MAXI IN STEPS INTERVALS OF THE FI
!       PHASE FUNCTION.
!   
!
!   INTEGR = INTEGRFI(XX,MUI,MUO,STEPS)
!
!   VERSION HISTORY:
!      1.0     WI 27.05.98 
!      2.0    MD 1 APR 05 TRANSLATED TO FORTRAN FROM MATLAB
!      2.1    MD 21 NOV 05 CHANGED ALL LOCALS TO ALLOCATABLE
!
!   USES: - NONE
!     
!   COPYRIGHT (C) 1998 BY THE INSTITUTE OF APPLIED PHYSICS, 
!   UNIVERSITY OF BERN, SWITZERLAND

IMPLICIT NONE

INTEGER,INTENT(IN) :: NUM,STEPS
REAL, INTENT(IN) :: XX(NUM),MUI(NUM),MUO(NUM)
REAL, INTENT(OUT) :: INTEGR(NUM)
REAL PI,DELTA,FI,F0,COFI,SI2FI

INTEGER :: IFI

REAL,DIMENSION(:),ALLOCATABLE ::  X2,SII,SIO,COSTE,SI2CHI,FUNC

ALLOCATE( X2(NUM),SII(NUM),SIO(NUM),COSTE(NUM),SI2CHI(NUM),FUNC(NUM) )

PI=3.14159
DELTA=PI/STEPS
F0=0.5*DELTA
INTEGR=0
X2=2*XX**2

DO IFI=1,STEPS
  FI=F0+(IFI-1)*DELTA
  SII=(1-MUI**2)**0.5
  SIO=(1-MUO**2)**0.5
  COFI=COS(FI)
  SI2FI=1-COFI**2
  COSTE=MUI*MUO+SII*SIO*COFI
  SI2CHI=0.5*(1+COSTE**2)
  FUNC=SI2CHI/(1+(1-COSTE)*X2)**2
  INTEGR=INTEGR+FUNC*DELTA
END DO

INTEGR=INTEGR/PI

DEALLOCATE( X2,SII,SIO,COSTE,SI2CHI,FUNC )

END SUBROUTINE INTEGRFI


! -------------------------------------------------------------------------
!
SUBROUTINE INTEGRMUI(XX,MINI,MAXI,MINO,MAXO,STEPS,NUM,INTEGR,ARG_LENGTH)
!
! -------------------------------------------------------------------------
!
!     CODE ORIGINALLY OBTAINED IN MATLAB FROM MATZLER
!
!   CALCULATES INTEGRATION  OVER INCIDENT DIRECTIONS, MUI
!       FROM MINI TO MAXI IN STEPS INTERVALS OF THE FI AND
!       MUO INTEGRATED PHASE FUNCTION.
!   
!
!   INTEGR = INTEGRMUI(XX,MINI,MAXI,MINO,MAXO,STEPS)
!
!   VERSION HISTORY:
!      1.0     WI 27.05.98 
!      2.0    MD 1 APR 05 TRANSLATED TO FORTRAN FROM MATLAB
!
!   USES: INTEGRMUO
!     
!   COPYRIGHT (C) 1998 BY THE INSTITUTE OF APPLIED PHYSICS, 
!   UNIVERSITY OF BERN, SWITZERLAND

IMPLICIT NONE
 
INTEGER,INTENT(IN) :: NUM,STEPS,ARG_LENGTH(2)
REAL, INTENT(IN) :: XX(NUM),MINI(NUM),MAXI,MINO(ARG_LENGTH(1)),&
                      MAXO(ARG_LENGTH(2))
REAL, INTENT(OUT) :: INTEGR(NUM)
REAL :: STEPSR
REAL,DIMENSION(:),ALLOCATABLE :: DMU,DELTA,F0,MUI,FUNC
INTEGER IMU

ALLOCATE( DMU(NUM),DELTA(NUM),F0(NUM),MUI(NUM),FUNC(NUM) )

STEPSR=REAL(STEPS)
DMU=MAXI-MINI
DELTA=DMU/STEPSR
F0=0.5*DELTA
INTEGR=0.

DO IMU=1,STEPS
  MUI=MINI+F0+(IMU-1)*DELTA
  CALL INTEGRMUO(XX,MUI,MINO,MAXO,STEPS,FUNC,NUM,ARG_LENGTH)
  INTEGR=INTEGR+FUNC*DELTA
END DO

INTEGR=INTEGR/DMU

DEALLOCATE( DMU,DELTA,F0,MUI,FUNC )

END SUBROUTINE INTEGRMUI


! -------------------------------------------------------------------------
!
SUBROUTINE INTEGRMUO(XX,MUI,MINO,MAXO,STEPS,INTEGR,NUM,ARG_LENGTH)
!
! -------------------------------------------------------------------------
!
!     CODE ORIGINALLY OBTAINED IN MATLAB FROM MATZLER
!
!   CALCULATES INTEGRATION  OVER INCIDENT DIRECTIONS, MUI
!       FROM MINO TO MAXO IN STEPS INTERVALS OF THE FI
!       PHASE FUNCTION.
! 
!
!   INTEGR = INTEGRMUO(XX,MUI,MINO,MAXO,STEPS)
!
!   VERSION HISTORY:
!      1.0     WI 27.05.98 
!      2.0    MD 1 APR 05 TRANSLATED TO FORTRAN FROM MATLAB
!      2.1    MD 21 NOV 05 MADE ALL LOCALS ALLOCATABLE
!
!   USES: INTEGRFI
!     
!   COPYRIGHT (C) 1998 BY THE INSTITUTE OF APPLIED PHYSICS, 
!   UNIVERSITY OF BERN, SWITZERLAND      

IMPLICIT NONE

INTEGER,INTENT(IN) :: NUM,STEPS,ARG_LENGTH(2)
REAL,INTENT(IN) :: MUI(NUM),MINO(ARG_LENGTH(1)),MAXO(ARG_LENGTH(2)),XX(NUM)
REAL,INTENT(OUT) :: INTEGR(NUM)
REAL :: MINOS,MAXOS
REAL,DIMENSION(:), ALLOCATABLE ::  DMU,DELTA,F0,MUO,FUNC
INTEGER IMU,I

ALLOCATE( DMU(NUM),DELTA(NUM),F0(NUM),MUO(NUM),FUNC(NUM) )

IF (ARG_LENGTH(1)==1) THEN
! N.B. IF MINO IS SCALAR, MAXO IS VECTOR
  MINOS=MINO(1)
  DMU=MAXO-MINOS
ELSEIF (ARG_LENGTH(2)==1) THEN
! N.B. IF MAXO IS SCALAR, MINO IS VECTOR
  MAXOS=MAXO(1)
  DMU=MAXOS-MINO
ELSE
  DMU=MAXO-MINO
END IF     

DELTA=DMU/STEPS
F0=0.5*DELTA
INTEGR=0.

DO IMU=1,STEPS
  IF (ARG_LENGTH(1)==1) THEN
    MUO=MINOS+F0+(IMU-1)*DELTA
  ELSE
    MUO=MINO+F0+(IMU-1)*DELTA
  END IF
  CALL INTEGRFI(XX,MUI,MUO,STEPS,FUNC,NUM)
  INTEGR=INTEGR+FUNC*DELTA
END DO

INTEGR=INTEGR/2

DEALLOCATE( DMU,DELTA,F0,MUO,FUNC )

END SUBROUTINE INTEGRMUO


! -------------------------------------------------------------------------
!
SUBROUTINE LAYER(RI,SI,TRI,TI,TGND,TSKY,D,NUM)
!
! -------------------------------------------------------------------------
!
!     CODE ORIGINALLY OBTAINED IN MATLAB FROM MATZLER
!
!   CALCULATES THE UPWELLING BRIGHTNESS TEMPERATURES D (SEE NOTE 6)  
!
!   D = LAYER(RI,SI,TI,TI,TGND,TSKY)
!       D:    UPWELLING BRIGHTNESS TEMPERATURE
!       RI:   LAYER REFLECTIVITY
!       SI:   INTERFACE REFLECTIVITY
!       TI:   LAYER TRANSMISSIVITY
!       TI:   PHYSICAL TEMPERATURE [K]
!       TGND: BRIGHTNESS TEMPERATURE OF THE SOIL BELOW THE SNOWPACK
!       TSKY: BRIGHTNESS TEMPERATURE OF THE SKY
!
!   VERSION HISTORY:
!      1.0    WI 15.7.95
!      1.1    WI 26.9.97  HANDLES ALSO THE SPECIAL CASE OF A SINGLE LAYER NOW
!      1.2    WI 02.03.99 FIXED ERROR IN 1 LAYER HANDLING 
!      2.0    MD 1 APR 05 TRANSLATED TO FORTRAN FROM MATLAB
!  
!   USES: - INVERT_MATRIX SUBROUTINE BY MIKE,ZEROSI INTERNAL FUNCTION AND
!              EYEI INTERNAL FUNCTION BY MIKE
!
!   COPYRIGHT (C) 1997 BY THE INSTITUTE OF APPLIED PHYSICS, 
!   UNIVERSITY OF BERN, SWITZERLAND

IMPLICIT NONE

INTEGER,INTENT(IN) :: NUM
REAL,INTENT(IN) :: RI(NUM),SI(NUM+1),TRI(NUM),TI(NUM),TGND,TSKY
REAL,INTENT(OUT) :: D(NUM)
REAL K1
REAL,DIMENSION(:),ALLOCATABLE ::  EI,F,E
REAL,DIMENSION(:,:),ALLOCATABLE :: M1,H,EYE,M2,M3,M4,M5,INVIM1,INVIM5,EYEM1,&
  EYEM5 
INTEGER ROW,COL,I

!integer,intent(in) :: pixel

ALLOCATE( EI(NUM),M1(NUM,NUM),H(NUM-1,NUM-1),EYE(NUM,NUM),M2(NUM,NUM),&
       M3(NUM,NUM),M4(NUM,NUM),E(NUM),F(NUM),M5(NUM,NUM),&
       INVIM1(NUM,NUM),INVIM5(NUM,NUM),EYEM1(NUM,NUM),EYEM5(NUM,NUM) )

EI=1-RI-TRI

IF (NUM==1) THEN
  !FOR ONE LAYER CASE, THIS IS THE ENTIRE CALCULATION; THE MATRIX INVERSION
  ! ROUTINE IS NOT NEEDED.  THEREFORE, A RETURN STATEMENT IS USED HERE...
  K1=(1-RI(1)*SI(1))*(1-RI(1)*SI(2))-TRI(1)*SI(1)*TRI(1)*SI(2)
  D=TRI(1)*SI(1)*((1-SI(1))*RI(1)*TGND+(1-SI(2))*TSKY*TRI(1)+&
      EI(1)*TI(1))/K1+(1-RI(1)*SI(1))*((1-SI(1))*TGND*TRI(1)+&
      (1-SI(2))*TSKY*RI(1)+EI(1)*TI(1))/K1
  RETURN
ELSE
! INITIALIZE ARRAYS
  M1=ZEROSI(NUM,NUM)
  H=ZEROSI(NUM-1,NUM-1)
  M2=ZEROSI(NUM,NUM)
  M3=ZEROSI(NUM,NUM)
  M4=ZEROSI(NUM,NUM)

  DO I=1,NUM
    M1(I,I)=RI(I)*SI(I)
  END DO
  DO I=1,NUM-1
    H(I,I)=TRI(I)*(1-SI(I+1))
  END DO
  M1(1:NUM-1:1,2:NUM:1)=M1(1:NUM-1:1,2:NUM:1)+H

  EYE=EYEI(NUM)
  H=ZEROSI(NUM-1,NUM-1)
  DO I=1,NUM
    M2(I,I)=TRI(I)*SI(I+1)
  END DO
  DO I=2,NUM
    H(I-1,I-1)=RI(I)*(1-SI(I))
  END DO
  M2(2:NUM:1,1:NUM-1:1)=M2(2:NUM:1,1:NUM-1:1)+H

  H=ZEROSI(NUM-1,NUM-1)
  DO I=1,NUM
    M3(I,I)=TRI(I)*SI(I)
  END DO
  DO I=1,NUM-1
    H(I,I)=RI(I)*(1-SI(I+1))
  END DO
  M3(1:NUM-1:1,2:NUM:1)=M3(1:NUM-1:1,2:NUM:1)+H

  H=ZEROSI(NUM-1,NUM-1)
  DO I=1,NUM
    M4(I,I)=RI(I)*SI(I+1)
  END DO
  DO I=2,NUM
    H(I-1,I-1)=TRI(I)*(1-SI(I))
  END DO
  M4(2:NUM:1,1:NUM-1:1)=M4(2:NUM:1,1:NUM-1:1)+H

  E=EI*TI
  E(1)=E(1)+RI(1)*(1-SI(1))*TGND
  E(NUM)=E(NUM)+TRI(NUM)*(1-SI(NUM+1))*TSKY

  F=EI*TI
  F(1)=F(1)+TRI(1)*(1-SI(1))*TGND
  F(NUM)=F(NUM)+RI(NUM)*(1-SI(NUM+1))*TSKY

END IF
   
EYEM1=EYE-M1
CALL INVERT_MATRIX(EYEM1,INVIM1,NUM)

M5=MATMUL(M3,MATMUL(INVIM1,M2))+M4
EYEM5=EYE-M5
CALL INVERT_MATRIX(EYEM5,INVIM5,NUM)

D=MATMUL(INVIM5,(MATMUL(MATMUL(M3,INVIM1),E)+F))

DEALLOCATE( EI,M1,H,EYE,M2,M3,M4,E,F,M5,INVIM1,INVIM5,EYEM1,EYEM5 )

CONTAINS

FUNCTION ZEROSI(ROW,COL)

! BY MIKE, 1 APRIL 2005
!
! THIS FUNCTION IS INTERNAL TO LAYER SUBROUTINE
! MANY VALUES IN THE ABOVE ARRAYS ARE NEVER A VALUE OTHER THAN ZERO, SO INSTEAD
! OF USING WHATEVER VALUES ARE RANDOMLY ALLOCATED TO THE ARRAYS WHEN THEY ARE 
! ALLOCATED, I SPECIFICALLY SET EACH POSITION TO ZERO.  THIS FUNCTION SHOULD 
! BE ENTIRELY unneceSSARY, SINCE THE DEFAULT VALUES IN THE ARRAY SHOULD BE ZERO. NONETHELESS, I DECIDED TO EXPLICITLY ZERO OUT 2-D ARRAYS BEFORE USING THEM

IMPLICIT NONE

INTEGER,INTENT(IN):: ROW,COL
REAL :: ZEROSI(ROW,COL)
INTEGER I,J

DO I=1,ROW
  DO J=1,COL
    ZEROSI(I,J)=0.
  END DO
END DO

END FUNCTION ZEROSI

FUNCTION EYEI(NUM)


! BY MIKE, 1 APRIL 2005
!
! THIS FUNCTION IS INTERNAL TO LAYER SUBROUTINE
! THIS FUNCTION DEFINES AN IDENTITY MATRIX OF SIZE NUM

INTEGER, INTENT(IN) :: NUM
REAL :: EYEI(NUM,NUM)
INTEGER I,J
DO I=1,NUM
  DO J=1,NUM
    IF (I==J) THEN
      EYEI(I,J)=1
    ELSE
      EYEI(I,J)=0
    END IF
  END DO
END DO
END FUNCTION EYEI
  

END SUBROUTINE LAYER


! -------------------------------------------------------------------------
!
SUBROUTINE MIXMOD(FREQ,TI,WIFR,EPSI,EPSII,NUM)
!
! -------------------------------------------------------------------------
!
!     CODE ORIGINALLY OBTAINED IN MATLAB FROM MATZLER
!
!   CALCULATES THE PERMITTIVITY FOR WETNESS > 0
!      PHYSICAL MIXING MODEL WEISE 97 AFTER MATZLER 1987 (CORRECTED)
!      WATER TEMPERATURE IS ASSUMED CONSTANT AT 273.15 K
!
!   [EPSI,EPSII] = MIXMOD(F,TI,WI,EPSI,EPSII)
!       EPSI:  REAL PART OF THE PERMITTIVITY
!       EPSII: IMAGINARY PART OF THE PERMITTIVITY
!       F:     FREQUENCY [GHZ]
!       TI:    PHYSICAL SNOW TEMPERATURE
!       WI:    WETNESS [!]
!       EPSI:  REAL PART OF DRY SNOW PERM.
!       EPSII: IMAGINARY PART OF DRY SNOW PERM.
!
!   VERSION HISTORY:
!      1.0    WI 15.7.95
!      2.0    MD  1 APR 05 TRANSLATED TO FORTRAN FROM MATLAB
!      2.1    MD 21 NOV 05 MADE ALL LOCALS DYNAMICALLY ALLOCATABLE
!   
!   USES: - NONE
!
!   COPYRIGHT (C) 1997 BY THE INSTITUTE OF APPLIED PHYSICS, 
!   UNIVERSITY OF BERN, SWITZERLAND

IMPLICIT NONE

INTEGER, INTENT(IN) :: NUM
REAL, INTENT(IN) :: FREQ, TI(NUM), WIFR(NUM)
REAL, INTENT(INOUT) :: EPSI(NUM), EPSII(NUM)

REAL :: AA,AB,AC,EUW,ESW,FRW
REAL,DIMENSION(:),ALLOCATABLE ::  ESA,ESB,ESC,EUA,EUB,EUC,FA,FB,FC,EEA,EEB,&
     EEC,FWA,FWB,FWC,DEPSIA,DEPSIB,DEPSIC,DEPSI,DEPSIIA,DEPSIIB,DEPSIIC,DEPSII

ALLOCATE( ESA(NUM),ESB(NUM),ESC(NUM),EUA(NUM),&
     EUB(NUM),EUC(NUM),FA(NUM),FB(NUM),FC(NUM),EEA(NUM),EEB(NUM),&
     EEC(NUM),FWA(NUM),FWB(NUM),FWC(NUM),DEPSIA(NUM),DEPSIB(NUM),&
     DEPSIC(NUM),DEPSI(NUM),DEPSIIA(NUM),DEPSIIB(NUM),DEPSIIC(NUM),&
     DEPSII(NUM) )

AA=0.005
AB=0.4975
AC=0.4975
EUW=4.9
ESW=88.045
FRW=0.11109                            ! INVERSE RELAXATION FREQUENCY OF WATER
ESA=(ESW-EPSI)/(3*(1+AA*(ESW/EPSI-1)))
ESB=(ESW-EPSI)/(3*(1+AB*(ESW/EPSI-1)))
ESC=(ESW-EPSI)/(3*(1+AC*(ESW/EPSI-1)))
EUA=(EUW-EPSI)/(3*(1+AA*(EUW/EPSI-1)))
EUB=(EUW-EPSI)/(3*(1+AB*(EUW/EPSI-1)))
EUC=(EUW-EPSI)/(3*(1+AC*(EUW/EPSI-1)))

FA=1+AA*(ESW-EUW)/(EPSI+AA*(EUW-EPSI))
FB=1+AB*(ESW-EUW)/(EPSI+AB*(EUW-EPSI))
FC=1+AC*(ESW-EUW)/(EPSI+AC*(EUW-EPSI))

EEA=ESA-EUA
EEB=ESB-EUB
EEC=ESC-EUC

FWA=FRW/FA
FWB=FRW/FB
FWC=FRW/FC

DEPSIA=EUA+EEA/(1+(FWA*FREQ)**2)
DEPSIB=EUB+EEB/(1+(FWB*FREQ)**2)
DEPSIC=EUC+EEC/(1+(FWC*FREQ)**2)
DEPSI=WIFR*(DEPSIA+DEPSIB+DEPSIC)

DEPSIIA=FWA*FREQ*EEA/(1+(FWA*FREQ)**2)
DEPSIIB=FWB*FREQ*EEB/(1+(FWB*FREQ)**2)
DEPSIIC=FWC*FREQ*EEC/(1+(FWC*FREQ)**2)
DEPSII=WIFR*(DEPSIIA+DEPSIIB+DEPSIIC)

EPSI=EPSI+DEPSI
EPSII=EPSII+DEPSII

DEALLOCATE( ESA,ESB,ESC,EUA, EUB,EUC,FA,FB,FC,EEA,EEB,EEC,FWA,FWB,&
     FWC,DEPSIA,DEPSIB, DEPSIC,DEPSI,DEPSIIA,DEPSIIB,DEPSIIC, DEPSII )

END SUBROUTINE MIXMOD


! -------------------------------------------------------------------------
!
SUBROUTINE PFADC(TETA,DI,EPSI,GS6,DEI,TEI,TSCAT,NUM)
!
! -------------------------------------------------------------------------
!
!      CODE ORIGINALLY OBTAINED IN MATLAB FROM MATZLER
!
!   CALCULATES THE EFFECTIVE PATH LENGTH IN A LAYER
!
!   [DEI,TEI,TSCAT] = PFADC(TETA,DI,EPSI,GS6)
!       DEI:  EFFECTIVE PATH LENGTH [M]
!       TEI:  LOCAL INCIDENCE ANGLE
!       TSCAT: SCATTERING 
!       TETA: INCIDENCE ANGLE AT SNOW AIR INTERFACE
!       DI:   THICKNESS [M]
!       EPSI: DIELECTRIC PERMITTIVITY
!       GS6:  6-FLUX SCATTERING COEFFICIENT
!
!   VERSION HISTORY:
!      1.0    WI 15.10.97
!      2.0    MD 1 APR 05 TRANSLATED TO FORTRAN FROM MATLAB
!      2.1    MD 21 NOV 05 CHANGED ALL LOCALS TO ALLOCATBLE
!
!   
!   USES: - NONE
!
!   COPYRIGHT (C) 1997 BY THE INSTITUTE OF APPLIED PHYSICS, 
!   UNIVERSITY OF BERN, SWITZERLAND

IMPLICIT NONE

INTEGER, INTENT(IN) :: NUM
REAL, INTENT(IN) :: TETA,DI(NUM),EPSI(NUM),GS6(NUM)
REAL, INTENT(OUT) :: DEI(NUM),TEI(NUM),TSCAT(NUM)
REAL,DIMENSION(:),ALLOCATABLE ::  NS,COSTETASN,COSC,COSTETASC,TAUSCAT,COSTETA
INTEGER I

ALLOCATE( NS(NUM),COSTETASN(NUM),COSC(NUM),COSTETASC(NUM),TAUSCAT(NUM+1),&
       COSTETA(NUM) )

NS=EPSI**0.5
COSTETASN=(1-(SIN(TETA)/NS)**2)**0.5      
COSC=(1-(1/NS)**2)**0.5
COSTETASC=0.5*(1+COSC)
DEI=DI/COSTETASN
    
TAUSCAT(NUM+1)=0

DO I=NUM,1,-1
  TAUSCAT(I)=TAUSCAT(I+1)+DEI(I)*GS6(I)/2
  TSCAT(I)=EXP(-1*TAUSCAT(I))
  COSTETA(I)=TSCAT(I)*COSTETASN(I)+(1-TSCAT(I))*COSTETASC(I)
END DO      

TEI=ACOS(COSTETA)

DEALLOCATE (  NS,COSTETASN,COSC,COSTETASC,TAUSCAT,COSTETA )

END SUBROUTINE PFADC


! -------------------------------------------------------------------------
!
SUBROUTINE PFADI(TEI,DI,DEI,NUM)
!
! -------------------------------------------------------------------------
!
!     CODE ORIGINALLY OBTAINED IN MATLAB FROM MATZLER
!
!   CALCULATES THE EFFECTIVE PATH LENGTH IN A LAYER
!
!   DEI = PFADI(TEI,DI)
!       DEI:  EFFECTIVE PATH LENGTH [M]
!       TEI:  LOCAL INCIDENCE ANGLE
!       DI:   THICKNESS [M]
!
!   VERSION HISTORY:
!      1.0    WI 15.7.95
!      2.0    MD 1 APR 05 TRANSLATED TO FORTRAN FROM MATLAB
!   
!   USES - NONE
!
!   COPYRIGHT (C) 1997 BY THE INSTITUTE OF APPLIED PHYSICS, 
!   UNIVERSITY OF BERN, SWITZERLAND

IMPLICIT NONE

INTEGER, INTENT(IN) :: NUM
REAL, INTENT(IN) :: TEI(NUM+1),DI(NUM)
REAL, INTENT(OUT) :: DEI(NUM)

DEI=DI/COS(TEI(1:NUM))

END SUBROUTINE PFADI


! -------------------------------------------------------------------------
!
SUBROUTINE POLDER(VFI,A,EICE,EPSI,EPSEFF,NUM)
!
! -------------------------------------------------------------------------
!  WRITTEN BY MIKE, 1 APRIL 05
!  SOLVES (1) THROUGH (5) IN MATZLER, 1996 IN IEEE
!  IMPLEMENTS NEWTON-RAPHSON ITERATION TECHNIQUE IN ORDER TO SOLVE THE RESULT
!  OF SUBSTITUTING EQUATIONS (4) AND (5) INTO (3),THEN (3) INTO (1) AND SOLVING.
!  FOR DOCUMENTATION, SEE REPORT "SOLVING FOR EEFF.SXW" UNDER REPORTS/MEMLS
!  FOLDER.
!
!  INPUTS: V - VOLUME FRACTION OF ICE
!          A - DEPOLARIZATION FACTOR
!          EICE - ICE PERMITTIVITY
!          EPSI - DRY SNOW PERMITTIVITY
!  OUTPUT: EPSEFF - EFFECITVE ICE PERMITTIVITY

IMPLICIT NONE

INTEGER, INTENT(IN) :: NUM
REAL, INTENT(IN) :: VFI(NUM),A(NUM),EICE,EPSI(NUM)
REAL, INTENT(OUT) :: EPSEFF(NUM)
REAL EPS,X,F,U1,V1,U2,V2,B,T,DBDX,DTDX,DFDX,DELTAX
INTEGER I,K

EPS=0.001
DO I=1,NUM
  X=1-EPSI(I)    !X0, INITIAL GUESS
  F=EPS*10       !DUMMY VALUE FOR FIRST GUESS
  K=1            !ITERATION COUNTER
  DO
    K=K+1
    U1=2*(1+(1-A(I))*X)
    V1=1+(1-A(I))*X+A(I)*(EICE-1)
    U2=1+2*A(I)*X
    V2=1+2*A(I)*X+(1-2*A(I))*(EICE-1)
    B=3-VFI(I)*(EICE-1)*(2*A(I)/V1+(1-2*A(I))/V2)
    T=VFI(I)*(EICE-1)*(U1/V1+U2/V2)
    DBDX=2*A(I)*VFI(I)*(EICE-1)*((1-A(I))/V1**2+(1-2*A(I))/V2**2)
    DTDX=DBDX*(EICE-1)
    DFDX=1-(B*DTDX-T*DBDX)/B**2
    DELTAX=-1*F/DFDX
    X=X+DELTAX
    F=X-T/B
    IF (ABS(F)<EPS) EXIT    ! TEST WHETHER WE ARE CLOSE ENOUGH TO ZERO
  END DO
  EPSEFF(I)=X+1
END DO
  
END SUBROUTINE POLDER


! -------------------------------------------------------------------------
!
SUBROUTINE POLMIX(TSCAT,SIH,SIV,NUM)
!
! -------------------------------------------------------------------------
!
!     CODE ORIGINALLY OBTAINED IN MATLAB FROM MATZLER
!
!   CALCULATES THE POLARIZATION MIXING OF THE INTERFACE REFLECTIVITIES
!       OF EACH LAYER (TAKING INTO ACCOUNT THE FIRST ORDER SCATTERING)
!
!   [SIH,SIV] = POLMIX(TSCAT,SIH,SIV)
!       SIH:   INTERFACE REFLECTIVITY AT H-POL
!       SIV:   INTERFACE REFLECTIVITY AT V-POL
!       TSCAT: TAU SCAT
!
!   VERSION HISTORY:
!      1.0    WI 14.10.97
!      1.1    WI  4.11.97  BUG FIX (LAYER NUMBERING PROBLEM)
!      2.0    MD 1 APR 05 TRANSLATED TO FORTRAN FROM MATLAB
!
!   USES - NONE
!
!   COPYRIGHT (C) 1997 BY THE INSTITUTE OF APPLIED PHYSICS, 
!   UNIVERSITY OF BERN, SWITZERLAND

IMPLICIT NONE

INTEGER,INTENT(IN) :: NUM
REAL,INTENT(IN) :: TSCAT(NUM)
REAL,INTENT(INOUT) :: SIH(NUM+1),SIV(NUM+1)
REAL,DIMENSION(:),ALLOCATABLE ::  TSCATLONG,SMEAN,DELTAS

ALLOCATE( TSCATLONG(NUM+1),SMEAN(NUM+1),DELTAS(NUM+1) )

TSCATLONG(1:NUM)=TSCAT(1:NUM)
TSCATLONG(NUM+1)=1.

SMEAN=0.5*(SIH+SIV)
DELTAS=0.5*TSCATLONG*(SIH-SIV)

SIH=SMEAN+DELTAS
SIV=SMEAN-DELTAS

DEALLOCATE( TSCATLONG,SMEAN,DELTAS )

END SUBROUTINE POLMIX


! -------------------------------------------------------------------------
!
SUBROUTINE RO2EPSD(ROI,TI,FREQ,EPSI,EPSII,NUM,pixel,replicate,rank,meas,fn)
!
! -------------------------------------------------------------------------
!   
!     CODE ORIGINALLY OBTAINED IN MATLAB FROM MATZLER
!
!   CALCULATES THE DIELECTRIC PERMITTIVITY FROM 
!   DENSITY FOR DRY SNOW.
!
!   [EPSI,EPSII] = RO2EPSD(ROI,TI,FREQ)
!       EPSI:  REAL PART OF DIELECTRIC PERMITTIVITY
!       EPSII: IMAGINARY PART OF DIELECTRIC PERMITTIVITY
!       ROI:   DENSITY
!       TI:    SNOW TEMPERATURE IN KELVIN
!       FREQ:  FREQUENCY
!
!   VERSION HISTORY:
!      1.0    WI 15.7.95
!      2.0    WI 12.11.97  ENHANCED WITH POLDER AND VAN SANTEN EQUATIONS (SEE
!                           POLDER.M)
!      3.0    MD  1 APR 05 TRANSLATED TO FORTRAN FROM MATLAB
!      3.1    MD 21 NOV 05 CHANGED ALL LOCALS TO DYNAMICALLY ALLOCATABLE
!
!   USES:
!       EPSICE, EPSR, POLDER
!
!   COPYRIGHT (C) 1997 BY THE INSTITUTE OF APPLIED PHYSICS, 
!   UNIVERSITY OF BERN, SWITZERLAND

IMPLICIT NONE

INTEGER,INTENT(IN):: NUM
REAL, INTENT(IN) :: ROI(NUM),TI(NUM),FREQ
REAL, INTENT(OUT) :: EPSI(NUM), EPSII(NUM)
INTEGER :: I
REAL :: EI
REAL,DIMENSION(:),ALLOCATABLE ::  EICE,F,A,EPSP,A3,EA,EA3,K1,K3,KSQ

integer,intent(in) :: pixel,replicate,rank,meas,fn

ALLOCATE( EICE(NUM),F(NUM),A(NUM),EPSP(NUM),A3(NUM),EA(NUM),EA3(NUM), & 
     K1(NUM),K3(NUM),KSQ(NUM) )

CALL EPSICE(TI,FREQ,EICE,NUM)

CALL EPSR(ROI,NUM,EPSI)

!     IMAGINARY PART AFTER POLDER AND VAN SANTEN 1946 (EFFECTIVE-MEDIUM APPROX)

F=ROI/0.917
EI=3.185

DO I=1,NUM
  A(I)=0.3
  IF (F(I)<0.55) THEN
    A(I)=0.476-0.64*F(I)
  END IF
  IF (F(I)<0.333) THEN
    A(I)=0.1+0.5*F(I)
  END IF
END DO

CALL POLDER(F,A,EI,EPSI,EPSP,NUM)

A3=1-2*A
EA=(EPSP*(1-A))+A
EA3=(EPSP*(1-A3))+A3
K1=(EA/(EA+A*(EI-1)))**2
K3=(EA3/(EA3+A3*(EI-1)))**2
KSQ=(2*K1+K3)/3
EPSII=EPSI**0.5*EICE*KSQ*F

DEALLOCATE( EICE,F,A,EPSP,A3,EA,EA3,K1,K3,KSQ )

END SUBROUTINE RO2EPSD


! -------------------------------------------------------------------------
!
SUBROUTINE RT(GAI,GBI,DEI,RI,TI,NUM)
!
! -------------------------------------------------------------------------
!
!     CODE ORIGINALLY OBTAINED IN MATLAB FROM MATZLER
!
!   CALCULATES THE LAYER REFLECTIVITY AND TRANSMISSIVITY   
!
!
!   [RI,TI] = RT(GAI,GBI,DEI)
!       RI:   LAYER REFLECTIVITY
!       TI:   LAYER TRANSMISSIVITY
!       GAI:  ABSORPTION COEFFICIENT
!       GBI:  SCATTERING COEFFICIENT
!       DEI:  PATH LENGTH
!
!   VERSION HISTORY:
!      1.0    WI 15.7.95
!      2.0    MD 1 APR 05 TRANSLATED TO FORTRAN FROM MATLAB
!   
!   USES: NONE
!
!   COPYRIGHT (C) 1997 BY THE INSTITUTE OF APPLIED PHYSICS, 
!   UNIVERSITY OF BERN, SWITZERLAND

IMPLICIT NONE

INTEGER,INTENT(IN) :: NUM
REAL,INTENT(IN) :: GAI(NUM),GBI(NUM),DEI(NUM)
REAL,INTENT(OUT) :: RI(NUM),TI(NUM)
REAL,DIMENSION(:),ALLOCATABLE :: MYGAMMA,T0I,R0I,T02,R02
INTEGER I

ALLOCATE( MYGAMMA(NUM),T0I(NUM),R0I(NUM),T02(NUM),R02(NUM) )

MYGAMMA=(GAI*(GAI+2*GBI))**0.5
T0I=EXP(-1*MYGAMMA*DEI)

DO I=1,NUM
  IF(GBI(I)>0.00001)THEN
    R0I(I)=GBI(I)/(GAI(I)+GBI(I)+MYGAMMA(I))
  ELSE
    R0I(I)=0
  END IF
END DO

T02=T0I**2
R02=R0I**2
RI=R0I*(1-T02)/(1-T02*R02)
TI=T0I*(1-R02)/(1-T02*R02)

DEALLOCATE( MYGAMMA,T0I,R0I,T02,R02 )

END SUBROUTINE RT


! -------------------------------------------------------------------------
!
SUBROUTINE RUFFSOIL(F,MV,T,KSIGMA,THETA,EPS_TOP,&
             R_H_MOD,R_V_MOD)
!
! -------------------------------------------------------------------------
!
!     CODE ORIGINALLY OBTAINED IN MATLAB FROM PULLIAINEN
!
!     FUNCTION FOR CALCULATING REFLECTIVITIES OF ROUGH, BARE SOILS
!     ACCORDING TO THEORY BY WEGMULLER & MTZLER
!     F = FREQUENCY [HZ]
!     MV = VOLUMETRIC MOISTURE [0..1]
!     T = TEMP [K]
!     KSIGMA = NORMALIZED SURFACE SDEV
!     THETA = NADIR ANGLE [DEG]
!     EPS_TOP = EPSILON OF OVERLYING MEDIUM
!     EPS_SOIL = DEFINE EPSILON EXPLICITLY
!
!    VERSION HISTORY:
!      1.0    ?? ?.?.?
!      2.0    MD 1 APR 05 TRANSLATED TO FORTRAN FROM MATLAB


IMPLICIT NONE
REAL,INTENT(IN) :: F,MV,T,KSIGMA,THETA
COMPLEX, INTENT(IN) :: EPS_TOP
REAL,INTENT(OUT) :: R_H_MOD,R_V_MOD
REAL GND_TEMP,GND_EPS,PI,FRESNEL_H,FRESNEL_V,THETA_R
COMPLEX EPS_SOIL,EPS_EFF

PI=3.14159
GND_TEMP=T-273.16 ! K TO C

CALL EPSS(MV,GND_TEMP,F,EPS_SOIL)

EPS_EFF=EPS_SOIL/EPS_TOP

CALL GAMMAH(EPS_EFF,THETA,FRESNEL_H)
CALL GAMMAV(EPS_EFF,THETA,FRESNEL_V)

THETA_R=THETA/180*PI

R_H_MOD=FRESNEL_H*EXP(-KSIGMA**((0.1*COS(THETA_R))**0.5))

IF (THETA<=60) THEN
  R_V_MOD=R_H_MOD*COS(THETA_R)**0.65
ELSEIF(THETA==70)THEN
  R_V_MOD=R_H_MOD*0.621
ELSE
!  PRINT*,("OOPS!  USE R_V_MOD=R_H_MOD, SINCE THETA=") ! ADDED BY MIKE
!  PRINT *, THETA
  R_V_MOD=R_H_MOD 
END IF

END SUBROUTINE RUFFSOIL


! -------------------------------------------------------------------------
!
SUBROUTINE SCCOEFF(ROI,TI,PCI,FREQ,WIFR,GAI,SCCHO,GBIH,GBIV,GS6,&
                     GA2I,NUM,EPSI,EPSII,pixel,replicate,rank,meas)
!
! -------------------------------------------------------------------------
!
! CODE ORIGINALLY OBTAINED IN MATLAB FROM MATZLER, MOD. BY MIKE (SEE HISTORY) 
!
!   CALCULATES THE SCATTERING COEFFICIENT FROM STRUCTURAL PARAMETERS
!     DIFFERENT ALGORITHMS CAN BE CHOSEN, BY CHANGING "SCCHO"
!
!   [GBIH,GBIV,GS6,GA2I] = SCCOEFF(ROI,TI,PCI,FREQ,WI,GAI,SCCHO)
!       GBIH:  2-FLUX SCATTERING COEFFICIENT AT H POL
!       GBIV:  2-FLUX SCATTERING COEFFICIENT AT V POL
!       GS6:   6-FLUX SCATTERING COEFFICIENT
!       GA2I:  2-FLUX ABSORPTION COEFFICIENT
!       ROI:   DENSITY
!       TI:    PHYSICAL TEMPERATURE
!       PCI:   CORRELATION LENGTH
!       FREQ:  FREQUENCY
!       WI:    WETNESS
!       GAI:   ABSORPTION COEFFICIENT
!       SCCHO: SCATTERING COEFFICIENT ALGORITHM CHOSEN
!
!   VERSION HISTORY:
!      1.0B    WI 15.7.95
!      1.0     WI 23.9.97 BUG FIXED
!      1.1     WI 26.9.97 LATEST FIT ON EXPERIMENTAL DATA WAS ADDED (OPTION 7)
!      1.2     WI 13.10.97 OPTION 8 ADDED, ADAPTED SCATTERING OF A SHELL/SPHERE
!                            TO NOTE 9/VER2 
!      1.3     WI  4.11.97 OPTION 9, 10 AND 11 ADDED 
!      1.4     WI 27.05.98 BORN APPROXIMATION ADDED (BORNA.M)
!      2.0     MD 1 APR 05 CALL TO BORNA CHANGED TO CALL TO BORN (BY MIKE). 
!                            ALL OPTIONS FOR OTHER SHAPES REMOVED BUT BORN 
!                            APPROX AND THE APPROX FOR FINE GRAIN SNOW IN 
!                            WIESMANN AND MATZLER 1999
!      2.0     MD 21 NOV 05  MADE ALL LOCALS DYNAMICALLY ALLOCATABLE
!
!   USES: BORN
!
!
!   COPYRIGHT (C) 1997 BY THE INSTITUTE OF APPLIED PHYSICS, 
!   UNIVERSITY OF BERN, SWITZERLAND

IMPLICIT NONE

INTEGER, INTENT(IN) :: NUM,SCCHO
REAL, INTENT(IN) :: ROI(NUM),TI(NUM),PCI(NUM),FREQ,WIFR(NUM),&
                      GAI(NUM),EPSI(NUM),EPSII(NUM)
REAL, INTENT(OUT) :: GBIH(NUM),GBIV(NUM),GS6(NUM),GA2I(NUM)
REAL C,ROAIR,ROICE,DGB0H,DGB0V,K,EICE,PI
REAL,DIMENSION(:),ALLOCATABLE ::  VFI,KP,GB6,GC6,GF6,GTR,OMEGA
INTEGER :: I,IERR !IERR USED FOR MPI_FINALIZE IF WE HAVE AN ERROR

integer, intent(in) :: pixel,replicate,rank,meas

ALLOCATE( VFI(NUM),KP(NUM),GB6(NUM),GC6(NUM),GF6(NUM),GTR(NUM),OMEGA(NUM) )

! CONSTANTS
PI=3.14159
C=2.99
ROAIR=0.001293
ROICE=0.917

! SPECULAR COMPONENT OF SCATTERING COEFFICIENT
!   USUALLY 0 CAN BE IMPORTANT IN NEW SNOW!
DGB0H=0.
DGB0V=0.
K=FREQ*2.*PI/0.299793
EICE=3.18
VFI=ROI/ROICE

IF (SCCHO==1) THEN
  !DUE TO A BAD UDPATE, I'M ADDING A CHECK TO VERIFY THAT ROI IS REASONABLE
  !THE CONSTANTS IN THE FOLLOWING LINE ARE DERIVED FROM EMPIRICAL RELATIONSHIP
  !IN THE CALCULATION OF GS6
  DO I=1,NUM
    IF(ROI(I).GE.(7.48*PCI(I)+0.439))THEN
      PRINT *, 'ERROR IN SCCOEFF: DENSITY IS TOO LARGE OR GRAIN SIZE IS', &
        'TOO SMALL; ROI(I)=',ROI(I),'PCI(I)=',PCI(I),'LAYER#=',I,&
        '. STOPPING PROGRAM EXECUTION'
!      CALL MPI_FINALIZE(IERR)
      STOP
    END IF
  END DO
  !FIT VOM 4.11.97 (WITH DENSITY, USES CORR. LENGTH FROM EXP. FIT!)
  GS6=(9.2*PCI-1.23*ROI+0.54)**2.5*(FREQ/50.)**2.5
  OMEGA=((EPSI-1)/EPSI)**0.5
  GB6=0.5*GS6*(1-OMEGA)
  GC6=0.25*GS6*OMEGA
ELSEIF (SCCHO==2) THEN
   ! BORN APPROXIMATION
   CALL BORN(K,VFI,PCI,EPSI,EICE,GB6,GC6,GF6,GS6,NUM,pixel,replicate,rank,meas)
END IF

! COMPUTE OTHER SCATTERING COEFFICIENTS

GTR=(4*GC6)/(GAI+2*GC6)
GA2I=GAI*(1+GTR)
GBIH=(GB6+DGB0H)+GTR*GC6
GBIV=(GB6+DGB0V)+GTR*GC6

DEALLOCATE( VFI,KP,GB6,GC6,GF6,GTR,OMEGA )

END SUBROUTINE SCCOEFF


! -------------------------------------------------------------------------
!
SUBROUTINE SLRED(NUM,ROI,EPSI,EPSII,TEI,SIH,SIV,DI,DEI,TI,PCI,WI,GAI,&
  FREQ,RNUM,XROI,XEPSI,XEPSII,XTEI,XSIH,XSIV,XDI,XDEI,XTI,XPCI,XWI,XGAI,&
  pixel,replicate,rank,meas)
!
! -------------------------------------------------------------------------
!
!   LOCATES AND TREATS COHERENT LAYERS IN A SNOWPACK
!     SEE TECHNOTE 11
!
!   [RNUM,RROI,REPSI,REPSII,RTEI,RSIH,RSIV,RDI,RDEI,RTI,RPCI,RWI,RGAI]=
!       SLRED(NUM,ROI,EPSI,EPSII,TEI,SIH,SIV,DI,DEI,TI,PCI,FREQ,WI,GAI) 
!       NUM:  INDEX OF THE LAYER IN THE ORIGINAL SNOWPACK
!       ROI:  DENSITY [G/CM^3]
!       EPSI:
!       EPSII:
!       TEI:  LOCAL INCIDENCE ANGLE
!       SIH:  LAYER REFLECTIVITY AT H POL
!       SIV:  LAYER REFLECTIVITY AT V POL
!       DI:   LAYER THICKNESS
!       DEI:  LOCAL PATH LENGTH [M]
!       TI:   PHYSICAL SNOW TEMPERATURE [K]
!       PCI:  CORRELATION LENGTH [MM]
!       WI:   WETNESS  
!       GAI:  ABSORPTION COEFFICIENT
!       FREQ: FREQUENCY
!
!      1.0    WI 21.8.95
!      2.0    WI 13.8.98  COMPLETELY REWRITTEN
!      3.0    MD 1  APR 05 STRIPPED DOWN TO ONLY CHECK FOR COHERENT LAYERS -MD
!      3.1    MD 18 APR 05 FUNCTIONALITY ADDED TO DEAL WITH COHERENT LAYERS, 
!                            SO LONG AS THERE ARE NOT SUCCESSIVE LAYERS
!      3.2    MD 04 NOV 05 FUNCTIONALITY ADDED TO DEAL WITH SUCCESSIVE 
!                            COHERENT LAYERS FOR THREE LAYERS
!      3.3    MD 12 NOV 05 CHANGED TO DYNAMICALLY ALLOCATE ALL LOCALS
!      4.0    JG 10 DEC 10 ADDED FUNCTIONALITY FROM MATLAB FOR ARBITRARY
!                            NUMBER OF LAYERS
!      4.1    MD 08 APR 11 SLIGHT TWEAKS TO JG'S CODE
!   
!   USES:
!       FRESNELRC
!
!   COPYRIGHT (C) 1997 BY THE INSTITUTE OF APPLIED PHYSICS, 
!   UNIVERSITY OF BERN, SWITZERLAND

IMPLICIT NONE

INTEGER,INTENT(IN) :: NUM
REAL,INTENT(INOUT) :: ROI(NUM),EPSI(NUM),EPSII(NUM),TEI(NUM+1),SIH(NUM),&
  SIV(NUM),DI(NUM),DEI(NUM),TI(NUM),PCI(NUM),WI(NUM),GAI(NUM)
REAL,INTENT(IN) :: FREQ
REAL,INTENT(OUT) :: XROI(NUM),XEPSI(NUM),XEPSII(NUM),XTEI(NUM+1),XSIH(NUM),&
  XSIV(NUM),XDI(NUM),XDEI(NUM),XTI(NUM),XPCI(NUM),XWI(NUM),XGAI(NUM)
INTEGER, INTENT(OUT) :: RNUM
INTEGER, DIMENSION(:), ALLOCATABLE :: I,A
REAL CC,PI,FIC,FC,THETA
REAL,DIMENSION(:),ALLOCATABLE ::  NS,FI,X
INTEGER J,NTHIN,PL,SC,SCMAX,ML,MLO,M,K,NAEQ0,NAEQ1,tnum
REAL FITOT
REAL,DIMENSION(:),ALLOCATABLE :: TROI,TEPSI,TEPSII,TTEI,FITV,&
  TSIH,TSIV,TDI,TDEI,TTI,TPCI,TWI,TGAI,TNS,TFI,EPSI_AUG,FH,FV
REAL,DIMENSION(:),ALLOCATABLE :: T2ROI,T2EPSI,T2EPSII,T2TEI,&
  T2DI,T2DEI,T2TI,T2PCI,T2WI,T2GAI,T2NS,T2FI
INTEGER TAL
LOGICAL,DIMENSION(:),ALLOCATABLE :: MASK

integer,intent(in) :: pixel,replicate,rank,meas

ALLOCATE( NS(NUM),FI(NUM), X(NUM) )

! IN GENERAL, WE FIRST TEST TO SEE IF THERE ARE ANY COHERENT LAYERS.  IF NOT,
!   WE SKIP TO CASE 2, OTHERWISE, WE HAVE CASE 1.  IN CASE 1, THE FIRST STEP IS
!   TO TREAT THE EFFECT OF SUCCESSIVE COHERENT SNOWPACK LAYERS BY COMBINING 
!   THESE INTO A SINGLE LAYER. IF THERE ARE NO SUCCESSIVE COHERENT LAYERS,
!   WE SKIP TO STEP 2; REGARDLESS, THE ARRAYS WITH THE T- PREFIX ARE DEFINED
!   BEFORE STEP 2.  IN STEP 2, THE EFFECT OF ISOLATED COHERENT LAYERS IS 
!   DEALT WITH BY INCORPORATING THE EFFECT OF EACH COHERENT LAYER INTO THE
!   INTER-LAYER REFLECTIVITIES.  

! CONSTANTS
CC=0.299793
PI=3.14159
FIC=4*PI*FREQ/CC
FC=4.712

! COMPUTE FI IN ORDER TO CHECK ON COHERENT LAYERS
THETA=TEI(NUM+1)
NS=EPSI**0.5
FI=FIC*DI*NS*COS(TEI(1:NUM))

! COUNT THE THIN LAYERS
NTHIN=0
DO J=1,NUM
  IF (FI(J)<FC) THEN
    NTHIN=NTHIN+1
  END IF
END DO

! ALLOCATE THE I ARRAY, WHICH CONTAINS THE INDECES OF THE THIN LAYERS
ALLOCATE(I(1:NTHIN),A(NUM))

! DEFINE THE I AND A ARRAYS.  THE A ARRAY HAS A VALUE OF 1 FOR THIN 
!   LAYERS AND 0 OTHERWISE
K=0
DO J=1,NUM
  IF (FI(J)<FC) THEN
    K=K+1
    I(K)=J
    A(J)=1
  ELSE
    A(J)=0
  END IF
END DO
! THE BOTTOM LAYER IS ALWAYS ASSUMED NONCOHERENT
A(1)=0

! CHECK TO SEE IF WE HAVE ANY COHERENT LAYERS TO TREAT.  IF NOT, ALLOCATE
!   THE REPLACEMENT ARRAYS (WITH THE 'R' PREFIX) WITH A SIZE OF THE ORIGINAL
!   NUMBER OF LAYERS, THEN DEFINE THOSE ARRAYS BASED ON THE ORIGINAL VALUES
! IF THERE IS ONLY ONE LAYER, IT IS ASSUMED TO BE NONCOHERENT, SO THE ORIGINAL
!   NUMBER OF LAYERS IS ASSIGNED TO RNUM AND THE OUTPUTS SET TO THE INPUTS.

IF (NTHIN>0.AND.NUM.GT.1) THEN
  ! CASE 1: TREAT COHERENT LAYERS IN THE SNOWPACK
  ! 1) IDENTIFY SUCCESSIVE COHERENT LAYERS AND MARK THE PACKS FROM 2,3...SCMAX
  PL=0
  SC=1
  SCMAX=0
  ML=0
  MLO=0

  DO M=2,NUM
    IF (A(M)==1 .AND. PL==1) THEN
      IF(ML==0)THEN
        SC=SC+1
        ML=1
        A(M-1)=SC
      END IF

      A(M)=SC
      SCMAX=SC
    ELSE
      IF (PL==1) THEN
        PL=0
      ELSE
        IF(A(M)==1)THEN
          PL=1
          ML=0
        END IF
      END IF
    END IF
  END DO

  !JG'S CODE TO ALLOW SUCCESSIVE COHERENT LAYERS BEGINS HERE. MD, 4/8/2011
  IF (SCMAX>0) THEN
    ! COMBINE SUCCESSIVE COHERENT LAYERS BY WEIGHTING WITH THE PHASE
    ! COPY ARRAYS TO TEMPORARIES FOR SIMPLICITY OF CODE
    ALLOCATE(T2DI(NUM),T2DEI(NUM),T2ROI(NUM),T2TI(NUM),T2WI(NUM),T2PCI(NUM),&
      T2NS(NUM),T2GAI(NUM),T2EPSI(NUM),T2EPSII(NUM),T2TEI(NUM+1),T2FI(NUM))
    ALLOCATE(MASK(NUM),FITV(NUM))
    T2DI=DI
    T2DEI=DEI
    T2ROI=ROI
    T2TI=TI
    T2WI=WI
    T2PCI=PCI
    T2NS=NS
    T2GAI=GAI
    T2EPSI=EPSI
    T2EPSII=EPSII
    T2TEI=TEI
    T2FI=FI
    ! COMBINE LAYERS
    DO M=2,SCMAX
      MASK=(A==M)
      FITOT=SUM(FI,1,MASK)
      FITV=FI/FITOT        ! WILL USE ONLY ELEMENTS CORRESPONDING TO MASK
      ! FIND MAXIMUM INDEX FOR WHICH A==M
      TAL=NUM
      DO WHILE (.NOT. MASK(TAL))
        TAL=TAL-1
      END DO
      ! THIS IS NOT EFFICIENT, JUST A QUICK AND SIMPLE TRANSLATION FROM MATLAB
      T2DI(TAL)=SUM(DI,1,MASK)
      T2DEI(TAL)=SUM(DEI,1,MASK)
      T2ROI(TAL)=SUM(ROI*FITV,1,MASK)
      T2TI(TAL)=SUM(TI*FITV,1,MASK)
      T2WI(TAL)=SUM(WI*FITV,1,MASK)
      T2PCI(TAL)=SUM(PCI*FITV,1,MASK)
      T2NS(TAL)=SUM(NS*FITV,1,MASK)
      T2GAI(TAL)=SUM(GAI*FITV,1,MASK)
      T2EPSI(TAL)=SUM(EPSI*FITV,1,MASK)
      T2EPSII(TAL)=SUM(EPSII*FITV,1,MASK)
      T2TEI(TAL)=SUM(TEI(1:NUM)*FITV,1,MASK)
      T2FI(TAL)=FITOT
      A(TAL)=1
    ENDDO

    ! REMOVE REDUNDANT LAYERS THAT WERE COMBINED WITH SUCCESIVE LAYERS
    ! SAVE NEW ARRAYS IN Tx ARRAYS
    MASK=(A<2)
    TNUM=COUNT(MASK)
!    ALLOCATE(TDI(TNUM),TDEI(TNUM),TROI(TNUM),TTI(TNUM),TWI(TNUM),TPCI(TNUM),TNS(TNUM),& !Mike removing the duplicate TNS() allocation
    ALLOCATE(TDI(TNUM),TDEI(TNUM),TROI(TNUM),TTI(TNUM),TWI(TNUM),TPCI(TNUM),&
      TNS(TNUM),TGAI(TNUM),TEPSI(TNUM),TEPSII(TNUM),TTEI(TNUM+1),TFI(TNUM))
    TDI=PACK(T2DI,MASK)
    TDEI=PACK(T2DEI,MASK)
    TROI=PACK(T2ROI,MASK)
    TTI=PACK(T2TI,MASK)
    TWI=PACK(T2WI,MASK)
    TPCI=PACK(T2PCI,MASK)
    TNS=PACK(T2NS,MASK)
    TGAI=PACK(T2GAI,MASK)
    TEPSI=PACK(T2EPSI,MASK)
    TEPSII=PACK(T2EPSII,MASK)
    TTEI(1:TNUM)=PACK(T2TEI(1:NUM),MASK)
!    TTEI(TNUM+1)=NUM+1     !JG'S LINE
    TTEI(TNUM+1)=TEI(NUM+1) !MD's EDIT, 4/8/11
    TFI=PACK(T2FI,MASK)
    DEALLOCATE(T2DI,T2DEI,T2ROI,T2TI,T2WI,T2PCI,T2NS,T2GAI,T2EPSI,T2EPSII,&
      T2TEI,T2FI)
    DEALLOCATE(MASK,FITV)
  ELSE
    !IF THERE ARE NO SUCCESSIVE COHERENT LAYERS, I WILL MAP THE x ARRAYS TO 
    !  THE Tx ARRAYS...
    ALLOCATE(TDI(NUM),TDEI(NUM),TROI(NUM),TTI(NUM),TWI(NUM),TPCI(NUM),&
      TNS(NUM),TGAI(NUM),TEPSI(NUM),TEPSII(NUM),TTEI(NUM+1),TFI(NUM))
    TDI=DI
    TDEI=DEI
    TROI=ROI
    TTI=TI
    TWI=WI
    TPCI=PCI
    TNS=NS
    TGAI=GAI
    TEPSI=EPSI
    TEPSII=EPSII
    TTEI=TEI
    TFI=FI
    TNUM=NUM
  ENDIF
  DEALLOCATE(I,A) ! THIS WAS ADDED BY MD, 4/8/11. JG HAD REMOVED IT.
                  ! IT NEEDS TO BE IN SINCE A,I ARE REALLOCATED BELOW.

  ! 2) DEAL WITH ISOLATED COHERENT LAYERS BY COMBINING THESE LAYERS' EFFECTS
  ! INTO THE INTER-LAYER REFLECTIVITIES
  
  ! COUNT THE THIN LAYERS AFTER REMOVAL OF SUCCESSIVE COHERENT LAYERS. 

  ! NOTE THAT THE BOTTOM LAYER IS ALWAYS ASSUMED NON-COHERENT: DON'T COUNT IT.
  ! THIS CHANGE MADE BY MD, 4/8/11
  NTHIN=0
  DO J=2,TNUM
    IF (TFI(J)<FC ) THEN
      NTHIN=NTHIN+1
    END IF
  END DO

  ! ALLOCATE THE A ARRAY WHICH MARKS COHERENT LAYERS; THE I ARRAY SWITCHES
  !   BETWEEN MARKING INDECES OF COHERENT AND NONCOHERENT LAYERS.  THE GOAL
  !   IS TO CALCULATE THE INTERFACE REFLECTIVITIES.

!  ALLOCATE(I(NTHIN),A(TNUM)) !THIS CHANGE BY MD, 4/8/11: I SHOULD BE SAME
!    SIZE AS A. IT IS NOT USED, ANYWAY, HERE, AND IS DEALLOCATED, SO SHOULD
!    PROBABLY JUST REMOVE IN THE FUTURE.
  ALLOCATE(I(TNUM),A(TNUM)) 

  ! REDEFINE THE I AND A ARRAYS.  THE A ARRAY HAS A VALUE OF 1 FOR THIN 
  !   LAYERS AND 0 OTHERWISE, NOW THAT THERE ARE NO SUCCESSIVE COHERENT LAYERS
  K=0
  DO J=1,TNUM
    IF (TFI(J)<FC) THEN
      K=K+1
      I(K)=J
      A(J)=1
    ELSE
      A(J)=0
    END IF
  END DO
  ! THE BOTTOM LAYER IS ALWAYS ASSUMED NONCOHERENT
  A(1)=0
  DEALLOCATE(I) !I IS NOT USED NOW

  !  FIND THE VALUES OF A EQUAL TO ZERO, SAVE THE INDECES TO I
  NAEQ0=0
  DO J=1,TNUM
    IF (A(J)==0) THEN
      NAEQ0=NAEQ0+1
    END IF
  END DO
  ALLOCATE(I(NAEQ0))

  K=0
  DO J=1,TNUM
    IF (A(J)==0) THEN
      K=K+1
      I(K)=J
    END IF
  END DO

  ! CALCULATE INTERFACE REFLECTION COEFFICIENTS
  ALLOCATE(EPSI_AUG(TNUM+1),FH(TNUM),FV(TNUM))
  EPSI_AUG(1:TNUM)=TEPSI
  EPSI_AUG(TNUM+1)=1.0
  
  CALL FRESNELRC(TTEI,EPSI_AUG,FH,FV,TNUM)

  ! FOR LAYERS OF TYPE 0 SHI = FH^2
  ALLOCATE(TSIH(TNUM),TSIV(TNUM))
  DO J=1,NAEQ0
    TSIH(I(J))=FH(I(J))**2
    TSIV(I(J))=FV(I(J))**2
  END DO

  IF(NTHIN.EQ.0)THEN
    ! THERE ARE NO MORE COHERENT LAYERS AFTER REMOVAL OF SUCCESSIVE COHERENT 
    ! LAYERS SO SET THE OUTPUT ARRAYS EQUAL TO CURRENT Tx ARRAYS 
    RNUM=TNUM 
    XROI(1:RNUM)=TROI 
    XEPSI(1:RNUM)=TEPSI
    XEPSII(1:RNUM)=TEPSII
    XTEI(1:RNUM+1)=TTEI
    XSIH(1:RNUM)=TSIH
    XSIV(1:RNUM)=TSIV
    XDI(1:RNUM)=TDI
    XDEI(1:RNUM)=TDEI
    XTI(1:RNUM)=TTI
    XPCI(1:RNUM)=TPCI
    XWI(1:RNUM)=TWI
    XGAI(1:RNUM)=TGAI
  ELSE
    ! IF THERE ARE STILL COHERENT LAYERS AFTER REMOVAL OF SUCCESSIVE COHERENT
    ! LAYERS, THEN DEAL WITH THESE.  DO A REDUCTION ON LAYERS OF TYPE 0 
    !   (COHERENT LAYER EFFECTS ARE TAKEN INTO ACCOUNT IN THE LAYER 
    !   REFLECTIVITIES)

    !  FIND THE NUMBER OF VALUES OF A EQUAL TO ONE

    DEALLOCATE(I)
    NAEQ1=0
    DO J=1,TNUM
      IF (A(J)==1) THEN
        NAEQ1=NAEQ1+1
      END IF
    END DO
    ALLOCATE(I(1:NAEQ1))

    !  FIND THE VALUES OF A EQUAL TO ONE
    K=0
    DO J=1,TNUM
      IF (A(J)==1) THEN
        K=K+1
        I(K)=J
      END IF
    END DO
  
   !COMPUTE NEW INTERFACE REFLECTIVITIES
    X=0 !INITIALIZE VARIABLES
!    XSIH=TSIH
!    XSIV=TSIV
    DO J=1,NAEQ1
      X(I(J))=2*FH(I(J))*FH(I(J)-1)*COS(FI(I(J)))
      TSIH(I(J)-1)=(FH(I(J))**2+FH(I(J)-1)**2+X(I(J)))/&
        (1+FH(I(J))**2*FH(I(J)-1)**2+X(I(J)))
      X(I(J))=2*FV(I(J))*FV(I(J)-1)*COS(FI(I(J)))
      TSIV(I(J)-1)=(FV(I(J))**2+FV(I(J)-1)**2+X(I(J)))/&
        (1+FV(I(J))**2*FV(I(J)-1)**2+X(I(J)))
    END DO

    !  FIND THE NUMBER OF VALUES OF A EQUAL TO ZERO
    DEALLOCATE(I)
    NAEQ0=0
    DO J=1,TNUM
      IF (A(J)==0) THEN
        NAEQ0=NAEQ0+1
      END IF
    END DO
    ALLOCATE(I(NAEQ0))

    !  FIND THE VALUES OF A EQUAL TO ZERO
    K=0
    DO J=1,TNUM
      IF (A(J)==0) THEN
        K=K+1
        I(K)=J
      END IF
    END DO

    !  DEFINE OUTPUT VARIABLES BASED ON I ARRAY
    DO J=1,NAEQ0
!      XROI(J)=ROI(I(J))
!      XTEI(J)=TEI(I(J))
!      XDI(J)=DI(I(J))
!      XTI(J)=TI(I(J))
!      XPCI(J)=PCI(I(J))
!      XWI(J)=WI(I(J))
!      XGAI(J)=GAI(I(J))
      XROI(J)=TROI(I(J))
      XTEI(J)=TTEI(I(J))
      XDI(J)=TDI(I(J))
      XTI(J)=TTI(I(J))
      XPCI(J)=TPCI(I(J))
      XWI(J)=TWI(I(J))
      XGAI(J)=TGAI(I(J))
   
!      XSIH(J)=XSIH(I(J))
!      XSIV(J)=XSIV(I(J))

      XSIH(J)=TSIH(I(J))
      XSIV(J)=TSIV(I(J))

!      XEPSI(J)=EPSI(I(J))
!      XEPSII(J)=EPSII(I(J))
!      XDEI(J)=DEI(I(J))
      XEPSI(J)=TEPSI(I(J))
      XEPSII(J)=TEPSII(I(J))
      XDEI(J)=TDEI(I(J))
    END DO

    RNUM=TNUM-NTHIN
    XTEI(RNUM+1)=THETA 
  END IF
  DEALLOCATE(TDI,TDEI,TROI,TTI,TWI,TPCI,TNS,TGAI,TEPSI,TEPSII,TTEI,TFI,&
     TSIH,TSIV)
ELSE
  ! THERE ARE NO COHERENT LAYERS (OR ONLY ONE LAYER), SO SET THE OUTPUT 
  ! ARRAYS EQUAL TO THE INPUT ARRAYS
  RNUM=NUM 
  XROI=ROI
  XEPSI=EPSI
  XEPSII=EPSII
  XTEI=TEI
  XSIH=SIH
  XSIV=SIV
  XDI=DI
  XDEI=DEI
  XTI=TI
  XPCI=PCI
  XWI=WI
  XGAI=GAI
END IF

DEALLOCATE( NS,FI, X )
 
END SUBROUTINE SLRED


! -------------------------------------------------------------------------
!
SUBROUTINE SNOWAO(V,A,NUM)
!
! -------------------------------------------------------------------------
!
!     CODE ORIGINALLY OBTAINED IN MATLAB FROM MATZLER
!
!   COMPUTES THE DEPOLARIZATION FACTOR OF OBLATE SNOW GRAINS
!   NOTE 10, MTZLER 1997
!
!   A = SNOWAO(V)
!       A:    DEPOLARIZATION FACTOR OF OBLATE SNOW GRAINS
!       V:    VOLUME FRACTION OF ICE
!
!   VERSION HISTORY:
!      1.0    WI 29.5.98
!      2.0    MD 1 APR 05 TRANSLATED TO FORTRAN FROM MATLAB
!
!   USES: NONE
!       
!   COPYRIGHT (C) 1997 BY THE INSTITUTE OF APPLIED PHYSICS, 
!   UNIVERSITY OF BERN, SWITZERLAND


IMPLICIT NONE
INTEGER, INTENT(IN) :: NUM
REAL, INTENT(IN) :: V(NUM)
REAL, INTENT(OUT) :: A(NUM)
INTEGER I

DO I=1,NUM
  A(I)=0.3
  IF (V(I)<0.55) THEN
    A(I)=0.476-0.64*V(I)
  END IF
  IF (V(I)<=0.333) THEN
    A(I)=0.1+0.5*V(I)
  END IF
END DO

END SUBROUTINE SNOWAO


! -------------------------------------------------------------------------
!
SUBROUTINE INVERT_MATRIX(MA,INV,N)
!
! -------------------------------------------------------------------------
!     
!     MATRIX INVERSION ALGORITHM OBTAINED FROM GOTOP FORTRAN 90 TEXT,
!     ISBN:957-566-172-9
!
!     COPIED FROM THE COMPANION CD TO THAT TEXT BY MIKE, 1 APRIL 2005

IMPLICIT NONE

INTEGER,INTENT(IN) :: N
REAL,INTENT(IN) :: MA(N,N)
REAL,INTENT(OUT) :: INV(N,N)
REAL,dimension(:,:),allocatable :: temp
INTEGER I,J
 
allocate(temp(n,n))

DO I=1,N
  DO J=1,N
    TEMP(I,J)=MA(I,J)
    INV(I,J)=0.
  END DO
  INV(I,I)=1.
END DO

!print *, 'before upper call'
CALL UPPER(TEMP,INV,N)
!print *, 'before lower call'
CALL LOWER(TEMP,INV,N)

!print *, 'before inv calc'
DO I=1,N
  DO J=1,N
    INV(I,J)=INV(I,J)/TEMP(I,I)
  END DO
END DO

!print *, 'before deallocation'
deallocate(temp)

CONTAINS

SUBROUTINE UPPER(M,S,N)
INTEGER,INTENT(IN):: N
INTEGER I,J,K
REAL E
REAL,INTENT(INOUT):: M(N,N)
REAL,INTENT(INOUT):: S(N,N)

DO I=1,N-1
  DO J=I+1,N            
    E=M(J,I)/M(I,I)
    DO K=1,N
      M(J,K)=M(J,K)-M(I,K)*E
      S(J,K)=S(J,K)-S(I,K)*E
    END DO
  END DO
END DO

END SUBROUTINE UPPER

SUBROUTINE LOWER(M,S,N)
INTEGER,INTENT(IN):: N
REAL,INTENT(INOUT):: M(N,N)
REAL,INTENT(INOUT):: S(N,N)
INTEGER I,J,K
REAL E

DO I=N,2,-1
  DO J=I-1,1,-1         
    E=M(J,I)/M(I,I)
    DO K=1,N
      M(J,K)=M(J,K)-M(I,K)*E
      S(J,K)=S(J,K)-S(I,K)*E 
    END DO
  END DO
END DO

END SUBROUTINE LOWER

END SUBROUTINE INVERT_MATRIX


! -------------------------------------------------------------------------
!
SUBROUTINE ATM_MODEL(N_F,N_INS,FREQ,THETAD,ATM_IN,TSKY,TRAN)
!
! -------------------------------------------------------------------------

!     CODE ORIGINALLY OBTAINED IN MATLAB FROM PULLIAINEN AS SKYTEMP 
!
!
!     FUNCTION FOR CALCULATING THE ATMOSPHERIC BRIGHTNESS TEMPERATURE
!      AND TRANSMISSIVITY
!     
!     BY K. TIGERSTEDT 1997
!
!     [TSKY,TRAN] = SKYTEMP(FREQ,THETAD,STEP,P0,T0,MONTH,MOIST0) 
!
!       FREQ RANGE; FREQ=[1 5 10 15 19:24 30 40 50 55:65 70 80 90 100]  [GHZ]
!       STEP SIZE; TYP.  STEP = 0.05 [KM] (NOW HARDCODED IN)
!       GROUND PRESSURE; TYP. P0 = 1013 [MBAR] : ATM_IN(1)
!       GROUND TEMP.; TYP. T0 = 293.15 [K] : ATM_IN(2)
!       SEASON (MONTH) [1..12]; : ATM_IN(3)
!       GROUND-LEVEL WATER-VAPOUR; TYP. MOIST0 = 7.5 [G/M^3] ATM_IN(4)
!
!       NOTE: CLOUD DATA NOT USED YET: HERE IS OLD COMMENT:
!       CLOUD DATA: CLOUD_DATA = [CLOUD_ANAL CL_LOWER CL_UPPER MV RC ALFA GAMMA]
!
!       NOTE: THIS BIT ABOUT CLOUDS IRRELEVANT, SINCE CLOUDS NOT INCLUDED HERE.
!
!       WHERE 
!             CLOUD_ANAL  = 0/1   INCLUSION OF CLOUD ANALYSIS
!             CL_LOWER    = LOWER BOUNDARY OF CLOUD [KM]
!             CL_UPPER    = UPPER BOUNDARY OF CLOUD [KM]
!             MV          = LIQUID WATER CONTENT OF CLOUD [G/M^3]
!             RC          = MEAN DROP RADIUS 
!             ALFA, GAMMA = SHAPE PARAMETERS
!
!       1.0   KT  ? ??? 97
!       2.0   MD  2 JUN 05  TRANSLATED TO FORTRAN
!       2.1   MD 19 SEP 05  MODIFIED TO TAKE INPUTS AS ARRAYS,HARDCODE 'STEPS'
!   
!   USES: PRES
!         TEMP
!         WVPROF
!         OXABSORP
!         WVABSORB
!

IMPLICIT NONE

INTEGER,INTENT(IN) :: N_F,N_INS
REAL, INTENT(IN) :: ATM_IN(N_INS),FREQ(N_F),THETAD(N_F)
REAL :: STEP,P0,T0,MOIST0
REAL, INTENT(INOUT) :: TSKY(N_F),TRAN(N_F)
INTEGER I,J,N_STEPS,MONTH
REAL MYCEILING,TCOSMIC,T0K,PI,ATTCO,TAU_Z,TATM,KAPPA_DZ_OLD,&
       H,P,T,WV,CLOUD_SCA,CLOUD_EXT,CLOUD_ABS,K_O2,K_WV,KAPPA_DZ,&
       TOTAL_TAU_Z,TOTAL_ATTCO
real,dimension(:),allocatable :: theta

allocate(theta(n_f))

! EXTRACT INPUT DATA
P0=ATM_IN(1)
T0=ATM_IN(2)
MONTH=ATM_IN(3)
MOIST0=ATM_IN(4)

STEP=0.05 ! THIS LINE ADDED BY MIKE 9/19/05: HARDCODE STEP

MYCEILING=20.
TCOSMIC=2.7
T0K=273.15
PI=3.14159
THETA=THETAD/180*PI

N_STEPS=MYCEILING/STEP+1

DO I=1,N_F
  ATTCO=0.0
  TAU_Z=0.0
  TATM=0.0
  KAPPA_DZ_OLD=0.0

  DO J=1,N_STEPS
    H=MYCEILING-STEP*(J-1)
    CALL PRES(P0,H,P)
    CALL TEMP(T0,H,MONTH,T)
    CALL WVPROF(MOIST0,H,WV)
    ! FOR NOW, ASSUME THAT THERE ARE NO CLOUDS
    CLOUD_SCA=0.0
    CLOUD_EXT=0.0
    CLOUD_ABS=0.0

    ! NOTE THAT WE APPROXIMATE T_UP AS T_DOWN... SEE TEXT ON P.283
    CALL OXABSORP(FREQ(I),T,P,K_O2)
    CALL WVABSORB(FREQ(I),T,P,WV,K_WV)  
    ! PART OF THE INTEGRAND IN 5.44
    KAPPA_DZ=(K_O2+K_WV)*STEP/(10*LOG10(EXP(1.0)))+CLOUD_ABS*STEP*1000
    ! PART OF THE INTEGRAND IN 5.44
    TAU_Z=TAU_Z+KAPPA_DZ_OLD/COS(THETA(I))
    ! THIS IS 5.47, L_THETA
    ATTCO=EXP(-TAU_Z)
    ! THIS MAY BE 5.49
    TATM=TATM+(1-EXP(-KAPPA_DZ/COS(THETA(I))))*T*ATTCO
    KAPPA_DZ_OLD=KAPPA_DZ+CLOUD_SCA*STEP*1000
  END DO
  TOTAL_TAU_Z=TAU_Z+KAPPA_DZ_OLD/COS(THETA(I))
  TOTAL_ATTCO=EXP(-TOTAL_TAU_Z)
   
  TSKY(I) = TATM
  TRAN(I) = TOTAL_ATTCO       
END DO

deallocate(theta)

END SUBROUTINE ATM_MODEL


! -------------------------------------------------------------------------
!
SUBROUTINE PRES(P0,Z,P)
!
! -------------------------------------------------------------------------
!     FUNCTION FOR CALCULATING VERTICAL PRESSURE PROFILES
!     ASSUME EXPONETIAL PRESSURE PROFILE
!     P0 = SEA LEVEL PRESSURE
!     Z = HEIGHT [KM]
!
!     HISTORY
!       1.0   KT ? ??? ??
!       2.0   MD 6 JUN 05  TRANSLATED TO FORTRAN
!
!     CODE ORIGINALLY OBTAINED IN MATLAB FROM PULLIAINEN


IMPLICIT NONE

REAL,INTENT(IN)::P0,Z
REAL,INTENT(OUT)::P
REAL ZP
   
ZP=7.7 ! PRESSURE SCALE HEIGHT 7.7 KM
P=P0*EXP(-Z/ZP)

END SUBROUTINE PRES


! -------------------------------------------------------------------------
!
SUBROUTINE TEMP(T0,Z,MONTH,T)
!
! -------------------------------------------------------------------------
!     FUNCTION FOR CALCULATING VERTICAL TEMPERATURE PROFILE
!     T0 = GROUND TEMPERATURE [K]
!     Z = HEIGHT [KM]
!     MONTH = [1..12]
!
!     HISTORY
!       1.0   KT ? MAR 97  PROGRAMMED
!       1.1   KT ? DEC 97  UPDATED
!       2.0   MD 6 JUN 05  TRANSLATED TO FORTRAN
!
!     CODE ORIGINALLY OBTAINED IN MATLAB FROM PULLIAINEN

INTEGER,INTENT(IN) :: MONTH
REAL,   INTENT(IN) :: T0,Z
REAL,   INTENT(OUT):: T

REAL :: H1,H2,G2,K1,K2,K3 

real :: T1, T2

H1=8

IF (MONTH.EQ.1)THEN
        K1 = 2.958E-3
        K2 = -5.832E-3
        K3 = 3.771E-4
        T2 = 217
        H2 = 8.5
ELSEIF (MONTH.EQ.2)THEN
        K1 = -2.196E-3
        K2 = -4.419E-3
        K3 = 2.673E-4
        T2 = 218.33
        H2 = 8.75
ELSEIF (MONTH.EQ.3)THEN
        K1 = -1.717E-2
        K2 = -4.056E-4
        K3 = -4.252E-5
        T2 = 219.67
        H2 = 9
ELSEIF (MONTH.EQ.4)THEN
        K1 = -2.702E-2
        K2 = 2.327E-3
        K3 = -2.521E-4
        T2 = 221.00
        H2 = 9.25
ELSEIF (MONTH.EQ.5)THEN
        K1 = -3.33E-2
        K2 = 3.915E-3
        K3 = -3.616E-4
        T2 = 222.33
        H2 = 9.5
ELSEIF (MONTH.EQ.6)THEN
        K1 = -3.461E-2
        K2 = 4.154E-3
        K3 = -3.632E-4
        T2 = 223.67
        H2 = 9.75
ELSEIF (MONTH.EQ.7)THEN
        K1 = -3.213E-2
        K2 = 3.69E-3
        K3 = -3.317E-4
        T2 = 225
        H2 = 10.0
ELSEIF (MONTH.EQ.8)THEN
        K1 = -3.05E-2
        K2 = 3.423E-3
        K3 = -3.182E-4
        T2 = 223.67
        H2 = 9.75
ELSEIF (MONTH.EQ.9)THEN
        K1 = -2.928E-2
        K2 = 3.543E-3
        K3 = -3.472E-4
        T2 = 222.33
        H2 = 9.5
ELSEIF (MONTH.EQ.10)THEN
        K1 = -1.997E-2
        K2 = 1.777E-3
        K3 = -2.621E-4
        T2 = 221
        H2 = 9.25
ELSEIF (MONTH.EQ.11)THEN
        K1 = -1.533E-2
        K2 = 8.062E-4
        K3 = -2.24E-4
        T2 = 219.67
        H2 = 9.0
ELSEIF (MONTH.EQ.12)THEN
        K1 = -5.856E-3
        K2 = -2.773E-3
        K3 = 1.086E-4
        T2 = 218.33
        H2 = 8.75
END IF

T1 = T0*(1 + K1*H1 + K2*H1**2 + K3*H1**3)

IF (Z.LT.8) THEN
        T = T0*(1 + K1*Z + K2*Z**2 + K3*Z**3)
ELSEIF (Z.GE.8.AND.Z.LT.H2)THEN
        T = (T1-T2)*(Z-H2) / (H1 - H2) + T2
ELSEIF (Z.GE.H2.AND.Z.LE.20) THEN
        T = T2
END IF      
 
END SUBROUTINE TEMP


! -------------------------------------------------------------------------
!
SUBROUTINE WVPROF(M0,Z,M)
!
! -------------------------------------------------------------------------
!     FUNCTION FOR CALCULATING VERTICAL WATER VAPOUR PROFILES
!     ASSUME EXPONETIAL PRESSURE PROFILE
!     M0 = SEA LEVEL PRESSURE
!     Z = HEIGHT [KM]
!
!     HISTORY
!       1.0   KT ? ??? ??
!       2.0   MD 6 JUN 05  TRANSLATED TO FORTRAN
!
!     CODE ORIGINALLY OBTAINED IN MATLAB FROM PULLIAINEN

IMPLICIT NONE

REAL,INTENT(IN)::M0,Z
REAL,INTENT(OUT)::M
REAL ZM
   
ZM=2.35 ! WATER VAPOUR SCALE HEIGHT 2.35 KM
M=M0*EXP(-Z/ZM)

END SUBROUTINE WVPROF


! -------------------------------------------------------------------------
!
SUBROUTINE OXABSORP(F,T,P,K_O2)
!
! -------------------------------------------------------------------------
!     FUNCTION FOR CALCULATING OXYGEN ABSORPTION COEFFICIENT [DB/KM]
!     F IS FREQUENCY IN GHZ
!     T IS TEMPERATURE IN KELVINS
!     P IS PRESSURE IN MILLIBARS
!
!     HISTORY
!       1.0   KT ? NOV 96  PROGRAMMED
!       1.1   ?? ? FEB 98  ABSORPTION DATA NOW INCLUDED IN FUNCTION
!       2.0   MD 6 JUN 05  TRANSLATED TO FORTRAN
!
!     CODE ORIGINALLY OBTAINED IN MATLAB FROM PULLIAINEN

 IMPLICIT NONE

 REAL,INTENT(IN):: F,T,P
 REAL,INTENT(OUT)::K_O2
 INTEGER I
 REAL OXFIC(20,4),FNP(20),FNM(20),YNP(20),YNM(20),SIGMA,&
        GAN,GAB,DNP,DNM,GNPLUSF,GNPLUSMF,GNMINUSF,GNMINUSMF,&
        THETAN,FDOT,NR
 INTEGER N
 

 ! THESE DATA IN TABLE 5.4 IN ULABLY (1981) 
 OXFIC=RESHAPE((/&
 56.2648,118.7503,4.51e-4,-2.14e-5,& 
 58.4466,62.4863,4.94e-4,-3.78e-4,& 
 59.5910,60.3061,3.52e-4,-3.92e-4,&
 60.4348,59.1642,1.86e-4,-2.68e-4,&
 61.1506,58.3239,3.30e-5,-1.13e-4,&
 61.8002,57.6125,-1.03e-4,3.44e-5,&
 62.4112,56.9682,-2.23e-4,1.65e-4,&
 62.9980,56.3634,-3.32e-4,2.84e-4,&
 63.5685,55.7838,-4.32e-4,3.91e-4,&
 64.1278,55.2214,-5.26e-4,4.93e-4,&
 64.6789,54.6711,-6.13e-4,5.84e-4,&
 65.2241,54.1300,-6.99e-4,6.76e-4,&
 65.7647,53.5957,-7.74e-4,7.55e-4,&
 66.3020,53.0668,-8.61e-4,8.47e-4,&
 66.8367,52.5422,-9.11e-4,9.01e-4,&
 67.3694,52.0212,-1.03e-3,1.03e-3,&
 67.9007,51.5030,-9.87e-4,9.86e-4,&
 68.4308,50.9873,-1.32e-3,1.33e-3,&
 68.9601,50.4736,-7.07e-4,7.01e-4,&
 69.4887,49.9618,-2.58e-3,2.64e-3/),&
 (/20,4/),ORDER=(/2,1/))

 FNP=OXFIC(:,1)
 FNM=OXFIC(:,2)
 YNP=OXFIC(:,3)
 YNM=OXFIC(:,4)
 
 SIGMA=0

 DO N=1,39,2
   I=(N-1)/2+1
   
   ! THESE NEXT FOUR STATEMENTS ARE FROM 5.37-5.39 IN ULABLY (1981)
   GAN = 1.18*(P/1013)*(300/T)**0.85
   GAB = 0.49*(P/1013)*(300/T)**0.89

   ! THIS PART JUST CHANGED... MD
   NR=REAL(N)
   DNP = SQRT(NR*(2.*NR+3.)/((NR+1.)*(2.*NR+1.)))
   DNM = SQRT((NR+1.)*(2.*NR-1)/(NR*(2.*NR+1.)))

   !THESE CORRESPOND TO 5.35
   GNPLUSF=(GAN*DNP**2+P*(F-FNP(I))*YNP(I))/((F-FNP(I))**2+GAN**2)
   GNPLUSMF=(GAN*DNP**2+P*(-F-FNP(I))*YNP(I))/((-F-FNP(I))**2+GAN**2)
   GNMINUSF=(GAN*DNM**2+P*(F-FNM(I))*YNM(I))/((F-FNM(I))**2+GAN**2)
   GNMINUSMF=(GAN*DNM**2+P*(-F-FNM(I))*YNM(I))/((-F-FNM(I))**2+GAN**2)

   !THIS CORRESPONDS TO 5.36
   THETAN = 4.6E-3*(300/T)*(2*N+1)*EXP(-6.89E-3*N*(N+1)*(300/T))

   ! THIS CORRESPONDS TO THE SECOND TERM ON RHS OF 5.34
   SIGMA = SIGMA + THETAN*(GNPLUSF + GNPLUSMF + GNMINUSF + GNMINUSMF)
 END DO

 !THIS CORRESPONDS TO 5.34
 FDOT = 0.7*GAB/(F**2 + GAB**2) + SIGMA

 !THIS CORRESPONDS TO 5.33
 K_O2 = 1.61E-2*F**2*(P/1013)*(300/T)**2*FDOT

 END SUBROUTINE OXABSORP


! -------------------------------------------------------------------------
!
SUBROUTINE WVABSORB(F,T,P,PV,K_WV)
!
! -------------------------------------------------------------------------
!     FUNCTION FOR CALCULATING WATER-VAPOR ABSORPTION [DB/KM]
!
!     F IS FREQUENCY IN GHZ
!     T IS TEMPERATURE IN KELVINS
!     P IS PRESSURE IN MILLIBARS
!     PV = WATER-VAPOR DENSITY IN G/M^3
!
!     HISTORY
!       1.0   KT ? NOV 96
!       2.0   MD 6 JUN 05  TRANSLATED TO FORTRAN
!
!     CODE ORIGINALLY OBTAINED IN MATLAB FROM PULLIAINEN

REAL,INTENT(IN)::F,T,P,PV
REAL,INTENT(OUT)::K_WV
INTEGER I
REAL WVLINE(10,6),FI(10),EI(10),AI(10),GI0(10),AI_LC(10),XI(10),&
       GI,SIGMA,KH2O,DKAPPA

!     TABLE 5.3 IN ULABLY (1981)
WVLINE=RESHAPE((/&
22.23515,  644.0,  1.0,   2.85, 1.75, 0.626,&
183.31012, 196.0,  41.9,  2.68, 2.03, 0.649,&
323.00000, 1850.0, 334.4, 2.30, 1.95, 0.420,&
325.15380, 454.0,  115.7, 3.03, 1.85, 0.619,&
380.19680, 306.0,  651.8, 3.19, 1.82, 0.630,&
390.00000, 2199.0, 127.0, 2.11, 2.03, 0.330,&
436.00000, 1507.0, 191.4, 1.50, 1.97, 0.290,&
438.00000, 1070.0, 697.6, 1.94, 2.01, 0.360,&
442.00000, 1507.0, 590.2, 1.51, 2.02, 0.332,&
448.00080, 412.0,  973.1, 2.47, 2.19, 0.510/),&
 (/10,6/),ORDER=(/2,1/))

FI = WVLINE(:,1)
EI = WVLINE(:,2)
AI = WVLINE(:,3)
GI0 = WVLINE(:,4)
AI_LC = WVLINE(:,5)
XI = WVLINE(:,6)

SIGMA = 0.

DO I=1,10
  !THIS CORRESPONDS TO 5.29
  GI=GI0(I)*(P/1013.)*(300./T)**XI(I)*(1.+10.**(-2.)*AI_LC(I)*PV*T/P)

  !THIS CORRESPONDS TO SUMMATION TERM IN 5.28
  SIGMA=SIGMA+AI(I)*EXP(-EI(I)/T)*GI/((FI(I)**2-F**2)**2+4*F**2*GI**2)
END DO

!THIS CORRESPONDS TO 5.28
KH2O = 2*F**2*PV*(300/T)**2.5*SIGMA

!THIS CORRESPONDS TO 5.31
DKAPPA = 4.69E-6*PV*(300/T)**2.1*(P/1000)*F**2

!THIS CORRESPONDS TO 5.30
K_WV = KH2O+DKAPPA

END SUBROUTINE WVABSORB




subroutine test_ss_model()

use utilities_mod, only : logfileunit
use     types_mod, only : r4

! test THE forward observation operator

integer, parameter :: N_FREQ = 1  ! observations come in one frequency at a time
integer, parameter :: N_POL  = 2  ! code automatically computes both polarizations
integer   :: nlayers              ! number of snow levels - 5 in this case
character :: pol                  ! observation polarization [H,V]

! variables required by ss_snow() routine
real(r4), allocatable, dimension(:,:) :: y ! 2D array
real(r4) :: aux_ins(5) ! properties: [nlyrs, ground_T, soilsat, poros, proportionality]
integer  :: ctrl(4)        ! N_LYRS, N_AUX_INS, N_SNOW_INS, N_FREQ
real(r4) :: freq( N_FREQ)  ! frequencies at which calculations are to be done
real(r4) :: tetad(N_FREQ)  ! incidence angle of satellite
real(r4) :: tb_ubc(N_POL,N_FREQ) ! UPPER BOUNDARY CONDITION BRIGHTNESS TEMPERATURE
real(r4) :: tb_out(N_POL,N_FREQ) ! brightness temperature

tetad(:) = 55.0   ! AMSR-E incidence angle
freq(:)  = 89.0   ! test frequency (GHz)
pol      = 'H'    ! test polarization
nlayers  = 5      ! 5 snow layers in test

allocate( y(nlayers,5) ) ! snow layers -x- 5 properties

tb_ubc(:,N_FREQ) = (/ 2.7, 2.7 /)  ! two polarizations

ctrl(1) = nlayers
ctrl(2) = 0         ! not used as far as I can tell
ctrl(3) = 5
ctrl(4) = N_FREQ

aux_ins(1) = real(nlayers,r4)
aux_ins(2) = 271.1123
aux_ins(3) = 0.3
aux_ins(4) = 0.4
aux_ins(5) = 0.5_r4

y(:,1) = (/   0.6213,   0.2071,   0.1033,   0.0497,   0.0200 /) ! snow thickness (meters)
y(:,2) = (/ 270.5943, 150.7856,  96.1940,  66.4903,  58.0377 /) ! density (kg/m3)
y(:,3) = (/  93.1651,  84.0811,  67.6715,  66.8529,  65.6391 /) / 1000000.0_r4  ! grain diameter (m)
y(:,4) = (/   0.0000,   0.0000,   0.0000,   0.0000,   0.0000 /) ! liquid water fraction
y(:,5) = (/ 266.1220, 256.7763, 247.9525, 240.4609, 235.8929 /) ! temperature (K)

! the tb_out array contains the calculated brightness temperature outputs
! at each polarization (rows) and frequency (columns).

call ss_model(ctrl, freq, tetad, y, tb_ubc, aux_ins, tb_out)

write(     *     ,*)'ss_model() TEST: tb_out is ',tb_out,' should be  205.9256 206.9057'
write(logfileunit,*)'ss_model() TEST: tb_out is ',tb_out,' should be  205.9256 206.9057'

deallocate( y )

end subroutine test_ss_model



end module rtm_memls_ss_mod

! <next few lines under version control, do not edit>
! $URL$
! $Id$
! $Revision$
! $Date$

