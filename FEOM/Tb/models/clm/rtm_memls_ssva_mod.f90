
! This code is not protected by the DART copyright agreement.
!
! DART $Id$

module rtm_memls_ssva_mod

use types_mod, only : digits12

implicit none
private

public :: ssva_rtm

logical :: debug = .false.

contains

subroutine ssva_rtm(ctrl,FREQ,TETAD,Y,LAI,tb_ubc,aux_ins,VEGDATA,CAN_TRAN3_IN,ATMOSDATA,tb_out)

! ----------------------------------------------------------------------------------------------
!
!     SOIL, SNOW, VEGETATION AND ATMOSPHERE RADIATIVE TRANSFER MODEL (SSVA RTM)
!
!     FORTRAN 90 VERSION OF MEMLS PROGRAM (ORIGINALLY WRITTEN BY WIESMANN AND MATZLER TO COMPUTE 
!       BRIGHTNESS TEMPERATURES OF N-LAYERED SNOWPACKS) INTEGRATED WITH A CANOPY RADIATIVE 
!       TRANSFER MODEL , AS WELL AS AN ATMOSPHERIC RADIATIVE TRANSFER MODEL BASED ON THE HELSINKI 
!       UNIVERSITY OF TECHNOLOGY (HUT) SOFTWARE PACKAGE DESIGNED FOR RETRIEVAL OF GEOPHYSICAL 
!       PARAMETERS, BY TIGERSTEDT AND PULLIAINEN. ANY NUMBER OF CALCULATIONS CAN BE DONE WITH 
!       DIFFERENT SNOWPACK PROPERTIES, FREQUENCIES, ANGLES, ETC.  IN THE CURRENT VERSION, EACH 
!       SNOWPACK MUST HAVE THE SAME NUMBER OF LAYERS, HOWEVER.  IN ADDITION, THIS CODE IS DESIGNED 
!       TO WORK WITH SNOWPACKS WITH INCOHERENT LAYERS OR WITH ONE COHERENT LAYER.  MORE SPECIFICALLY, 
!       THE CODE CANNOT HANDLE THE CASE WHERE THERE ARE SUCCEEDING COHERENT LAYERS.  IN THIS CASE, 
!       THE PROGRAM WILL WRITE 999 TO THE OUTPUT FILE.
!
!     TRANSLATED (FROM MATLAB CODES) BY MIKE DURAND AT UCLA WORKING UNDER STEVE MARGULIS, 27 MAY 05
!       EMAIL MIDURAND@UCLA.EDU (OR MARGULIS@SEAS.UCLA.EDU) WITH QUESTIONS.  ON THE MEMLS MODEL
!       SEE WIESMANN AND MATZLER 99 IN REM. SENS. ENV., MATZLER AND WIESMANN 99 IN REM. SENS. ENV.
!       ON THE VEGETATION TRANSFER MODEL, SEE WEGMULLER ET AL. (1994).  ON THE ATMOSPHERIC TRANSFER
!       MODEL, SEE SEE ULABLY ET AL., 1981.
!
! ----------------------------------------------------------------------------------------------
!
!
!     1.DESCRIPTION.  THE CODE IS A COMPOSITE OF THE MEMLS2 CODE RECEIVED THROUGH CORRESPONDENCE 
!       WITH MATZLER, AND THREE HUT CODES RECEIVED THROUGH CORRESPONDENCE WITH PULLIAINEN USED FOR 
!       A) DETERMINING THE REFLECTIVITY OF THE GROUND SURFACE, B) DETERMINING THE OPACITY OF 
!       THE VEGETATION LAYER, AND C) DETERMINING THE OPACITY OF THE ATMOSPHERE.  ALL THREE CODES 
!       WERE WRITTEN IN MATLAB AND WERE OBTAINED BY MIKE OR STEVE SOMETIME IN 2003.  THE MEMLS CODE 
!       USES THE GROUND REFLECTIVITY AND THE SNOWPACK DATA TO COMPUTE THE BRIGHTNESS TEMPERATURE 
!       OF THE SNOWPACK AND GROUND SCENE. AFTER THE OPACITY OF THE VEGETATION LAYER IS COMPUTED, 
!       THE EMITTED BRIGHTNESS TEMPERATURE OF THE GROUND, SNOW AND VEGETATION IS COMPUTED, USING 
!       THE CANOPY PROPERTIES AND UPWELLING BRIGHTNESS TEMPERATURES AND EMISSIVITIES OF THE SNOWPACK 
!       AND GROUND SCENE.  THE CODE WAS TRANSLATED TO FORTRAN IN ORDER TO SAVE COMPUTATION TIME IN 
!       A DATA ASSIMILATION SCHEME IN WHICH MILLIONS OF CALLS MUST BE MADE TO THE RADIATIVE TRANSFER 
!       MODEL .  IN TESTS, ONE HUNDRED BRIGHTNESS TEMPERATURE CALCULATIONS TOOK TEN TIMES LESS 
!       PROCESSOR TIME IN THIS FORTRAN VERSION THAN IN THE ORIGINAL MATLAB.  EXTENSIVE VERIFICATION 
!       WAS PERFORMED USING DATA FROM SNOWPIT DATA FOR NINE DAYS IN ONE WINTER DURING THE CLPX PROGRAM 
!       AS WELL AS 3-LAYER SNOWMODEL RESULTS FROM THE MODIFIED SAST (SUN ET AL, 99 IN JGR) + SSIB 
!       MODEL RUN AT MAMMOTH MOUNTAIN, TO ENSURE THAT THE FORTRAN CODE PRODUCES IDENTICAL RESULTS AS
!       THE MATLAB CODE.
!
!     2. MODIFICATION.  THE MAIN CHANGE MADE TO THE MEMLS CODE IN THE TRANSLATION PROCESS WAS THAT
!       THE VAN POLDER APPROXIMATION (EFFECTIVE MIXING THEORY) WAS  NO LONGER BEING USED IN 
!       THE MATLAB CODES WHEN I RECEIVED THEM.  IN FACT, THE REAL PART OF THE SNOW DIELECTRIC 
!       WAS USED INSTEAD IN SEVERAL SUBROUTINES. THIS WAS SLIGHTLY INCONSISTENT WITH THE PAPERS, 
!       SO (FOLLOWING MATZLER'S ADVICE VIA EMAIL) I WROTE A NEW 'POLDER' SUBROUTINE WHICH USES 
!       THE NEWTON-RAPHSON APPROXIMATION TO SOLVE FOR THE SNOW EFFECTIVE PERMITTIVITY - SEE
!       MATZLER'S 1996 PAPER IN IEEE FOR THE EQUATIONS AND THE SUBROUTINE COMMENTS BELOW.  
!       ACCORDING TO COMPARISON WITH THE SNOWPIT DATA RESULTS, THE EFFECT OF USING THE SNOW 
!       DIELECTRIC INSTEAD OF EFFECTIVE PERMITTIVITY ON THE BRIGHTNESS TEMPREATURE WAS MINIMAL 
!       (~0.1 DEGREE).  HOWEVER, BECAUSE I COULD NOT TEST WITH A MORE EXTENSIVE DATASET, I LEFT 
!       THE SLIGHTLY MORE COMPUTATIONALLY  EXPENSIVE EFFECTIVE PERMITTIVITY CALCULATION IN PLACE
!       FOR THE SAKE OF INTERNAL CONSISTENCY.
!
!       ANOTHER CHANGE THAT I MADE TO MEMLS WAS TO SET UP THE PROGRAM TO READ IN SNOW GRAIN 
!       DIAMETER SINCE THIS IS USUALLY WHAT IS MEASUSRED IN SNOWPITS AND MODELED BY PROGNOSTIC
!       EQUATIONS IN SNOW MODELS.  THE CONSTANT OF PROPORTIONALITY BETWEEN THE GRAIN DIAMETER
!       AND THE CORRELATION LENGTH (SEE MATLZER, 2002 IN JOURNAL OF GLACIOLOGY) IS ALSO READ IN.
!
!       A THIRD CHANGE I MADE TO MEMLS WAS TO USE A SWITCH TO DETERMINE WHETHER THE BORN APPROXIMATION 
!       OR THE EMPIRICAL SCATTERING COEFFICIENT WOULD BE USED.  IF THE MAXIMUM CORRELATION 
!       LENGTH IN THE SNOWPACK IS GREATER THAN 0.33 MM, THE BORN APPROXIMATION IS USED; OTHERWISE,
!       THE EMPIRICAL FORMULA IS USED.
!
!       FINALLY, THE CANOPY MODEL WAS MODIFIED SOMEWHAT IN ORDER TO BRING THE CODE INTO 
!       LINE WITH THE PAPER BY WEGMULLER ET AL. (1995) IN "PASSIVE MICROWAVE REMOTE SENSING OF 
!       LAND-ATMOSPHERE INTERACTIONS: ESA/NASA INTERNATIONAL WORKSHOP".  THREE PRIMARY CHANGES WERE
!       MADE.  FIRST, THE INPUTS WERE MODIFIED TO BE CANOPY HEIGHT, NEEDLE LENGTH, NEEDLE 
!       THICKNESS AND NEEDLE NUMBER DENSITY INSTEAD OF BIOMASS, VEGETATION DENSITY AND NEEDLE
!       THICKNESS.  SECOND, THE RESISTIVE SHEET APPROXIMATION WHICH WAS MADE TO COMPUTE THE 
!       ABSORPTION COEFFICIENT WAS REMOVED, AND THE FULL EQUATIONS IN WEGMULLER ET AL. (1995)
!       WERE IMPLEMENTED.  FINALLY, AN ERROR WAS CORRECTED.  IN THE DERIVATION OF THE CANOPY 
!       OPACITY, IT IS ASSUMED THAT THE NEEDLES ARE HORIZONTAL.  THIS RESULTS IN THE INCIDENCE
!       ANGLE ON THE NEEDLES BEING EQUAL TO THE OBSERVATION ANGLE.  PREVIOUSLY, THE INCIDENCE
!       ANGLE AND OBSERVATION ANGLE WERE BOTH REQUIRED AS INPUTS INTO THE MODEL.  WITH RESPECT TO THE
!       GEOMETRICAL PARAMETER A_P, THIS IS GIVEN IN TABLE 1 IN THE SAME PUBLICATION FOR HORIZONTAL
!       LEAVES AND NEEDLES, SO IT SHOULD NOT BE REQUIRED AS A PARAMETER.
!
!     3. COMPLETENESS.  I TRANSLATED EVERYTHING PRECISELY AS IT WAS IN THE MATLAB CODE AS CLOSELY
!       AS POSSIBLE.  THE ONLY EXCEPTION WAS THAT (BECAUSE I TYPICALLY DON'T WORK WITH SNOWPIT
!       DATA WITH VERY THIN LAYERS) I REMOVED THE ABILITY TO DEAL WITH SUCCEEDING COHERENT SNOWPACK 
!       LAYERS IN THE INTEREST OF FINISHING THE TRANSLATION IN A TIMELY MANNER.  I TRANSLATED 
!       ONLY THE BEGINNING OF THE SLRED SUBROUTINE, AND SET IT UP TO WRITE 999 TO THE OUTPUT FILE
!       IF IT FINDS SUCCEEDING COHERENT LAYERS.  ISOLATED COHERENT LAYERS ARE HANDLED CORRECTLY.
!     
!     4. INPUT AND OUTPUT.  THIS PROGRAM IS CONFIGURED TO READ THE INPUT DATA FROM FILES.  ONE
!       FILE IS READ (MEMLSN.IN) WHICH CONTAINS SNOW DATA, GROUND DATA, FREQUENCY DATA ETC.  
!       THE FIRST LINE IN THIS FILE IS THE NUMBER OF CALCULATIONS TO BE PERFORMED.  THE SECOND
!       LINE IS THE NUMBER OF LAYERS FOR ALL OF THE SNOWPACK CALCULATIONS: IN THE CURRENT 
!       VERSION OF THE CODE, ALL CALCULATIONS TO BE DONE IN ONE MEMLS CALL MUST BE DONE WITH 
!       THE SAME NUMBER OF LAYERS.  AFTER THESE TWO LINES, SNOW DATA AND OTHER DATA ARE ENTERED
!       ON SEPARATE LINES FOR ALL OF THE REST OF THE CALCULATIONS.
!
!       ALL SNOW DATA IS ON A SINGLE LINE IN THE FILE.  THE N-LAYER SNOW DATA LINE SHOULD 
!       CONTAIN (IN THIS ORDER): LAYER THICKNESS (IN METERS), LAYER DENSITY (KGM3), LAYER
!       GRAIN DIAMETER ( IN METERS), LAYER WETNESS (IN DIMENSIONLESS VOLUMETRIC WATER CONTENT
!       OR FRACTION OF LIQUID WATER IN THE SNOWPACK, AND LAYER TEMPERATURE (K).  FOR EACH OF 
!       THESE VARIABLES, THE LAYER DATA SHOULD BE WRITTEN FROM 1 TO N. AN EXAMPLE LINE USING THE
!       VARIABLES AND A THREE LAYER SNOWPACK BELOW WOULD BE:
!         DI(1) DI(2) DI(3) ROIKG(1) ROIKG(2) ROIKG(3) GDI(1) GDI(2) GDI(3) WIFR(1) WIFR(2) WIFR(3) TI(1) TI(2) TI(3)
!       THE OTHER DATA NEEDED FOR SOIL - SNOW - VEGETATION - ATMOSPHERE MODEL EXECUTION IS READ INTO 
!       THE 'OTHERDATA' ARRAY, WHICH IS PRINTED ON THE LINE BELOW THE SNOW DATA.  THESE DATA ARE (IN 
!       ORDER) GROUND TEMPERATURE (K), FREQUENCY AT WHICH TO COMPUTE THE PREDICTED BRIGHTNESS 
!       TEMPERATURE (GHZ), THE ANGLE AT WHICH TO COMPUTE THE PREDICTED BRIGHTNESS TEMPERATURE 
!       (DEGREES), THE CONSTANT OF PROPORTIONALITY BETWEEN THE SNOW GRAIN DIAMETER AND CORRELATION 
!       LENGTH (DIMENSIONLESS; FOR THIS SEE MATLZER, 2002 IN JOURNAL OF GLACIOLOGY - FOR SAST MODELED 
!       GRAIN DIAMETERS I USE 0.16, AND FOR SNOWPIT GRAIN DIAMETERS I USE 0.5), SKY BRIGHTNESS 
!       TEMPERATURE (HORIZONTAL POLARIZATION, K), SKY BRIGHTNESS TEMPERATURE (VERTICAL 
!       POLARIZATION, K), SOIL POROSITY (DIMENSIONLESS), SOIL SATURATION (DIMENSIONLESS).
!       THESE VALUES SHOULD BE PRINTED ON A SINGLE LINE FOR THE INPUT FILE.  THE VEGETATION DATA 
!       ARE READ INTO THE 'VEGDATA' ARRAY.  THESE DATA ARE (IN ORDER) VEGETATION HEIGHT (M), 
!       VEGETATION TEMPERATURE (K), GRAVIMETRIC WATER CONTENT (FRAC), VEGETATION WATER SALINITY 
!       (PARTS PER THOUSAND), NEEDLE THICKNESS (M), NEEDLE LENGTH (M), NEEDLE NUMBER DENSITY 
!       (NUMBER PER CUBIC METER).  THE ATMOSPHERIC DATA REQUIRED ARE (IN ORDER) ATMOSPHERIC 
!       TEMPERATURE (K), PRESSURE (MBAR) AND WATER VAPOR (G/M3), MONTH OF YEAR (1-12); THESE DATA 
!       SHOULD ALSO BE ON A SINGLE LINE, AND WILL BE READ INTO THE ATMOSDATA ARRAY.  BOTH THE 
!       BRIGHTNESS TEMPERATURE AND THE EMISSIVITY OF THE SNOWPACK AT HORIZONTAL AND VERTICAL 
!       POLARIZATIONS ARE WRITTEN TO AN OUTPUT FILE (MEMLS.OUT).
! 
!     5. POSSIBLE IMPROVEMENTS TO THE CODE.  THE NEXT STEP WOULD BE TO MODIFY IT SO THAT EACH
!       CALCULATION COULD HAVE A DIFFERENT NUMBER OF LAYERS.  OTHER IDEAS ARE TO INCORPORATE
!       SWITCHES TO DECIDE BETWEEN SPEED AND ACCURACY (SUCH AS SWITCHING OFF THE BORN 
!       APPROXIMATION AND VAN POLDER FORMULA, WHICH INVOLVE MORE CALCULATIONS).  ANOTHER STEP 
!       WOULD BE TO MAKE A VERSION OF THE CODE TO RUN ON A FIXED NUMBER OF LAYERS, WHICH WOULD 
!       SAVE TIME ALLOCATING AND DE-ALLOCATING ARRAYS.

! 0.  PRELIMINARIES
!  A. DECLARATIONS
!   1.FOR PART 1
      !REAL OTHERDATA(8),VEGDATA(7),ATMOSDATA(4)
      INTEGER :: CTRL(8)
      REAL VEGDATA(7), CAN_TRAN3_IN(4), ATMOSDATA(4), LAI
      REAL,   INTENT(IN) :: AUX_INS(5),TB_UBC(2,CTRL(4)),FREQ,TETAD(CTRL(4))
      REAL, DIMENSION(:,:) :: Y
      REAL, DIMENSION(:), ALLOCATABLE :: TI,WIFR,ROIKG,DI,GDI,ROI,GDIMM,PCI,&
                                           EPSI,EPSII,GAI,NS,TEI,DEI,SIH,SIV
      REAL,DIMENSION(:), ALLOCATABLE :: XNUM,XROI,XEPSI,XEPSII,XTEI,XSIH,XSIV,XDI,XDEI,&
                                           XTI,XPCI,XWIFR,XGAI
      REAL,DIMENSION(:), ALLOCATABLE :: RROI,REPSI,REPSII,RTEI,RSIH,RSIV,RDI,RDEI,&
                                           RTI,RPCI,RWIFR,RGAI
      REAL GND_SIG,GND_EPS,MJU0,EPS0,PI,TGS,SNGDPCI,TSKYH,TSKYV,&
             SASTPOROS,TETA,SOILSATURATION,GND_TEMP,GND_MV,MAXPCI,VEG_HEIGHT,&
             VEG_TEMP,MG,S,NDL_THK,NDL_LGTH,NDL_NUM,T0,P0,MOIST0
      REAL,   INTENT(OUT):: TB_OUT(2,CTRL(4))

      !ATOURE INTEGER SCCHO,I,NUM,NCALCS,K,RNUM,MONTH,VEG_SWITCH,ATM_SWITCH
      INTEGER SCCHO,I,NUM,K,RNUM,MONTH,VEG_SWITCH1,VEG_SWITCH2, VEG_SWITCH3, ATM_SWITCH


!   2.FOR PART 2
      REAL EPS_T,TETAD_SOIL,EPS_B
      COMPLEX, DIMENSION(:), ALLOCATABLE :: EPSR
      COMPLEX EPS_UPPER
      REAL KSIG,S0H,S0V

!   3.FOR PART 3
      REAL,DIMENSION(:),ALLOCATABLE :: GBIH,GBIV,GS6,GA2I,TSCAT,RSIHLONG,&
                                         RSIVLONG
!   4.FOR PART 4
      REAL,DIMENSION(:),ALLOCATABLE :: RI,TRI,DH,DV
      REAL TSG_H,TSG_V,ESG_H,ESG_V

!   5.FOR PART 5
      COMPLEX EVEG,ESW
      REAL TCAN_V,TCAN_H,CAN_LOSS_H,CAN_LOSS_V,EFSG_H,EFSG_V,TFSG_H,TFSG_V,&
             TATM,ATM_TRAN,TAFSG_H,TAFSG_V
      integer, parameter :: NFREQ = 1
   
     REAL, PARAMETER :: ICE_DENSITY = 0.917

      !ATOURE
      REAL, ALLOCATABLE, DIMENSION(:) :: ICE_FRAC


!  D. DEFINE CONSTANTS
      GND_SIG=0.002
      GND_EPS=0
      MJU0=1.2566e-006
      EPS0=8.8542e-012
	
      PI=3.14159
	
      NUM = ctrl(1)
      TSKYH=TB_UBC(1,NFREQ)
      TSKYV=TB_UBC(2,NFREQ)
      VEG_SWITCH1 = ctrl(5)
      VEG_SWITCH2 = ctrl(6)
      VEG_SWITCH3 = ctrl(7)
      ATM_SWITCH = ctrl(8)


!  1. CHECK TO MAKE SURE THERE IS SNOW.  OTHERWISE DEAL WITH SOIL ONLY
!     NOTE: AUX_INS(1) CONTAINS 0 IN THE CASE OF NO SNOW, THOUGH NUM
!     WILL BE 1 TO AVOID INCORRECT ARRAY ALLOCATIONS
IF (AUX_INS(1).EQ.0) THEN
  DO K=1,NFREQ
    ! THERE IS NO SNOWPACK, SO COMPUTE REFLECTIVITY OF GROUND AND OBTAIN
    ! OUTPUT BRIGHTNESS TEMPERATURES
    EPS_T=1.
    TETAD_SOIL=TETAD(K)
    EPS_UPPER=1.0003 !DIELECTRIC PERMITTIVITY OF AIR

    KSIG=REAL(2*PI*FREQ*1E9*(MJU0*EPS0*EPS_UPPER)**0.5)*GND_SIG
    CALL RUFFSOIL(FREQ*1E9,GND_MV,GND_TEMP,KSIG,TETAD_SOIL,&
      EPS_UPPER,S0H,S0V)

    TB_OUT(1,K)=(1-S0H)*GND_TEMP+S0H*TSKYH
    TB_OUT(2,K)=(1-S0V)*GND_TEMP+S0V*TSKYV
  END DO

  RETURN !TO MAIN PROGRAM

END IF

! 2. COMPUTE BRIGHTNESS TEMPERATURE OF SNOWPACK AND SOIL
      !DO K=1,NCALCS
      DO K=1,1 !NCALCS


      ! ATOURE
      if ( debug ) then
         write(*,*)'SSVA_RTM:    CTRL ',CTRL
         write(*,*)'SSVA_RTM:    FREQ ',FREQ
         write(*,*)'SSVA_RTM:   TETAD ',TETAD
         write(*,*)'SSVA_RTM:       Y ',Y
         write(*,*)'SSVA_RTM:  TB_UBC ',TB_UBC
         write(*,*)'SSVA_RTM:  AUX_INS',AUX_INS

         WRITE(*,*)'         ======================='
         WRITE(*,*)'SSA_RTM:    VEGDATA     ',VEGDATA
         WRITE(*,*)'         ======================='
         WRITE(*,*)'SSA_RTM:    ATMOSDATA     ', ATMOSDATA
      endif

	!  C. ALLOCATE AND RESHAPE STATEMENT
	!     ALL SNOW DATA WILL BE RESHAPED INTO THE Y MATRIX FOR EXTRACTION	
	
	!  E. ALLOCATE AND EXTRACT STATEMENTS
          ALLOCATE(DI(1:NUM),ROIKG(1:NUM),GDI(1:NUM),WIFR(1:NUM),TI(1:NUM))
	
          DI(1:NUM)=   Y(1:NUM,1)  ! snow thickness
          ROIKG(1:NUM)=Y(1:NUM,2)  ! snow density
          GDI(1:NUM)=  Y(1:NUM,3)  ! specific grain diameter (need in microns) XX.YYYYE-06
          WIFR(1:NUM)= Y(1:NUM,4)  ! liquid water fraction
          TI(1:NUM)=   Y(1:NUM,5)  ! snow temperature    
	
          GND_TEMP       = AUX_INS(2) ! Ground temperature
          SOILSATURATION = AUX_INS(3) ! soil saturation
          SASTPOROS      = AUX_INS(4) ! soil porosity (fraction)
          SNGDPCI        = AUX_INS(5) ! proportionality constant
          !GND_TEMP=OTHERDATA(1)
          !FREQ=OTHERDATA(2)
          !TETAD=OTHERDATA(3)
          !SNGDPCI=OTHERDATA(4)
          !TSKYH=OTHERDATA(5)
          !TSKYV=OTHERDATA(6)
          !SASTPOROS=OTHERDATA(7)
          !SOILSATURATION=OTHERDATA(8)



         !============ATOURE ======================
         !!define canopy parameters
         !VEGDATA(1) =  5.1   ! canopy height [m]
         !VEGDATA(2) = -5     ! vegetation temperatue [deg C]
         !VEGDATA(3) = 0.5    ! gravimetric water content [frac]
         !VEGDATA(4) = 8      ! salinity, promilles        
         !VEGDATA(5) = 0.1E-2 ! needle thickness / diameter [m]
         !VEGDATA(6) = 0.8E-2 ! needle length [m]
         !VEGDATA(7) =12456   ! needle number density [#/m^-3]
         ! =======================================

          VEG_HEIGHT=VEGDATA(1)
          VEG_TEMP=VEGDATA(2)
          MG=VEGDATA(3)
          S=VEGDATA(4)
          NDL_THK=VEGDATA(5)
          NDL_LGTH=VEGDATA(6)
          NDL_NUM=VEGDATA(7)                    




          WRITE(*,*)'         ======================='
          WRITE(*,*)'SSA_RTM:    canopy height [m]                 ',VEG_HEIGHT
          WRITE(*,*)'SSA_RTM:    vegetation temperatue [deg C]     ',VEG_TEMP
          WRITE(*,*)'SSA_RTM:    gravimetric water content [frac]  ',MG
          WRITE(*,*)'SSA_RTM:    salinity, promilles               ',S
          WRITE(*,*)'SSA_RTM:    needle thickness / diameter [m]   ',NDL_THK
          WRITE(*,*)'SSA_RTM:    needle length [m]                 ',NDL_LGTH
          WRITE(*,*)'SSA_RTM:    needle number density [#/m^-3]    ', NDL_NUM

          WRITE(*,*)'         ======================='
	
          GND_MV=SOILSATURATION*SASTPOROS
          


         !============ATOURE ======================
         !define canopy parameters
         !ATMOSDATA(1) = 270   !ground level atmospheric temperature in K
         !ATMOSDATA(2) =1013.25!ground level atmospheric pressure in mbar
         !ATMOSDATA(3) =7.5    !ground level water vapor in atmosphere in g/m3
         !ATMOSDATA(4) =11     !month of year
          

          T0=ATMOSDATA(1)
          P0=ATMOSDATA(2)
          MOIST0=ATMOSDATA(3)
          MONTH=ATMOSDATA(4)          


          WRITE(*,*)'         ======================='
          WRITE(*,*)'SSA_RTM: Ground level atmospheric temperature in K ', T0
          WRITE(*,*)'SSA_RTM: Ground level atmospheric pressure in mbar ', P0
          WRITE(*,*)'SSA_RTM: Ground level water vapor in atmos in g/m3 ', MOIST0
          WRITE(*,*)'SSA_RTM: month of year               ',MONTH

	
	!  F. ALLOCATE AND UNIT CONVERSION STATEMENTS
          ALLOCATE(ROI(1:NUM),GDIMM(1:NUM),PCI(1:NUM),ICE_FRAC(1:NUM))
          
          ROI=ROIKG/1000.0
          TETA=TETAD(1)*PI/180
        
          ICE_FRAC(:) = ROI(:) / ICE_DENSITY
        
          ! Original correlation length used GDI as 'measured' grain diameter (Dmax).
          ! Code modified 2 July 2013 to use 'effective' grain diameter. TJH 
          ! FIXME ... there may be a better algorithm for correlation length.

          GDIMM=GDI*1000   ! TJH meters to millimeters
          !PCI=GDIMM*SNGDPCI         
          !pci(:)   = .67*GDIMM * (1.0 - ice_frac)
          PCI(:)   = 0.5 * GDIMM * (1.0 - ICE_FRAC )
         
         !ALLY - FIXME : pseudocode follows
         !if snowdensity>917kg/m3
         !   Set snowdensity = 917
         !   and
         !   Pci =0 %% correlation length
         !endif

        if ( debug ) then
          write(*,*)'SSVA_RTM: Specific grain size : GDIMM    ', GDIMM
          write(*,*)'SSVA_RTM: Snow density        : ROI      ', ROI
          write(*,*)'SSVA_RTM: ice fraction        : ice_frac ', ice_frac
          write(*,*)'SSVA_RTM: Correlation length  : PCI      ', PCI
        endif

        deallocate(ICE_FRAC)


	
	!  G. DETERMINE WHICH SCATTERING COEFFICIENT COMPUTATION METHOD TO USE
	!     THE VALUE OF 0.33 USED HERE FROM PERSONAL CORRESPONDENCE WITH MATZLER
	
          MAXPCI=MAXVAL(PCI)
          IF (MAXPCI<0.33) THEN
            SCCHO=1 ! USE EMPIRICAL SCATTERING COEFFICIENT FROM WIESMANN AND MATZLER 99
          ELSE 
            SCCHO=2 ! USE BORN APPROXIMATION FROM MATZLER AND WIESMANN 99
          ENDIF

        !THIS OPTION OUGHT TO BE AUTOMATED:
        !DURING MY WORK WITH SSIB3+MEMLS TO MODEL GBMR-7 TB, I NEEDED TO USE SCCHO=2
        !SCCHO=2
        !IN ORDER TO SAVE TIME FOR THE SYNTHETIC TESTS, HOWEVER, I USED SCCHO=1
        SCCHO=1



          
	! 1.  COMPUTE RADIATIVE TRANSFER PROPERTIES OF SNOW
          ALLOCATE(EPSI(1:NUM),EPSII(1:NUM),GAI(1:NUM),NS(1:NUM),TEI(1:NUM+1),&
                     DEI(1:NUM),SIH(1:NUM),SIV(1:NUM),XROI(1:NUM),XEPSI(1:NUM),&
                     XEPSII(1:NUM),XTEI(1:NUM+1),XSIH(1:NUM),XSIV(1:NUM),&
                     XDI(1:NUM),XDEI(1:NUM),XTI(1:NUM),XPCI(1:NUM),XWIFR(1:NUM),&
                     XGAI(1:NUM))
	
          CALL RO2EPSD(ROI,TI,FREQ,EPSI,EPSII,NUM)
          CALL MIXMOD(FREQ,TI,WIFR,EPSI,EPSII,NUM)      
          CALL ABSCOEFF(EPSI,EPSII,TI,FREQ,WIFR,GAI,NUM)
          NS=EPSI**0.5
          TEI(1:NUM)=ASIN(SIN(TETA)/NS)
          TEI(NUM+1)=TETA      
          CALL PFADI(TEI,DI,DEI,NUM)
          CALL FRESNELC(TEI,EPSI,SIH,SIV,NUM)

          CALL SLRED(NUM,ROI,EPSI,EPSII,TEI,SIH,SIV,DI,DEI,TI,PCI,WIFR,GAI,&
            FREQ,RNUM,XROI,XEPSI,XEPSII,XTEI,XSIH,XSIV,XDI,XDEI,XTI,XPCI,XWIFR,XGAI)

          ALLOCATE(RROI(1:RNUM),REPSI(1:RNUM),REPSII(1:RNUM),RTEI(1:RNUM+1),&
                     RSIH(1:RNUM),RSIV(1:RNUM),RDI(1:RNUM),RDEI(1:RNUM),RTI(1:RNUM),&
                     RPCI(1:RNUM),RWIFR(1:RNUM),RGAI(1:RNUM))

          DO I=1,RNUM
            RROI(I)=XROI(I)
            REPSI(I)=XEPSI(I)
            REPSII(I)=XEPSII(I)
            RSIH(I)=XSIH(I)
            RSIV(I)=XSIV(I)
            RDI(I)=XDI(I)
            RDEI(I)=XDEI(I)
            RTI(I)=XTI(I)
            RPCI(I)=XPCI(I)
            RWIFR(I)=XWIFR(I)
            RGAI(I)=XGAI(I)
         END DO
         DO I=1,RNUM+1
           RTEI(I)=XTEI(I)
         END DO       
	
	! 2.  COMPUTE GROUND REFLECTIVITIES
          ALLOCATE(EPSR(1:RNUM))
	
          EPS_T=1.
          TETAD_SOIL=TETAD(1)
          
          DO I=RNUM,1,-1
            EPS_B=EPSI(I)
            CALL AOT(EPS_T,EPS_B,TETAD_SOIL)
            EPS_T=EPS_B
          END DO          
	
          EPSR=CMPLX(REPSI,(-1*REPSII)) 
          EPS_UPPER=EPSR(1)
	
          KSIG=REAL(2*PI*FREQ*1E9*(MJU0*EPS0*EPS_UPPER)**0.5)*GND_SIG	
          CALL RUFFSOIL(FREQ*1E9,GND_MV,GND_TEMP,KSIG,TETAD_SOIL,EPS_UPPER,&
                      S0H,S0V)
	
	! 3.  COMPUTE SCATTERING COEFFICIENTS, REFLECTIVITIES AND TRANSMISSIVITIES

          DEALLOCATE(RTEI,RDEI) ! BECAUSE THESE ARRAYS WILL HAVE A DIFFERENT SIZE NOW
          ALLOCATE(GBIH(1:RNUM),GBIV(1:RNUM),GS6(1:RNUM),GA2I(1:RNUM),TSCAT(1:RNUM),&
                     RTEI(1:RNUM),RDEI(1:RNUM),RSIHLONG(1:RNUM+1),RSIVLONG(1:RNUM+1))
                     
          CALL SCCOEFF(RROI,RTI,RPCI,FREQ,RWIFR,RGAI,SCCHO,GBIH,GBIV,GS6,GA2I,&
                               RNUM,REPSI,REPSII)                                             
          CALL PFADC(TETA,RDI,REPSI,GS6,RDEI,RTEI,TSCAT,RNUM)	
          RSIHLONG(1)=S0H
          RSIHLONG(2:RNUM+1)=RSIH
          RSIVLONG(1)=S0V
          RSIVLONG(2:RNUM+1)=RSIV
          CALL POLMIX(TSCAT,RSIHLONG,RSIVLONG,RNUM)

        ! 4. temporary change...
	
        !   C) COMPUTE ATMOSPHERE TRANSMISSIVITY AND BRIGHTNESS TEMP
          IF (ATM_SWITCH.EQ.1) THEN
            CALL SKYTEMP(1,FREQ,TETAD(1),0.05,P0,T0,MONTH,MOIST0,TATM,ATM_TRAN)
          ELSE
            TATM=0.
            ATM_TRAN=1.
          END IF
          tskyh=tskyh*atm_tran+tatm
          tskyv=tskyv*atm_tran+tatm


	! 5.  COMPUTE BRIGHTNESS TEMPERATURES AND EMISSIVITIES OF SNOWPACK AND GROUND
          ALLOCATE(RI(1:RNUM),TRI(1:RNUM),DH(1:RNUM),DV(1:RNUM))
	  
          !this is a temporary fix...
          if(sum(di).gt.0.)then
          CALL RT(GA2I,GBIH,DEI,RI,TRI,RNUM)
          CALL LAYER(RI,RSIHLONG,TRI,RTI,GND_TEMP,TSKYH,DH,RNUM)
          TSG_H=(1-RSIHLONG(RNUM+1))*DH(RNUM)+RSIHLONG(RNUM+1)*TSKYH
          CALL RT(GA2I,GBIV,RDEI,RI,TRI,RNUM)
          CALL LAYER(RI,RSIVLONG,TRI,TI,GND_TEMP,TSKYV,DV,RNUM)
          TSG_V=(1-RSIVLONG(RNUM+1))*DV(RNUM)+RSIVLONG(RNUM+1)*TSKYV
          CALL EMISSIVITY(GA2I,GBIH,GBIV,RDEI,RSIHLONG,RSIVLONG,GND_TEMP,RTI,&
                              ESG_H,ESG_V,RNUM)
          else
            tsg_h=(1-s0h)*gnd_temp+s0h*tskyh
            tsg_v=(1-s0v)*gnd_temp+s0v*tskyv
          end if

        ! 6. COMPUTE BRIGHTNESS TEMPS AFTER ATTENUATION BY THE CANOPY AND ATMOSPHERE
          IF(VEG_SWITCH1.EQ.1)THEN         
        !   A) COMPUTE EMISSIVITY OF VEGETATION
            CALL EPSLEAF(FREQ,S,VEG_TEMP,MG,EVEG)
        !   B) COMPUTE CANOPY TRANSMISSIVITY
            CALL CAN_TRAN1(FREQ,TETAD(1),EVEG,NDL_THK,NDL_NUM,NDL_LGTH,VEG_HEIGHT,&
                 TCAN_H,TCAN_V)

          ELSEIF (VEG_SWITCH2.EQ.1)THEN

             !Canopy transmissivity according to Vonder Jagt 2014
             CALL CAN_TRAN2(LAI,TCAN_H,TCAN_V)

          ELSE
            TCAN_H=1.0
            TCAN_V=1.0
          END IF

        !   D) COMPUTE LOSS TERMS, ESMISSIVITY AND BRIGHTNESS TEMPS OF
        !        GROUND SNOW AND FOREST SCENE
          CAN_LOSS_H=1/TCAN_H
          CAN_LOSS_V=1/TCAN_V
          EFSG_H= 1-(1/CAN_LOSS_H**2)*(1-ESG_H)
          EFSG_V= 1-(1/CAN_LOSS_V**2)*(1-ESG_V)
          TFSG_H=(1-1/CAN_LOSS_H)*VEG_TEMP+(1/CAN_LOSS_H)*TSG_H+&
            (1-ESG_H)*(1-1/CAN_LOSS_H)*(1/CAN_LOSS_H)*VEG_TEMP
          TFSG_V=(1-1/CAN_LOSS_V)*VEG_TEMP+(1/CAN_LOSS_V)*TSG_V+&
            (1-ESG_V)*(1-1/CAN_LOSS_V)*(1/CAN_LOSS_V)*VEG_TEMP

        !   E) COMPUTE TOA BRIGHTNESS TEMP
          TAFSG_H=TFSG_H*ATM_TRAN+TATM+TSKYH*(1-EFSG_H)*ATM_TRAN
          TAFSG_V=TFSG_V*ATM_TRAN+TATM+TSKYV*(1-EFSG_V)*ATM_TRAN
	
	! 6.  WRITE STATEMENTS
          WRITE(2,'(8F10.4)') TAFSG_H,TAFSG_V,TFSG_H,TFSG_V,TATM,ATM_TRAN,EFSG_H,EFSG_V
          
         ! Ally TOURE
         WRITE(*,*)'SSVA_RTM:  TAFSG_H   ',TAFSG_H
         WRITE(*,*)'SSVA_RTM:  TAFSG_V   ',TAFSG_V

         WRITE(*,*)'SSVA_RTM:  TFSG_H    ',TFSG_H
         WRITE(*,*)'SSVA_RTM:  TFSG_V    ',TFSG_V

         WRITE(*,*)'SSVA_RTM:  TATM      ',TATM
         WRITE(*,*)'SSVA_RTM:  ATM_TRAN  ',ATM_TRAN

         WRITE(*,*)'SSVA_RTM:  EFSG_H    ',EFSG_H
         WRITE(*,*)'SSVA_RTM:  EFSG_V    ',EFSG_V

        ! 7.  DEALLOCATE VARIABLE SPACE
    
          DEALLOCATE(DI,ROIKG,GDI,WIFR,TI,ROI,GDIMM,PCI,EPSI,& 
            EPSII,GAI,NS,TEI,DEI,SIH,SIV,EPSR,GBIH,GBIV,GS6,GA2I,TSCAT,&
            RSIHLONG,RSIVLONG,RI,TRI,DH,DV)

          DEALLOCATE(RROI,REPSI,REPSII,RTEI,RSIH,RSIV,RDI,RDEI,RTI,RPCI,RWIFR,RGAI,&
                     XROI,XEPSI,XEPSII,XTEI,XSIH,XSIV,XDI,XDEI,XTI,XPCI,XWIFR,XGAI)

      END DO
      
      END subroutine ssva_rtm



! -------------------------------------------------------------------------
!
      SUBROUTINE ABSCOEFF(EPSI,EPSII,TI,FREQ,WIFR,GAI,NUM)
!
! -------------------------------------------------------------------------
!
!   CODE ORIGINALLY OBTAINED IN MATLAB FROM MATZLER
!
!   COMPUTES THE ABSORPTION COEFFICIENT FROM THE DIELECTRIC PROPERTIES   
!
!
!   [GAI] = ABSCOEFF(EPSI,EPSII,TI,FREQ,WI)
!       GAI:   ABSORPTION COEFFICIENT [M^-1]
!       EPSI:  REAL PART DIEL
!       EPSII: IMAGINARY PART DIEL
!       TI:    PHYSICAL TEMPERATURE
!       FREQ:  FREQUENCY [GHZ]
!       WI:    VOLUMETRIC LIQUID WATER CONTENT
!
!   VERSION HISTORY:
!      1.0    WI 15.7.95
!      1.1    WI 12.11.97 MORE PRECISE FORMULA FOR GAI USED
!      2.0    MD 1 APR 05 TRANSLATED TO FORTRAN FROM MATLAB
!
!   USES: NONE


     !!!!!!!STOP ATOURE

INTEGER, INTENT(IN) :: NUM
REAL, INTENT(IN) :: EPSI(NUM),EPSII(NUM),TI(NUM),FREQ,WIFR(NUM)
REAL, INTENT(OUT) :: GAI(NUM)
REAL C,PI, part1, part2, numerator,denominator
INTEGER I
 
!C=2.99793
!PI=3.14159
! Must try alternative implementation of following (it over/underflows
!GAI=((2*PI*10*FREQ)*EPSII)/(C*(EPSI-(EPSII**2/4*EPSI))**0.5)

C  = 2.99793_digits12
PI = 3.14159_digits12
do i = 1,NUM
   numerator   = 2.0_digits12 * PI * 10.0_digits12 * real(FREQ,digits12) * real(EPSII(i),digits12)
   part1       = (EPSII(i)**2.0/4.0_digits12)*EPSI(i)
   part2       = EPSI(i) - part1
   denominator = C * part2**0.5

   if ( debug ) then
      write(*,*)'abscoeff: i = ',i,' of ',NUM
      write(*,*)'abscoeff:           C ', C
      write(*,*)'abscoeff:        FREQ ', FREQ
      write(*,*)'abscoeff:        EPSI ', EPSI(i)
      write(*,*)'abscoeff:       EPSII ', EPSII(i)
      write(*,*)'abscoeff: numerator   ', numerator
      write(*,*)'abscoeff: part1       ', part1
      write(*,*)'abscoeff: part2       ', part2
      write(*,*)'abscoeff: denominator ', denominator
      write(*,*)'abscoeff: GAI is then ', numerator / denominator
   endif

   GAI(i) = numerator/denominator
enddo



      END SUBROUTINE ABSCOEFF

! -------------------------------------------------------------------------
!
      SUBROUTINE AOT(EPS_T,EPS_B,TETAD_SOIL)
!
! -------------------------------------------------------------------------
!
!     CODE ORIGINALLY OBTAINED IN MATLAB FROM PULLIAINEN
!
!     FUNCTION FOR CALCULATING THE ANGLE OF TRANSMISSION 
!     IN THE CASE OF A PLANE BOUNDARY BETWEEN TWO
!     MEDIAS WITH COMPLEX PERMITTIVITIES
!     K. TIGERSTEDT/97
!
!   INPUT PARAMETERS:
!     EPS_T = TOP LAYER EPSILON_R [COMPLEX],
!     EPS_B = BOTTOM LAYER EPSILON_R [COMPLEX]
!     THETAD = INCIDENCE ANGLE [DEG]
!   OUTPUT:
!     KSID   = TRANSMISSION ANGLE IN BOTTOM LAYER [DEG]
!
!   VERSION HISTORY:
!      1.0    KT ?.?.97
!      2.0    MD 1 APR 05 TRANSLATED TO FORTRAN FROM MATLAB

      REAL, INTENT(IN) :: EPS_T,EPS_B
      REAL, INTENT(INOUT) :: TETAD_SOIL
      REAL THETA,KSI,PI	
      COMPLEX NUMERATOR,DENOMINATOR

      PI=3.14159
      THETA=TETAD_SOIL/180*PI
      NUMERATOR=EPS_T**0.5*SIN(THETA)
      DENOMINATOR=(EPS_B-EPS_T*(1-COS(THETA)**2))**0.5

      KSI=ATAN(REAL(NUMERATOR)/REAL(DENOMINATOR))
      TETAD_SOIL=KSI/PI*180

      END SUBROUTINE AOT

! -------------------------------------------------------------------------
!
      SUBROUTINE BORN(K,VFI,PCIMM,EPSI,EICE,GB6,GC6,GF6,GS6,NUM)
!
! -------------------------------------------------------------------------
!
!   CODE ORIGINALLY OBTAINED IN MATLAB FROM MATZLER, MODIFIED BY MIKE... SEE VERSION HISTORY
!
!   CALCULATES THE SCATTERING COEFFICIENT USING BORN APPROXIMATION       
!
!   [GB6,GC6,GF6,GS6] = BORNA(K,VFI,PCI,EPSI,EICE,EPSEFF,KP)
!       GB6: 6-FLUX BACK SCATTERING COEFFICIENT 
!       GC6: 6-FLUX CROSS SCATTERING COEFFICIENT 
!       GF6: 6-FLUX FORWARD SCATTERING COEFFICIENT 
!       GS6: 6-FLUX SCATTERING COEFFICIENT 
!       K:   WAVE NUMBER
!       VFI: VOLUME FRACTION OF ICE
!       PCI: CORRELATION LENGTH
!       EPSI: DIELECTRIC CONSTANT OF SNOW
!       EICE: DIELECTRIC CONSTANT OF SNOW
!       EPSEFF: EFFECTIVE PERMITTIVITY
!
!   VERSION HISTORY:
!      1.0     WI 27.05.98 
!      2.0     WI 31.03.05.  TRANSLATED TO FORTRAN BY MIKE.  BORNA AND 
!                             BORNSNK COMBINED INTO ONE.  CALL TO POLDER
!                             IS USED TO COMPUTE EFFECTIVE PERMITTIVITY
!      3.0     MD 1 APR 05 TRANSLATED TO FORTRAN FROM MATLAB
!
!   USES:
!     
!   COPYRIGHT (C) 1998 BY THE INSTITUTE OF APPLIED PHYSICS, 
!   UNIVERSITY OF BERN, SWITZERLAND

      INTEGER, INTENT(IN) :: NUM
      REAL, INTENT(IN) :: K,VFI(NUM),PCIMM(NUM),EPSI(NUM),EICE
      REAL, INTENT(OUT) :: GB6(NUM),GC6(NUM),GF6(NUM),GS6(NUM)
      REAL PCI(NUM),A(NUM),A3(NUM),EA(NUM),EA3(NUM),K1(NUM),K3(NUM),KP(NUM),&
             MUC(NUM),AA(NUM),XX(NUM),BB(NUM),BT(NUM),BF(NUM),BTOT(NUM),&
             EPSEFF(NUM)
      INTEGER STEPS,ROW,ARG_LENGTH(2),I
      REAL MAXO(NUM)
  
! 0)  CONSTANTS AND CONVERSION
      STEPS=11
      PCI=PCIMM*0.001

! 1)  COMPUTE FIELD FACTOR AND DEPOLARIZATION RATIO, FROM BORNSNK
!     'A' AFTER NOTE 10, MÄTZLER 1997, COMMENT AND CALL FROM BORNSNK
      CALL SNOWAO(VFI,A,NUM)

! 2)  COMPUTE EFFECTIVE PERMITTIVITY USING NEW FUNCTION POLDER.M
      CALL POLDER(VFI,A,EICE,EPSI,EPSEFF,NUM)

! 3)  COMPUTE KP, THE SQUARED RATIO BETWEEN INTERNAL / EXTERNAL FIELDS
!     THIS CODE ORIGINALLY IN BORNSNK, STARTING AT LINE 41
      A3=1-2*A
      EA=EPSEFF*(1-A)+A
      EA3=EPSEFF*(1-A3)+A3
      K1=(EA/(EA+A*(EICE-1)))**2
      K3=(EA3/(EA3+A3*(EICE-1)))**2
      KP=(2*K1+K3)/3

! 4)  COMPUTE SCATTERING COEFFICIENTS, FROM BORNA, STARTING AT LINE 34

      !NOTE: THE NEXT LINE CONSISTENT WITH MATZLER AND WIESMANN 99 PAPER EQUATION (7).
      !  BASED ON CORRESPONDENCE WITH MATZLER, EPSEFF=N^2

      MUC=((EPSEFF-1)/EPSEFF)**0.5      

      AA=2*(PCI*K)**3*K*VFI*(1-VFI)*(EICE-1)**2*KP
      XX=PCI*K*EPSI**0.5

! 5)  TRIPLE INTEGRATION 

!  A) BACKWARD SCATTERING
      ARG_LENGTH=(/1, NUM/)
      CALL INTEGRMUI(NUM, ARG_LENGTH, XX, MUC, 1., (/ -1. /) , -1.*MUC, STEPS, BB)
!  B) TRANSVERSE SCATTERING 
      ARG_LENGTH=(/NUM, NUM/)
      CALL INTEGRMUI(NUM, ARG_LENGTH, XX, MUC, 1., -1.*MUC,     MUC, STEPS, BT)
!  C) FORWARD SCATTERING   
      ARG_LENGTH=(/NUM, 1/)
      MAXO = 1.
      CALL INTEGRMUI(NUM, ARG_LENGTH, XX, MUC, 1.,     MUC,    MAXO, STEPS, BF)

! 6)  CALCULATION OF SCATTERING COEFFICIENTS

      BTOT=BB+BT+BF
      GB6=AA*BB
      GC6=0.25*AA*BT
      GF6=AA*BF
      GS6=AA*BTOT

      END SUBROUTINE BORN

! -------------------------------------------------------------------------
!
      SUBROUTINE CAN_TRAN1(FREQ,THETAD,EPS_VEG,D,N,L,H,TCAN_H,TCAN_V)
!
! -------------------------------------------------------------------------
!
!
!   CODE ORIGINALLY OBTAINED IN MATLAB FROM PULLIAINEN
!
!   CALCULATES THE CANOPY TRANSMISSIVITY
!
!   [TCAN_H,TCAN_V] = EPSLEAF(FREQ,THETAD,EPS_VEG,D,N,L,H)
!      TCAN_H,TCAN_V:  HORIZONTAL AND VERTICAL CANOPY TRANSMISSIVITY
!      FREQ: FREQUENCY IN GHZ
!      THETAD: OBSERVATION ANGLE IN DEGREES
!      EPS_VEG: VEGETATION DIELECTRIC CONSTANT (COMPLEX)
!      D: NEEDLE DIAMETER [M]
!      N: NEEDLE NUMBER DENSITY [NEEDLES PER CUBIC METER]
!      L: NEEDLE LENGTH [M]
!      H: VEGETATION HEIGHT [M]
!
!   VERSION HISTORY:
!      1.0     ? ?.?.?
!      2.0    MD 15 APR 05 TRANSLATED TO FORTRAN FROM MATLAB
!   
!   USES: NONE
!
!   THIS CODE IS DERIVED FROM WEGMULLER ET AL. (95), SEE REFERENCE IN MAIN COMMENTS
!

      REAL,INTENT(IN) :: FREQ,THETAD,D,N,L,H
      COMPLEX,INTENT(IN) :: EPS_VEG
      REAL,INTENT(OUT) :: TCAN_H,TCAN_V
      REAL PI,MJU0,EPS0,FHZ,THETA,C,K0,KZ0,R_H,R_V,T_H,T_V,A_H,A_V,&
             TAU_H,TAU_V
      COMPLEX RH,RV,KZ1
      !ATOURE
      REAL EPS_VDD      

    ! CONSTANTS
      PI=3.14159
      MJU0=PI*4E-7
      EPS0=8.8542E-12
            
    ! UNIT CONVERSIONS
      FHZ=FREQ*10**9
      THETA=THETAD*PI/180

    ! WAVE SPEED
      C=(MJU0*EPS0)**(-0.5)

      K0 = 2*PI*FHZ*SQRT(MJU0*EPS0)
      KZ0 = 2*PI*FHZ/C*COS(THETA)
      KZ1 = 2*PI*FHZ/C*SQRT(EPS_VEG-SIN(THETA)**2)

      RH = (KZ0-KZ1)/(KZ0+KZ1) 
      RV = (EPS_VEG*KZ0-KZ1)/(EPS_VEG*KZ0+KZ1)

      EPS_VDD=ABS(AIMAG(EPS_VEG))

    ! HORIZONTAL AND VERTICAL REFLECTIVITY OF A SINGLE LEAF (16)
      R_H=ABS(RH*(1-EXP((0.0,1.0)*(-2)*KZ1*D))/(1-RH**2* &
            EXP((0.0,1.0)*(-2)*KZ1*D)))**2
      R_V=ABS(RV*(1-EXP((0.0,1.0)*(-2)*KZ1*D))/(1-RV**2* &
            EXP((0.0,1.0)*(-2)*KZ1*D)))**2

    ! HORIZONTAL (17) AND VERTICAL (18) TRANSMISSIVITY OF A SINGLE LEAF 
      T_H = ABS(4*KZ0*KZ1*EXP((0.0,1.0)*(KZ0-KZ1)*D)/((KZ0+KZ1)**2* &
             (1-RH**2*EXP((0.0,1.0)*(-2)*KZ1*D))))**2 

      T_V = ABS(4*EPS_VEG*KZ0*KZ1*EXP((0.0,1.0)*(KZ0-KZ1)*D)/ &
             ((EPS_VEG*KZ0+KZ1)**2*(1-RV**2*EXP((0.0,1.0)*(-2)*KZ1*D))))**2

    ! ABSORPTIVITY OF A SINGLE LEAF (19)
      A_H = 1-T_H-R_H
      A_V = 1-T_V-R_V

    ! CANOPY OPACITY
      TAU_H = N*L*D*H*A_H
      TAU_V = N*L*D*H*A_V

    ! CANOPY TRANSMISSIVITY (25)
      TCAN_H=EXP(-TAU_H)
      TCAN_V=EXP(-TAU_V)

      END SUBROUTINE CAN_TRAN1

!=======ATOURE======================


! -------------------------------------------------------------------------
!
SUBROUTINE CAN_TRAN2(LAI,TCAN_H,TCAN_V)
!
! -------------------------------------------------------------------------
!
!
!
!   CALCULATES THE CANOPY TRANSMISSIVITY
!   LAI: LEAF AREA INDEX
!   TCAN_H,TCAN_V:  HORIZONTAL AND VERTICAL CANOPY TRANSMISSIVITY
!
!   VERSION HISTORY:
!      1.0     03/12/2014
!   
!   USES: NONE
!
!   THIS CODE IS DERIVED FROM  VONDER JAGT & DURAND 2014
!

REAL,INTENT(IN)  :: LAI
REAL,INTENT(OUT) :: TCAN_H,TCAN_V
REAL A, B, C, D

!Model coefficients 
A =  0.9721
B =  -0.2746
C =  0.02569
D =  0.3464 

! CANOPY TRANSMISSIVITY
TCAN_H = A*exp(B*LAI) + C*exp(D*LAI) !Horizontal polarization 
TCAN_V = A*exp(B*LAI) + C*exp(D*LAI) !Vertical polarization 



END SUBROUTINE CAN_TRAN2


SUBROUTINE CAN_TRAN3(LAI,CAN_TRAN3_IN, FREQ,TETAD,TCAN_H,TCAN_V)

!   CALCULATES THE CANOPY TRANSMISSIVITY
!
!      FREQ: FREQUENCY IN GHZ
!      THETAD: OBSERVATION ANGLE IN DEGREES
!      EPS_VEG: VEGETATION DIELECTRIC CONSTANT (COMPLEX)
!      B1_CAN(1) = 0.62  !H  !0.62 used in Huang et al. (2008) for both polarizations
!      B1_CAN(2) = 0.62  !V
!      X_CAN(1) = -0.4   !H  !-1.08 for wheat (stem-dominated) and
!                            -1.38 for soybean (leaf-dominated)
!      X_CAN(2) = -0.4   !V  !from Jackson and Schmugge (1991)
!      LAI: FROM MODIS DATA or CLM4 model
!      TCANOPY:  Vegetation physical temperature
!
!   VERSION HISTORY:
!      1.0    Ally TOURE obtained from Yonghwan on 11/6/2013
!
!   USES: NONE
!
!   THIS CODE IS DERIVED FROM  Jackson and Schmugge (1991,1992 , SEE REFERENCE IN MAIN COMMENTS

REAL,INTENT(IN)   :: CAN_TRAN3_IN(4) 
REAL,INTENT(OUT)  :: TCAN_H,TCAN_V
REAL,PARAMETER    :: PI=3.14159265
REAL,DIMENSION(2) :: B_CAN, B1_CAN, X_CAN !empirical coefficient for canopy transmissivity  
REAL,DIMENSION(2) :: TAU_C           
!REAL,DIMENSION(2) :: TB_CAN
REAL FREQ,TETAD, W_VEGE, LAI, LAMBDA  



B1_CAN(1) = CAN_TRAN3_IN(1) !H 0.62 used in Huang et al. (2008) for both pol
B1_CAN(2) = CAN_TRAN3_IN(2) !V
X_CAN(1)  = CAN_TRAN3_IN(3) !H -1.08 for wheat (stem-dominated)
X_CAN(2)  = CAN_TRAN3_IN(4) !V from Jackson and Schmugge (1991)



!! compute canopy Tb and transmissivity
!calculate the vegetation water content (kg /m2)
W_VEGE = exp(LAI/3.3) -1.0         ! (Paloscia and Pampaloni, 1988)

!compute the wavelength (m)
LAMBDA = 3*10**8 / (FREQ*1e9)

!calculate B_CAN
B_CAN(1) = B1_CAN(1)*(100*LAMBDA)**X_CAN(1)! (Jackson and Schmugge, 1991)
B_CAN(2) = B1_CAN(2)*(100*LAMBDA)**X_CAN(2)! (Jackson and Schmugge, 1991)

!calculate the vegetation optical depth
TAU_C(1) = (B_CAN(1)*W_VEGE) / cos(TETAD*pi/180)! (Jackson and Schmugge, 1991)
TAU_C(2) = (B_CAN(2)*W_VEGE) / cos(TETAD*pi/180)! (Jackson and Schmugge, 1991)

!calculate the canopy transmissivity
TCAN_H = exp(-TAU_C(1)) ! horizontal polarization(Schmugge and Jackson, 1992)
TCAN_V = exp(-TAU_C(2)) ! vertical polarization(Schmugge and Jackson, 1992)  

!compute canopy brightness temperature from emissivity (1-transmissivity),
!  and the vegetation physical temperature
!TB_CAN(1)=(1-TCAN_H(1))*TCANOPY
!TB_CAN(2)=(1-TCAN_H(2))*TCANOPY



END SUBROUTINE CAN_TRAN3





! -------------------------------------------------------------------------
!
      SUBROUTINE EMISSIVITY(GA2I,GBIH,GBIV,DEI,SIHLONG,SIVLONG,GND_TEMP,TI,&
                              EH,EV,NUM)
!
! -------------------------------------------------------------------------
!
!   CODE ORIGINALLY OBTAINED IN MATLAB FROM MATZLER, MODIFIED BY MIKE... SEE VERSION HISTORY
!
!   CALCULATES THE SCATTERING COEFFICIENT USING BORN APPROXIMATION       
!
!       GA2I: ABSORPTION COEFFICIENT
!       GBIH: 2-FLUX SCATTERING COEFFICIENT, H POLARIZATION
!       GBIV: 2-FLUX SCATTERING COEFFICIENT, V POLARIZATION
!       DEI:  EFFECTIVE PATH LENGTH [M]
!       SIHLONG: LAYER INTERFACE REFLECTIVITY, H POLARIZATION
!       SIVLONG: LAYER INTERFACE REFLECTIVITY, V POLARIZATION
!       EH:   EMISSIVITY, H POLARIZATION
!       EV:   EMISSIVITY, V POLARIZATION
!
!   VERSION HISTORY:
!      1.0     MD 1 APR 05 THIS CODE WAS PART OF LMAIN.  I TRANSLATED TO 
!                            FORTRAN FROM MATLAB AND MOVED IT TO A SEPARATE
!                            SUBROUTINE.  COMPARE WIESMANN AND MATZLER, 99 EQN (8)
!
!   USES: RT, LAYER
!     
!   COPYRIGHT (C) 1998 BY THE INSTITUTE OF APPLIED PHYSICS, 
!   UNIVERSITY OF BERN, SWITZERLAND

      INTEGER, INTENT(IN) :: NUM
      REAL,INTENT(IN) :: GA2I(NUM),GBIH(NUM),GBIV(NUM),DEI(NUM),&
                           SIHLONG(NUM+1),SIVLONG(NUM+1),GND_TEMP,&
                           TI(NUM)
      REAL,INTENT(OUT) :: EH,EV
      REAL RI(NUM),TRI(NUM),DH(NUM),DV(NUM),TBH0,TBH100,TBV0,TBV100,TSKY

      ! HORIZONTAL BRIGHTNESS TEMPERATURES UNDER DIFFERENT TSKY VALS

      CALL RT(GA2I,GBIH,DEI,RI,TRI,NUM)

      TSKY=0.
      CALL LAYER(RI,SIHLONG,TRI,TI,GND_TEMP,TSKY,DH,NUM)
      TBH0=(1-SIHLONG(NUM+1))*DH(NUM)+SIHLONG(NUM+1)*TSKY

      TSKY=100.
      CALL LAYER(RI,SIHLONG,TRI,TI,GND_TEMP,TSKY,DH,NUM)
      TBH100=(1-SIHLONG(NUM+1))*DH(NUM)+SIHLONG(NUM+1)*TSKY

      ! VERTICAL BRIGHTNESS TEMPERATUERS UNDER DIFFERENT TSKY VALS

      CALL RT(GA2I,GBIV,DEI,RI,TRI,NUM)

      TSKY=0.
      CALL LAYER(RI,SIVLONG,TRI,TI,GND_TEMP,TSKY,DV,NUM)
      TBV0=(1-SIVLONG(NUM+1))*DV(NUM)+SIVLONG(NUM+1)*TSKY

      TSKY=100.
      CALL LAYER(RI,SIVLONG,TRI,TI,GND_TEMP,TSKY,DV,NUM)
      TBV100=(1-SIVLONG(NUM+1))*DV(NUM)+SIVLONG(NUM+1)*TSKY

      ! COMPUTE EMISSIVITIES
      EH=1-(TBH100-TBH0)/100
      EV=1-(TBV100-TBV0)/100

      END SUBROUTINE EMISSIVITY

! -------------------------------------------------------------------------
!
SUBROUTINE EPSICE(TI,FREQ,EICE,NUM)
!
! -------------------------------------------------------------------------
!
!   CODE ORIGINALLY OBTAINED IN MATLAB FROM MATZLER
!
!   CALCULATES THE DIELECTRIC PERMITTIVITY OF ICE
!   AFTER HUFFORD, MITZIMA AND MATZLER
!
!   EICE = EPSICE(TI,FREQ)
!      EICE:  DIELECTRIC PERMITTIVITY OF ICE
!      TI:    TEMPERATURE IN K 
!      FREQ:  FREQUENCY IN GHZ
!
!   VERSION HISTORY:
!      1.0    WI 15.7.95
!      2.0    MD 1 APR 05 TRANSLATED TO FORTRAN FROM MATLAB
!   
!   USES: NONE
!
!   COPYRIGHT (C) 1997 BY THE INSTITUTE OF APPLIED PHYSICS, 
!   UNIVERSITY OF BERN, SWITZERLAND

!ATOURE: Original code
!INTEGER, INTENT(IN) :: NUM
!REAL, INTENT(IN) :: TI(NUM), FREQ
!REAL, INTENT(OUT) ::  EICE(NUM)
!REAL PP(NUM),B,B1,B2,DB(NUM),BETA(NUM),ALPHA(NUM)

!PP=(300/TI)-1
!B=335.25
!B1=0.0207
!B2=1.16E-11
!DB=EXP(-10.02+0.0364*(TI-273))
!BETA=((B1*EXP(B/TI))/(TI*(EXP(B/TI)-1)**2))+B2*FREQ**2+DB
!ALPHA=(0.00504+0.0062*PP)*EXP(-22.1*PP)
!EICE=ALPHA/FREQ+BETA*FREQ
!TH Modification

integer, intent(in)  :: num
real,    intent(in)  :: ti(num),FREQ
real,    intent(out) :: eice(num)

real(digits12) :: pp(num),b,b1,b2,db(num),beta(num),alpha(num)

pp    = (300.0_digits12/ti) - 1.0_digits12
b     = 335.25_digits12
B1    = 0.0207_digits12
B2    = 1.16E-11_digits12
db    = exp(-10.02_digits12 + 0.0364_digits12*(ti - 273.0_digits12))
beta  = ((b1*exp(b/ti))/(ti*(exp(b/ti)-1.0_digits12)**2))+b2*FREQ**2+db
alpha = (0.00504_digits12+0.0062_digits12*pp)*exp(-22.1_digits12*pp)
eice  = alpha/FREQ+beta*FREQ

END SUBROUTINE  EPSICE


! -------------------------------------------------------------------------
!
SUBROUTINE EPSLEAF(F,S,T,MG,EVEG)
!
! -------------------------------------------------------------------------
!
!   CODE ORIGINALLY OBTAINED IN MATLAB FROM PULLIAINEN
!
!   CALCULATES THE DIELECTRIC CONSTANT OF FRESH LEAVES
!
!   EVEG = EPSLEAF(F,S,T,MG)
!      EICE:  DIELECTRIC CONSTANT OF FRESH LEAVES
!      F: FREQUENCY IN GHZ
!      S: VEGETATION WATER SALINITY IN PROMILLES (PARTS PER THOUS.) 
!      T: VEGETATION TEMPERATURE IN K
!      MG: GRAVIMETRIC WATER CONTENT (FRACTION)      
!
!   VERSION HISTORY:
!      1.0     ? ?.?.?
!      2.0    MD 15 APR 05 TRANSLATED TO FORTRAN FROM MATLAB
!   
!   USES: EPSWS
!
!   THIS CODE IS DERIVED FROM MATZLER (94), "MICROWAVE (1-100 GHZ) 
!     DIELECTRIC MODEL OF LEAVES." IN IEEE.
!

REAL,INTENT(IN) :: F,S,T,MG
COMPLEX,INTENT(OUT) :: EVEG
REAL TC,FHZ,MD
COMPLEX ESW

!   UNIT CONVERSION
TC=T-273.15
FHZ=F*10**9

MD=1.-MG

CALL EPSWS(FHZ,S,TC,ESW)

EVEG=0.522*(1-1.32*MD)*ESW+0.51+3.84*MD

END SUBROUTINE EPSLEAF

! -------------------------------------------------------------------------
!
SUBROUTINE EPSWS(F,S,T,ESW)
!
! -------------------------------------------------------------------------
!
!   CODE ORIGINALLY OBTAINED IN MATLAB FROM PULLIAINEN
!
!   CALCULATES THE DIELECTRIC CONSTANT OF SALT WATER
!
!   ESW = EPSLEAF(F,S,T)
!      EICE:  DIELECTRIC CONSTANT OF FRESH LEAVES
!      F: FREQUENCY IN HZ
!      S: VEGETATION WATER SALINITY IN PROMILLES (PARTS PER THOUS.) 
!      T: VEGETATION TEMPERATURE IN C
!
!   VERSION HISTORY:
!      1.0     ? ?.?.?
!      2.0    MD 15 APR 05 TRANSLATED TO FORTRAN FROM MATLAB
!   
!   USES: NONE
!
!   THIS CODE IS DERIVED FROM ULABLY ET AL. (1986) MICROWAVE REMOTE SENSING, 
!     ACTIVE AND PASSIVE, VOL III... A SIMILAR MODEL CAN BE FOUND IN KLEIN
!     AND SWIFT (1977) IN IEEE. 

REAL,INTENT(IN) :: F,S,T
COMPLEX,INTENT(OUT) :: ESW
REAL PI,E0,EW_INF,N,A,EW0_T,EW0,B,T0,TW,D,ALFA,SIGMA_25,SIGMA

! ATOURE
REAL EW_R,  EW_I

! CONSTANTS
PI=3.14159
E0= 8.854E-12  ! SEE KLEIN AND SWIFT, P.106
EW_INF=4.9     ! SEE KLEIN AND SWIFT, P.100

! COMPARE NEXT LINE WITH (19) IN KLEIN AND SWIFT:
N = S*(1.707E-2+1.205E-5*S+4.058E-9*S*S)
! COMPARE NEXT LINE WITH (15) IN KLEIN AND SWIFT:
A = 1.00 - 0.2551*N + 5.151E-2 * N*N - 6.889E-3 * N*N*N
! COMPARE NEXT LINE WITH (14) IN KLEIN AND SWIFT:
EW0_T = 87.74 - 0.40008*T + 9.398E-4 * T*T + 1.410E-6 * T*T*T
! COMPARE NEXT LINE WITH (13) IN KLEIN AND SWIFT:
EW0 = EW0_T * A

! NOTE: HERE, I'M INTEGRATING THE OLD SUBROUTINE 'TAU.M' INTO THE NEXT
!   THREE LINES AND COMMENTS OF THIS CODE
! COMPARE NEXT LINE WITH (18) IN KLEIN AND SWIFT:
B=0.1463E-2*N*T+1.00-0.04896*N-0.02967*N*N+5.6441E-3*N*N*N
! COMPARE NEXT LINE WITH (17) IN KLEIN AND SWIFT:
T0=1/(2*PI)*(1.1109E-10-3.824E-12*T+6.938E-14*T*T-5.096E-16*T*T*T)
! COMPARE NEXT LINE WITH (16) IN KLEIN AND SWIFT:      
TW = T0* B

! NOTE: HERE, I'M INTEGRATING THE OLD SUBROUTINE 'SIGMA.M' INTO THE NEXT 
!   4 LINES OF THIS CODE
D=25-T
ALFA=2.033E-2+1.266E-4*D+2.464E-6*D*D-S*(1.849E-5-2.551E-7*D+2.551E-8*D*D)
SIGMA_25=S*(0.182521-1.46192E-3*S+2.09324E-5*S*S-1.28205E-7*S*S*S)
SIGMA=SIGMA_25*EXP(-D*ALFA)

! COMPARE NEXT THREE LINES WITH (5) IN KLEIN AND SWIFT:
EW_R=EW_INF+(EW0-EW_INF)/(1+(2*PI*F*TW)**2)
EW_I=(EW0-EW_INF)*2*PI*F*TW/(1+(2*PI*F*TW)**2)+SIGMA/(2*PI*E0*F)

ESW=CMPLX(EW_R,(-1*EW_I))       

END SUBROUTINE EPSWS

! -------------------------------------------------------------------------
!
SUBROUTINE EPSR(ROI,NUM,EPSI)
!
! -------------------------------------------------------------------------
!
!     CODE ORIGINALLY OBTAINED IN MATLAB FROM MATZLER
!
!   CALCULATES THE DIELECTRIC PERMITTIVITY FOR DRY SNOW FROM 
!   DENSITY .
!
!   EPSI = EPSR(ROI)
!       EPSI:  REAL PART OF DIELECTRIC PERMITTIVITY
!       ROI:   DENSITY G/CM^3
!
!   VERSION HISTORY:
!      1.0    WI 15.7.95
!      1.1    WI 23.9.97 ADDED LOOYENGA FOR SNOW DENSER THAN 0.4 G/CM^3
!      2.0    MD 1 APR 05 TRANSLATED TO FORTRAN FROM MATLAB
!
!   USES:
!       EPSICE
!
!
!
!   COPYRIGHT (C) 1997 BY THE INSTITUTE OF APPLIED PHYSICS, 
!   UNIVERSITY OF BERN, SWITZERLAND

INTEGER, INTENT(IN) :: NUM
REAL, INTENT(IN) :: ROI(NUM)
REAL, INTENT(OUT) :: EPSI(NUM)
INTEGER :: I
!ATOURE REAL VFI(NUM), EHB, ESB
REAL :: EHB, ESB

REAL,DIMENSION(:),ALLOCATABLE :: VFI
ALLOCATE(VFI(NUM))

VFI=ROI/0.917
EHB=0.99913
ESB=1.4759

DO I=1,NUM
  IF (ROI(I)<=0.4) THEN
    EPSI(I)=1+1.5995*ROI(I)+1.861*ROI(I)**3
  ELSE
   EPSI(I)=((1-VFI(I))*EHB+VFI(I)*ESB)**3
  END IF
END DO                  
DEALLOCATE(VFI)
END SUBROUTINE EPSR

! -------------------------------------------------------------------------
!
SUBROUTINE EPSS(MV,T,F,EPSS_VAR)
!
! -------------------------------------------------------------------------
!
!     CODE ORIGINALLY OBTAINED IN MATLAB FROM PULLIAINEN
!
!     FUNCTION FOR CALCULATING EPSILON FOR SOIL USING FREQUENCY,
!     TEMPERATURE AND VOLUMETRIC SOIL MOSITURE. USES EPSW.M FOR 
!     DIELECTRICITY OF WATER. 
!
!     BY J. PULLIAINEN (MOD. BY K. TIGERSTEDT) 
! 
!     MV [0..1]
!     T [C]
!     F [HZ]
!
!     NOTE: SOME FINNISH COMMENTS WERE NOT COPIED IN ENTIRETY -MD
!   VERSION HISTORY:
!      1.0    JP ?.?.?
!      1.1    KT ?.?.?
!      2.0    MD 1 APR 05 TRANSLATED TO FORTRAN FROM MATLAB

REAL,INTENT(IN) :: MV,T,F
COMPLEX,INTENT(OUT) :: EPSS_VAR
REAL S,CLAY,RHOS,BETA,ALFA,REI,A,B,C,M,IEI_S,A_P,B_P,C_P,IEI_P,&
DELTA_IEI,INVT,ALF,B_1,B_2,BB,BET_M,BET_DELTA,BET,IEI,SS,EW_R,EW_I
COMPLEX EW,EPSALF
      
S=0.4                          ! SAND FRACTION
CLAY=0.3                       ! CLAY FRACTION
RHOS=1.1                       ! DRY-MATTER DENSITY

BETA=1.09-0.11*S+0.18*CLAY
ALFA=0.65

IF(T>0)THEN
  CALL EPSW(F,T,EW_R,EW_I)
ELSE
  REI=3.1884+9.1E-4*T          ! MATZLER AND WEGMULLER 1987
  A=0.0026                     ! IMPURE ICE -5 ASTETTA (MATZLER)
  B=0.00023
  C=0.87
  M=F/1E9
  IEI_S=A/M+B*M**C
  A_P=6E-4                     ! PURE ICE -5 ASTETTA (MATZLER)
  B_P=6.5E-5
  C_P=0.7
  IEI_P=A_P/M+B_P*M**C_P
  DELTA_IEI=IEI_S-IEI_P

  ! HUFFORD 1991        
  INVT=300/(T+273)-1
  ALF=(0.00504+0.0062*INVT)*EXP(-22.1*INVT)

  ! (MISHIMA,MATZLER)
  B_1=0.0207
  B_2=1.16E-11
  BB=335
  BET_M=B_1/(T+273)*EXP(BB/(T+273))/(EXP(BB/(T+273))-1)**2+B_2*M**2
  BET_DELTA=EXP(-10.02+0.0364*T)
  BET=BET_M+BET_DELTA
  IEI=ALF/M+BET*M
  SS=10
  IEI=IEI+DELTA_IEI*SS/13
  EW_R=REI
  EW_I=IEI
END IF

EW=CMPLX(EW_R,(-1*EW_I))

EPSALF=1+0.65*RHOS+MV**BETA*(EW**ALFA-1)

EPSS_VAR=EPSALF**(1/ALFA)        

END SUBROUTINE EPSS


! -------------------------------------------------------------------------
!
SUBROUTINE EPSW(F,T,EW_R,EW_I)
!
! -------------------------------------------------------------------------
!
!     CODE ORIGINALLY OBTAINED IN MATLAB FROM PULLIAINEN
!
!     LASKEE PUHTAAN VEDEN EPSILONIN TAAJUUDEN F, 
!     L MP TILAN T FUNKTIONA
!     5.12.89 JPK; 17.2.1993 JP
!    VERSION HISTORY:
!      1.0    JPK 5.12.89 
!      1.1    JP 17.02.93
!      2.0    MD 1 APR 05 TRANSLATED TO FORTRAN FROM MATLAB
!
!     NOTE: ADDITIONAL COMMENTS IN FINNISH NOT COPIED HERE -MD

REAL,INTENT(IN) :: F,T
REAL,INTENT(OUT) :: EW_R,EW_I
REAL S,E0,EW_INF,EW0,N,D,ALFA,SIGMA_25,SIGMA_VAR,TW,PI,SIGMA

PI=3.14159
S=0
E0=8.854E12
EW_INF=4.9
EW0=87.74-0.40008*T+9.398E-4*T**2+1.410E-6*T**3
N=0

D=25-T
ALFA=2.033E-2+1.266E-4*D+2.462E-6*D**2-S*(1.849E-5-2.551E-7*D+&
             2.551E-8*D**2)

SIGMA_25=S*(0.182521-1.46192E-3*S+2.09324E-5*S**2-1.28205E-7*S**3)
SIGMA=SIGMA_25*EXP(-D*ALFA)

TW=1/(2*PI)*(1.1109E-10-3.824E-12*T+6.938E-14*T*T-5.096E-16*T*T*T)

EW_R=EW_INF+(EW0-EW_INF)/(1+(2*PI*F*TW)**2)
EW_I=(EW0-EW_INF)*2*PI*F*TW/(1+(2*PI*F*TW)**2)+SIGMA/(2*PI*E0*F)

END SUBROUTINE EPSW

! -------------------------------------------------------------------------
!
SUBROUTINE FRESNELC(TEI,EPSI,SIH,SIV,NUM)
!
! -------------------------------------------------------------------------
!
!     CODE ORIGINALLY OBTAINED IN MATLAB FROM MATZLER
!
!   FRESNEL REFLECTION COEFFICIENTS (ASSUMING EPS'' = 0)
!     (LAYER N+1 IS THE AIR ABOVE THE SNOWPACK)
!
!   [SIH,SIV] = FRESNEL(TEI,ROI)
!       SIH:  INTERFACE REFLECTIVITY AT H POL
!       SIV:  INTERFACE REFLECTIVITY AT V POL
!       TEI:  LOCAL INCIDENCE ANGLE
!       EPSI: REAL PART OF DIELECTRIC PERMITTIVITY
!
!   VERSION HISTORY:
!      1.0    WI 15.7.97
!      2.0    MD 1 APR 05 TRANSLATED TO FORTRAN FROM MATLAB
!   
!   USES:
!       EPSR
!
!
!   COPYRIGHT (C) 1997 BY THE INSTITUTE OF APPLIED PHYSICS, 
!   UNIVERSITY OF BERN, SWITZERLAND


INTEGER, INTENT(IN) :: NUM
REAL, INTENT(IN) :: TEI(NUM+1),EPSI(NUM)
!ctvs REAL, INTENT(OUT) :: SIH(NUM-1),SIV(NUM-1)
REAL, INTENT(OUT) :: SIH(NUM),SIV(NUM)
INTEGER :: I
REAL EPSO,EPSU,TEIN
REAL,DIMENSION(:),ALLOCATABLE :: EPSI_LOCAL

ALLOCATE(EPSI_LOCAL(NUM+1))

EPSI_LOCAL(1:NUM)=EPSI
EPSI_LOCAL(NUM+1)=1

DO I=1,NUM
  EPSO=EPSI_LOCAL(I+1)
  EPSU=EPSI_LOCAL(I)
  TEIN=TEI(I+1)
  SIH(I)=((EPSO**0.5*COS(TEIN)-(EPSU-EPSO*SIN(TEIN)**2)**0.5)/&
          (EPSO**0.5*COS(TEIN)+(EPSU-EPSO*SIN(TEIN)**2)**0.5))**2
  SIV(I)=((EPSU*COS(TEIN)-EPSO**0.5*(EPSU-EPSO*SIN(TEIN)**2)**0.5)/&
          (EPSU*COS(TEIN)+EPSO**0.5*(EPSU-EPSO*SIN(TEIN)**2)**0.5))**2
END DO        
DEALLOCATE(EPSI_LOCAL)

END SUBROUTINE FRESNELC

! -------------------------------------------------------------------------
!
SUBROUTINE FRESNELRC(TEI,EPSI,FH,FV,NUM)
!
! -------------------------------------------------------------------------
!
!     CODE ORIGINALLY OBTAINED IN MATLAB FROM MATZLER
!
!
!   FRESNEL REFLECTION COEFFICIENTS (ASSUMING EPS'' = 0)
!     (LAYER N+1 IS THE AIR ABOVE THE SNOWPACK)
!
!   [FH,FV] = FRESNELRC(TEI,EPSR)
!       FH:   FRESNEL REFLECTION COEFFICIENT AT H POL
!       FV:   FRESNEL REFLECTION COEFFICIENT AT V POL
!       TEI:  LOCAL INCIDENCE ANGLE
!       EPSR: (REAL PART) DIELECTRIC PERMITTIVITY
!
!   VERSION HISTORY:
!      1.0    WI 15.7.95
!      2.0    MD 1 APR 05 TRANSLATED TO FORTRAN FROM MATLAB
!   
!   USES:
!
!
!
!   COPYRIGHT (C) 1997 BY THE INSTITUTE OF APPLIED PHYSICS, 
!   UNIVERSITY OF BERN, SWITZERLAND

INTEGER,INTENT(IN) :: NUM
REAL,INTENT(IN) :: TEI(NUM+1),EPSI(NUM+1)
REAL,INTENT(OUT) :: FH(NUM),FV(NUM)
INTEGER N
REAL EPSN,TEIN,SINQ,QEPS,WURZ,WSUB,ND
      
DO N=1,NUM
  EPSN=EPSI(N)/EPSI(N+1)
  TEIN=TEI(N+1)
  SINQ=SIN(TEIN)**2
  QEPS=SINQ/EPSN
  WURZ=(1-QEPS)**0.5
  WSUB=EPSN-SINQ
  ND=EPSN**0.5
        
  FH(N)=((ND*WURZ-COS(TEIN))/(ND*WURZ+COS(TEIN)))
  FV(N)=((WURZ-ND*COS(TEIN))/(WURZ+ND*COS(TEIN)))
END DO             

END SUBROUTINE FRESNELRC

! -------------------------------------------------------------------------
!
SUBROUTINE GAMMAH(EPSS,THETA,GAMMAH_VAR)
!
! -------------------------------------------------------------------------
!
!     CODE ORIGINALLY OBTAINED IN MATLAB FROM PULLIAINEN
!
!    VERSION HISTORY:
!      1.0    JPK 5.12.89 
!      1.1    JP 17.03.93
!      2.0    MD 1 APR 05 TRANSLATED TO FORTRAN FROM MATLAB
!
!     NOTE: ADDITIONAL FINNISH COMMENTS NOT COPIED HERE

      REAL,INTENT(IN) :: THETA
      COMPLEX,INTENT(IN) :: EPSS      
      REAL,INTENT(OUT) :: GAMMAH_VAR
      REAL THETA_RAD,PI,COSTHETA
      COMPLEX NELIO

      PI=3.14159
      THETA_RAD=THETA/180*PI
      COSTHETA=COS(THETA_RAD)
      NELIO=SQRT(EPSS-SIN(THETA_RAD)**2)
      GAMMAH_VAR=(ABS((COSTHETA-NELIO)/(COSTHETA+NELIO)))**2

      END SUBROUTINE GAMMAH

! -------------------------------------------------------------------------
!
      SUBROUTINE GAMMAV(EPSS,THETA,GAMMAV_VAR)
!
! -------------------------------------------------------------------------
!
!     CODE ORIGINALLY OBTAINED IN MATLAB FROM PULLIAINEN
!
!    VERSION HISTORY:
!      1.0    JPK 5.12.89 
!      1.1    JP 17.03.93
!      2.0    MD 1 APR 05 TRANSLATED TO FORTRAN FROM MATLAB
!
!     NOTE: ADDITIONAL FINNISH COMMENTS NOT COPIED HERE

      REAL,INTENT(IN) :: THETA
      COMPLEX,INTENT(IN) :: EPSS      
      REAL,INTENT(OUT) :: GAMMAV_VAR
      REAL THETA_RAD,PI,COSTHETA
      COMPLEX NELIO

      PI=3.14159
      THETA_RAD=THETA/180*PI
      COSTHETA=COS(THETA_RAD)
      NELIO=SQRT(EPSS-SIN(THETA_RAD)**2)
      GAMMAV_VAR=(ABS((EPSS*COSTHETA-NELIO)/(EPSS*COSTHETA+NELIO)))**2

      END SUBROUTINE GAMMAV

! -------------------------------------------------------------------------
!
      SUBROUTINE INTEGRFI(XX,MUI,MUO,STEPS,INTEGR,NUM)
!
! -------------------------------------------------------------------------
!
!   CODE ORIGINALLY OBTAINED IN MATLAB FROM MATZLER
!
!   CALCULATES INTEGRATION  OVER INCIDENT DIRECTIONS, MUI
!       FROM MINI TO MAXI IN STEPS INTERVALS OF THE FI
!       PHASE FUNCTION.
!   
!
!   INTEGR = INTEGRFI(XX,MUI,MUO,STEPS)
!
!   VERSION HISTORY:
!      1.0     WI 27.05.98 
!      2.0    MD 1 APR 05 TRANSLATED TO FORTRAN FROM MATLAB
!
!   USES: - NONE
!     
!   COPYRIGHT (C) 1998 BY THE INSTITUTE OF APPLIED PHYSICS, 
!   UNIVERSITY OF BERN, SWITZERLAND

      INTEGER,INTENT(IN) :: NUM,STEPS
      REAL, INTENT(IN) :: XX(NUM),MUI(NUM),MUO(NUM)
      REAL, INTENT(OUT) :: INTEGR(NUM)
      REAL PI,DELTA,F0,X2(NUM),FI,SII(NUM),SIO(NUM),COFI,SI2FI,COSTE(NUM),&
             SI2CHI(NUM),FUNC(NUM)

      INTEGER IFI

      PI=3.14159
      DELTA=PI/STEPS
      F0=0.5*DELTA
      INTEGR=0
      X2=2*XX**2

      DO IFI=1,STEPS
        FI=F0+(IFI-1)*DELTA
        SII=(1-MUI**2)**0.5
        SIO=(1-MUO**2)**0.5
        COFI=COS(FI)
        SI2FI=1-COFI**2
        COSTE=MUI*MUO+SII*SIO*COFI
        SI2CHI=0.5*(1+COSTE**2)
        FUNC=SI2CHI/(1+(1-COSTE)*X2)**2
        INTEGR=INTEGR+FUNC*DELTA
      END DO

      INTEGR=INTEGR/PI

      END SUBROUTINE INTEGRFI

! -------------------------------------------------------------------------
!
      SUBROUTINE INTEGRMUI(NUM, ARG_LENGTH, XX, MINI, MAXI, MINO, MAXO, STEPS, INTEGR)
!
! -------------------------------------------------------------------------
!
!     CODE ORIGINALLY OBTAINED IN MATLAB FROM MATZLER
!
!   CALCULATES INTEGRATION  OVER INCIDENT DIRECTIONS, MUI
!       FROM MINI TO MAXI IN STEPS INTERVALS OF THE FI AND
!       MUO INTEGRATED PHASE FUNCTION.
!   
!
!   INTEGR = INTEGRMUI(XX,MINI,MAXI,MINO,MAXO,STEPS)
!
!   VERSION HISTORY:
!      1.0     WI 27.05.98 
!      2.0    MD 1 APR 05 TRANSLATED TO FORTRAN FROM MATLAB
!
!   USES: INTEGRMUO
!     
!   COPYRIGHT (C) 1998 BY THE INSTITUTE OF APPLIED PHYSICS, 
!   UNIVERSITY OF BERN, SWITZERLAND
       
integer, intent(in)  :: NUM
integer, intent(in)  :: ARG_LENGTH(2)
real,    intent(in)  :: XX(NUM)
real,    intent(in)  :: MINI(NUM)
real,    intent(in)  :: MAXI
real, dimension(:), intent(in) :: MINO
real, dimension(:), intent(in) :: MAXO
integer, intent(in)  :: STEPS 
real,    intent(out) :: INTEGR(NUM)

REAL :: DMU(NUM),DELTA(NUM),F0(NUM),MUI(NUM),FUNC(NUM), STEPSR
INTEGER ::  IMU

      STEPSR=REAL(STEPS)
      DMU=MAXI-MINI
      DELTA=DMU/STEPS
      F0=0.5*DELTA
      INTEGR=0.

      DO IMU=1,STEPS
        MUI=MINI+F0+(IMU-1)*DELTA
        CALL INTEGRMUO(XX,MUI,MINO,MAXO,STEPS,FUNC,NUM,ARG_LENGTH)
        INTEGR=INTEGR+FUNC*DELTA
      END DO

      INTEGR=INTEGR/DMU

      END SUBROUTINE INTEGRMUI

! -------------------------------------------------------------------------
!
      SUBROUTINE INTEGRMUO(XX,MUI,MINO,MAXO,STEPS,INTEGR,NUM,ARG_LENGTH)
!
! -------------------------------------------------------------------------
!
!     CODE ORIGINALLY OBTAINED IN MATLAB FROM MATZLER
!
!   CALCULATES INTEGRATION  OVER INCIDENT DIRECTIONS, MUI
!       FROM MINO TO MAXO IN STEPS INTERVALS OF THE FI
!       PHASE FUNCTION.
!   
!
!   INTEGR = INTEGRMUO(XX,MUI,MINO,MAXO,STEPS)
!
!   VERSION HISTORY:
!      1.0     WI 27.05.98 
!      2.0    MD 1 APR 05 TRANSLATED TO FORTRAN FROM MATLAB
!
!   USES: INTEGRFI
!     
!   COPYRIGHT (C) 1998 BY THE INSTITUTE OF APPLIED PHYSICS, 
!   UNIVERSITY OF BERN, SWITZERLAND      

      REAL :: XX(NUM)
      INTEGER,INTENT(IN) :: NUM,STEPS,ARG_LENGTH(2)
      REAL,INTENT(IN) :: MUI(NUM),MINO(ARG_LENGTH(1)),MAXO(ARG_LENGTH(2))
      REAL,INTENT(OUT) :: INTEGR(NUM)
      REAL DMU(NUM),DELTA(NUM),F0(NUM),MUO(NUM),FUNC(NUM),MINOS,MAXOS
      INTEGER IMU,I

      IF (ARG_LENGTH(1)==1) THEN
!       N.B. IF MINO IS SCALAR, MAXO IS VECTOR
        MINOS=MINO(1)
        DMU=MAXO-MINOS
      ELSEIF (ARG_LENGTH(2)==1) THEN
!       N.B. IF MAXO IS SCALAR, MINO IS VECTOR
        MAXOS=MAXO(1)
        DMU=MAXOS-MINO
      ELSE
        DMU=MAXO-MINO
      END IF     

      DELTA=DMU/STEPS
      F0=0.5*DELTA
      INTEGR=0.
      
      DO IMU=1,STEPS
        IF (ARG_LENGTH(1)==1) THEN
          MUO=MINOS+F0+(IMU-1)*DELTA
        ELSE
          MUO=MINO+F0+(IMU-1)*DELTA
        END IF
        CALL INTEGRFI(XX,MUI,MUO,STEPS,FUNC,NUM)
        INTEGR=INTEGR+FUNC*DELTA
      END DO

      INTEGR=INTEGR/2

      END SUBROUTINE INTEGRMUO

! -------------------------------------------------------------------------
!
      SUBROUTINE INVERT_MATRIX(MA,INV,N)
!
! -------------------------------------------------------------------------
!     
!     MATRIX INVERSION ALGORITHM OBTAINED FROM GOTOP FORTRAN 90 TEXT,
!     ISBN:957-566-172-9
!
!     COPIED FROM THE COMPANION CD TO THAT TEXT BY MIKE, 1 APRIL 2005

      INTEGER,INTENT(IN) :: N
      REAL,INTENT(IN) :: MA(N,N)
      REAL,INTENT(OUT) :: INV(N,N)
      REAL TEMP(N,N)
      INTEGER I,J

      DO I=1,N
        DO J=1,N
          TEMP(I,J)=MA(I,J)
          INV(I,J)=0.
        END DO
        INV(I,I)=1.
      END DO

      CALL UPPER(TEMP,INV,N)
      CALL LOWER(TEMP,INV,N)

      DO I=1,N
        DO J=1,N
          INV(I,J)=INV(I,J)/TEMP(I,I)
        END DO
      END DO


      CONTAINS

      SUBROUTINE UPPER(M,S,N)
        INTEGER N
        INTEGER I,J,K
        REAL E
        REAL M(N,N)
        REAL S(N,N)

        DO I=1,N-1
          DO J=I+1,N            
            E=M(J,I)/M(I,I)
            DO K=1,N
              M(J,K)=M(J,K)-M(I,K)*E
              S(J,K)=S(J,K)-S(I,K)*E       ! §±aªº¯x°}òµÛ°µ¥[îªk
            END DO
          END DO
        END DO

      END SUBROUTINE UPPER

      SUBROUTINE LOWER(M,S,N)
        INTEGER N
        REAL M(N,N)
        REAL S(N,N)
        INTEGER I,J,K
        REAL E

        DO I=N,2,-1
          DO J=I-1,1,-1         
            E=M(J,I)/M(I,I)
            DO K=1,N
              M(J,K)=M(J,K)-M(I,K)*E
              S(J,K)=S(J,K)-S(I,K)*E           ! §±aªº¯x°}òµÛ°µ¥[îªk
            END DO
          END DO
        END DO

      END SUBROUTINE LOWER

      END SUBROUTINE INVERT_MATRIX

! -------------------------------------------------------------------------
!
      SUBROUTINE LAYER(RI,SI,TRI,TI,TGND,TSKY,D,NUM)
!
! -------------------------------------------------------------------------
!
!     CODE ORIGINALLY OBTAINED IN MATLAB FROM MATZLER
!
!   CALCULATES THE UPWELLING BRIGHTNESS TEMPERATURES D (SEE NOTE 6)  
!
!   D = LAYER(RI,SI,TI,TI,TGND,TSKY)
!       D:    UPWELLING BRIGHTNESS TEMPERATURE
!       RI:   LAYER REFLECTIVITY
!       SI:   INTERFACE REFLECTIVITY
!       TI:   LAYER TRANSMISSIVITY
!       TI:   PHYSICAL TEMPERATURE [K]
!       TGND: BRIGHTNESS TEMPERATURE OF THE SOIL BELOW THE SNOWPACK
!       TSKY: BRIGHTNESS TEMPERATURE OF THE SKY
!
!   VERSION HISTORY:
!      1.0    WI 15.7.95
!      1.1    WI 26.9.97  HANDLES ALSO THE SPECIAL CASE OF A SINGLE LAYER NOW
!      1.2    WI 02.03.99 FIXED ERROR IN 1 LAYER HANDLING 
!      2.0    MD 1 APR 05 TRANSLATED TO FORTRAN FROM MATLAB
!  
!   USES: - INVERT_MATRIX SUBROUTINE BY MIKE,ZEROSI INTERNAL FUNCTION BY MIKE, AND 
!              EYEI INTERNAL FUNCTION BY MIKE
!
!   COPYRIGHT (C) 1997 BY THE INSTITUTE OF APPLIED PHYSICS, 
!   UNIVERSITY OF BERN, SWITZERLAND

      INTEGER,INTENT(IN) :: NUM
      REAL,INTENT(IN) :: RI(NUM),SI(NUM+1),TRI(NUM),TI(NUM),TGND,TSKY
      REAL,INTENT(OUT) :: D(NUM)
      REAL EI(NUM),K1,M1(NUM,NUM),H(NUM-1,NUM-1),EYE(NUM,NUM),M2(NUM,NUM),&
             M3(NUM,NUM),M4(NUM,NUM),E(NUM),F(NUM),M5(NUM,NUM),&
             INVIM1(NUM,NUM),INVIM5(NUM,NUM)             
      INTEGER ROW,COL,I

      EI=1-RI-TRI

      IF (NUM==1) THEN
        K1=(1-RI(1)*SI(1))*(1-RI(1)*SI(2))-TRI(1)*SI(1)*TRI(1)*SI(2)
        D=TRI(1)*SI(1)*((1-SI(1))*RI(1)*TGND+(1-SI(2))*TSKY*TRI(1)+&
            EI(1)*TI(1))/K1+(1-RI(1)*SI(1))*((1-SI(1))*TGND*TRI(1)+&
            (1-SI(2))*TSKY*RI(1)+EI(1)*TI(1))/K1
      ELSE
!       INITIALIZE ARRAYS
        M1=ZEROSI(NUM,NUM)
        H=ZEROSI(NUM-1,NUM-1)
        M2=ZEROSI(NUM,NUM)
        M3=ZEROSI(NUM,NUM)
        M4=ZEROSI(NUM,NUM)

        DO I=1,NUM
          M1(I,I)=RI(I)*SI(I)
        END DO
        DO I=1,NUM-1
          H(I,I)=TRI(I)*(1-SI(I+1))
        END DO
        M1(1:NUM-1:1,2:NUM:1)=M1(1:NUM-1:1,2:NUM:1)+H

        EYE=EYEI(NUM)
        H=ZEROSI(NUM-1,NUM-1)
        DO I=1,NUM
          M2(I,I)=TRI(I)*SI(I+1)
        END DO
        DO I=2,NUM
          H(I-1,I-1)=RI(I)*(1-SI(I))
        END DO
        M2(2:NUM:1,1:NUM-1:1)=M2(2:NUM:1,1:NUM-1:1)+H

        H=ZEROSI(NUM-1,NUM-1)
        DO I=1,NUM
          M3(I,I)=TRI(I)*SI(I)
        END DO
        DO I=1,NUM-1
          H(I,I)=RI(I)*(1-SI(I+1))
        END DO
        M3(1:NUM-1:1,2:NUM:1)=M3(1:NUM-1:1,2:NUM:1)+H

        H=ZEROSI(NUM-1,NUM-1)
        DO I=1,NUM
          M4(I,I)=RI(I)*SI(I+1)
        END DO
        DO I=2,NUM
          H(I-1,I-1)=TRI(I)*(1-SI(I))
        END DO
        M4(2:NUM:1,1:NUM-1:1)=M4(2:NUM:1,1:NUM-1:1)+H

        E=EI*TI
        E(1)=E(1)+RI(1)*(1-SI(1))*TGND
        E(NUM)=E(NUM)+TRI(NUM)*(1-SI(NUM+1))*TSKY

        F=EI*TI
        F(1)=F(1)+TRI(1)*(1-SI(1))*TGND
        F(NUM)=F(NUM)+RI(NUM)*(1-SI(NUM+1))*TSKY

      END IF
   
      CALL INVERT_MATRIX(EYE-M1,INVIM1,NUM)

      M5=MATMUL(M3,MATMUL(INVIM1,M2))+M4
      CALL INVERT_MATRIX(EYE-M5,INVIM5,NUM)

      D=MATMUL(INVIM5,(MATMUL(MATMUL(M3,INVIM1),E)+F))

      CONTAINS

      FUNCTION ZEROSI(ROW,COL)

        ! BY MIKE, 1 APRIL 2005
        !
        ! THIS FUNCTION IS INTERNAL TO LAYER SUBROUTINE
        ! MANY VALUES IN THE ABOVE ARRAYS ARE NEVER A VALUE OTHER THAN ZERO, SO INSTEAD OF 
        ! USING WHATEVER VALUES ARE RANDOMLY ALLOCATED TO THE ARRAYS WHEN THEY ARE ALLOCATED,
        ! I SPECIFICALLY SET EACH POSITION TO ZERO.  THIS FUNCTION SHOULD BE ENTIRELY 
        ! UNNECESSARY, SINCE THE DEFAULT VALUES IN THE ARRAY SHOULD BE ZERO. NONETHELESS, 
        ! I DECIDED TO EXPLICITLY ZERO OUT 2-D ARRAYS BEFORE USING THEM

        INTEGER,INTENT(IN):: ROW,COL
        REAL :: ZEROSI(ROW,COL)
        INTEGER I,J

        DO I=1,ROW
          DO J=1,COL
            ZEROSI(I,J)=0.
          END DO
        END DO

      END FUNCTION ZEROSI

      FUNCTION EYEI(NUM)


        ! BY MIKE, 1 APRIL 2005
        !
        ! THIS FUNCTION IS INTERNAL TO LAYER SUBROUTINE
        ! THIS FUNCTION DEFINES AN IDENTITY MATRIX OF SIZE NUM

        INTEGER, INTENT(IN) :: NUM
        REAL :: EYEI(NUM,NUM)
        INTEGER I,J
        DO I=1,NUM
          DO J=1,NUM
            IF (I==J) THEN
              EYEI(I,J)=1
            ELSE
              EYEI(I,J)=0
            END IF
          END DO
        END DO
      END FUNCTION EYEI
        

      END SUBROUTINE LAYER

! -------------------------------------------------------------------------
!
      SUBROUTINE MIXMOD(FREQ,TI,WIFR,EPSI,EPSII,NUM)
!
! -------------------------------------------------------------------------
!
!     CODE ORIGINALLY OBTAINED IN MATLAB FROM MATZLER
!
!   CALCULATES THE PERMITTIVITY FOR WETNESS > 0
!      PHYSICAL MIXING MODEL WEISE 97 AFTER MATZLER 1987 (CORRECTED)
!      WATER TEMPERATURE IS ASSUMED CONSTANT AT 273.15 K
!
!   [EPSI,EPSII] = MIXMOD(F,TI,WI,EPSI,EPSII)
!       EPSI:  REAL PART OF THE PERMITTIVITY
!       EPSII: IMAGINARY PART OF THE PERMITTIVITY
!       F:     FREQUENCY [GHZ]
!       TI:    PHYSICAL SNOW TEMPERATURE
!       WI:    WETNESS [!]
!       EPSI:  REAL PART OF DRY SNOW PERM.
!       EPSII: IMAGINARY PART OF DRY SNOW PERM.
!
!   VERSION HISTORY:
!      1.0    WI 15.7.95
!      2.0    MD 1 APR 05 TRANSLATED TO FORTRAN FROM MATLAB
!   
!   USES: - NONE
!
!   COPYRIGHT (C) 1997 BY THE INSTITUTE OF APPLIED PHYSICS, 
!   UNIVERSITY OF BERN, SWITZERLAND

      INTEGER, INTENT(IN) :: NUM
      REAL, INTENT(IN) :: FREQ, TI(NUM), WIFR(NUM)
      REAL, INTENT(INOUT) :: EPSI(NUM), EPSII(NUM)
      REAL AA,AB,AC,EUW,ESW,FRW,ESA(NUM),ESB(NUM),ESC(NUM),EUA(NUM),&
           EUB(NUM),EUC(NUM),FA(NUM),FB(NUM),FC(NUM),EEA(NUM),EEB(NUM),&
           EEC(NUM),FWA(NUM),FWB(NUM),FWC(NUM),DEPSIA(NUM),DEPSIB(NUM),&
           DEPSIC(NUM),DEPSI(NUM),DEPSIIA(NUM),DEPSIIB(NUM),DEPSIIC(NUM),&
           DEPSII(NUM)

      AA=0.005
      AB=0.4975
      AC=0.4975
      EUW=4.9
      ESW=88.045
      FRW=0.11109                            ! INVERSE RELAXATION FREQUENCY OF WATER
      ESA=(ESW-EPSI)/(3*(1+AA*(ESW/EPSI-1)))
      ESB=(ESW-EPSI)/(3*(1+AB*(ESW/EPSI-1)))
      ESC=(ESW-EPSI)/(3*(1+AC*(ESW/EPSI-1)))
      EUA=(EUW-EPSI)/(3*(1+AA*(EUW/EPSI-1)))
      EUB=(EUW-EPSI)/(3*(1+AB*(EUW/EPSI-1)))
      EUC=(EUW-EPSI)/(3*(1+AC*(EUW/EPSI-1)))

      FA=1+AA*(ESW-EUW)/(EPSI+AA*(EUW-EPSI))
      FB=1+AB*(ESW-EUW)/(EPSI+AB*(EUW-EPSI))
      FC=1+AC*(ESW-EUW)/(EPSI+AC*(EUW-EPSI))

      EEA=ESA-EUA
      EEB=ESB-EUB
      EEC=ESC-EUC

      FWA=FRW/FA
      FWB=FRW/FB      
      FWC=FRW/FC

      DEPSIA=EUA+EEA/(1+(FWA*FREQ)**2)
      DEPSIB=EUB+EEB/(1+(FWB*FREQ)**2)
      DEPSIC=EUC+EEC/(1+(FWC*FREQ)**2)
      DEPSI=WIFR*(DEPSIA+DEPSIB+DEPSIC)

      DEPSIIA=FWA*FREQ*EEA/(1+(FWA*FREQ)**2)
      DEPSIIB=FWB*FREQ*EEB/(1+(FWB*FREQ)**2)
      DEPSIIC=FWC*FREQ*EEC/(1+(FWC*FREQ)**2)
      DEPSII=WIFR*(DEPSIIA+DEPSIIB+DEPSIIC)

      EPSI=EPSI+DEPSI
      EPSII=EPSII+DEPSII

      END SUBROUTINE MIXMOD

! -------------------------------------------------------------------------
!
      SUBROUTINE OXABSORP(F,T,P,K_O2)
!
! -------------------------------------------------------------------------
!     FUNCTION FOR CALCULATING OXYGEN ABSORPTION COEFFICIENT [DB/KM]
!     F IS FREQUENCY IN GHZ
!     T IS TEMPERATURE IN KELVINS
!     P IS PRESSURE IN MILLIBARS
!
!     HISTORY
!       1.0   KT ? NOV 96  PROGRAMMED
!       1.1   ?? ? FEB 98  ABSORPTION DATA NOW INCLUDED IN FUNCTION
!       2.0   MD 6 JUN 05  TRANSLATED TO FORTRAN
!
!     CODE ORIGINALLY OBTAINED IN MATLAB FROM PULLIAINEN


       REAL,INTENT(IN):: F,T,P
       REAL,INTENT(OUT)::K_O2
       INTEGER I
       REAL OXFIC(20,4),FNP(20),FNM(20),YNP(20),YNM(20),SIGMA,&
              GAN,GAB,DNP,DNM,GNPLUSF,GNPLUSMF,GNMINUSF,GNMINUSMF,&
              THETAN,FDOT,NR
       INTEGER N
 
       
       ! THESE DATA IN TABLE 5.4 IN ULABLY (1981) 
       OXFIC=RESHAPE((/&
       56.2648,118.7503,4.51e-4,-2.14e-5,& 
       58.4466,62.4863,4.94e-4,-3.78e-4,& 
       59.5910,60.3061,3.52e-4,-3.92e-4,& 
       60.4348,59.1642,1.86e-4,-2.68e-4,& 
       61.1506,58.3239,3.30e-5,-1.13e-4,& 
       61.8002,57.6125,-1.03e-4,3.44e-5,& 
       62.4112,56.9682,-2.23e-4,1.65e-4,& 
       62.9980,56.3634,-3.32e-4,2.84e-4,& 
       63.5685,55.7838,-4.32e-4,3.91e-4,& 
       64.1278,55.2214,-5.26e-4,4.93e-4,& 
       64.6789,54.6711,-6.13e-4,5.84e-4,& 
       65.2241,54.1300,-6.99e-4,6.76e-4,& 
       65.7647,53.5957,-7.74e-4,7.55e-4,& 
       66.3020,53.0668,-8.61e-4,8.47e-4,& 
       66.8367,52.5422,-9.11e-4,9.01e-4,& 
       67.3694,52.0212,-1.03e-3,1.03e-3,& 
       67.9007,51.5030,-9.87e-4,9.86e-4,& 
       68.4308,50.9873,-1.32e-3,1.33e-3,& 
       68.9601,50.4736,-7.07e-4,7.01e-4,& 
       69.4887,49.9618,-2.58e-3,2.64e-3/),&
       (/20,4/),ORDER=(/2,1/))

       FNP=OXFIC(:,1)
       FNM=OXFIC(:,2)
       YNP=OXFIC(:,3)
       YNM=OXFIC(:,4)
       
       SIGMA=0

       DO N=1,39,2
         I=(N-1)/2+1
         
         ! THESE NEXT FOUR STATEMENTS ARE FROM 5.37-5.39 IN ULABLY (1981)
         GAN = 1.18*(P/1013)*(300/T)**0.85
         GAB = 0.49*(P/1013)*(300/T)**0.89

         ! THIS PART JUST CHANGED... MD
         NR=REAL(N)
         DNP = SQRT(NR*(2.*NR+3.)/((NR+1.)*(2.*NR+1.)))
         DNM = SQRT((NR+1.)*(2.*NR-1)/(NR*(2.*NR+1.)))

         !THESE CORRESPOND TO 5.35
         GNPLUSF=(GAN*DNP**2+P*(F-FNP(I))*YNP(I))/((F-FNP(I))**2+GAN**2)
         GNPLUSMF=(GAN*DNP**2+P*(-F-FNP(I))*YNP(I))/((-F-FNP(I))**2+GAN**2)
         GNMINUSF=(GAN*DNM**2+P*(F-FNM(I))*YNM(I))/((F-FNM(I))**2+GAN**2)
         GNMINUSMF=(GAN*DNM**2+P*(-F-FNM(I))*YNM(I))/((-F-FNM(I))**2+GAN**2)

         !THIS CORRESPONDS TO 5.36
         THETAN = 4.6E-3*(300/T)*(2*N+1)*EXP(-6.89E-3*N*(N+1)*(300/T))

         ! THIS CORRESPONDS TO THE SECOND TERM ON RHS OF 5.34
         SIGMA = SIGMA + THETAN*(GNPLUSF + GNPLUSMF + GNMINUSF + GNMINUSMF)
       END DO

       !THIS CORRESPONDS TO 5.34
       FDOT = 0.7*GAB/(F**2 + GAB**2) + SIGMA

       !THIS CORRESPONDS TO 5.33
       K_O2 = 1.61E-2*F**2*(P/1013)*(300/T)**2*FDOT

       END SUBROUTINE OXABSORP

! -------------------------------------------------------------------------
!
      SUBROUTINE PFADC(TETA,DI,EPSI,GS6,DEI,TEI,TSCAT,NUM)
!
! -------------------------------------------------------------------------
!
!      CODE ORIGINALLY OBTAINED IN MATLAB FROM MATZLER
!
!   CALCULATES THE EFFECTIVE PATH LENGTH IN A LAYER
!
!   [DEI,TEI,TSCAT] = PFADC(TETA,DI,EPSI,GS6)
!       DEI:  EFFECTIVE PATH LENGTH [M]
!       TEI:  LOCAL INCIDENCE ANGLE
!       TSCAT: SCATTERING 
!       TETA: INCIDENCE ANGLE AT SNOW AIR INTERFACE
!       DI:   THICKNESS [M]
!       EPSI: DIELECTRIC PERMITTIVITY
!       GS6:  6-FLUX SCATTERING COEFFICIENT
!
!   VERSION HISTORY:
!      1.0    WI 15.10.97
!      2.0    MD 1 APR 05 TRANSLATED TO FORTRAN FROM MATLAB
!
!   
!   USES: - NONE
!
!   COPYRIGHT (C) 1997 BY THE INSTITUTE OF APPLIED PHYSICS, 
!   UNIVERSITY OF BERN, SWITZERLAND

      INTEGER, INTENT(IN) :: NUM
      REAL, INTENT(IN) :: TETA,DI(NUM),EPSI(NUM),GS6(NUM)
      REAL, INTENT(OUT) :: DEI(NUM),TEI(NUM),TSCAT(NUM)
      REAL NS(NUM),COSTETASN(NUM),COSC(NUM),COSTETASC(NUM),TAUSCAT(NUM+1),&
             COSTETA(NUM)
      INTEGER I

      NS=EPSI**0.5
      COSTETASN=(1-(SIN(TETA)/NS)**2)**0.5      
      COSC=(1-(1/NS)**2)**0.5
      COSTETASC=0.5*(1+COSC)
      DEI=DI/COSTETASN
    
      TAUSCAT(NUM+1)=0

      DO I=NUM,1,-1
        TAUSCAT(I)=TAUSCAT(I+1)+DEI(I)*GS6(I)/2
        TSCAT(I)=EXP(-1*TAUSCAT(I))
        COSTETA(I)=TSCAT(I)*COSTETASN(I)+(1-TSCAT(I))*COSTETASC(I)
      END DO      

      TEI=ACOS(COSTETA)

      END SUBROUTINE PFADC

! -------------------------------------------------------------------------
!
      SUBROUTINE PFADI(TEI,DI,DEI,NUM)
!
! -------------------------------------------------------------------------
!
!     CODE ORIGINALLY OBTAINED IN MATLAB FROM MATZLER
!
!   CALCULATES THE EFFECTIVE PATH LENGTH IN A LAYER
!
!   DEI = PFADI(TEI,DI)
!       DEI:  EFFECTIVE PATH LENGTH [M]
!       TEI:  LOCAL INCIDENCE ANGLE
!       DI:   THICKNESS [M]
!
!   VERSION HISTORY:
!      1.0    WI 15.7.95
!      2.0    MD 1 APR 05 TRANSLATED TO FORTRAN FROM MATLAB
!   
!   USES - NONE
!
!   COPYRIGHT (C) 1997 BY THE INSTITUTE OF APPLIED PHYSICS, 
!   UNIVERSITY OF BERN, SWITZERLAND
      INTEGER, INTENT(IN) :: NUM
      REAL, INTENT(IN) :: TEI(NUM+1),DI(NUM)
      REAL, INTENT(OUT) :: DEI(NUM)

      DEI=DI/COS(TEI(1:NUM))

      END SUBROUTINE PFADI

! -------------------------------------------------------------------------
!
      SUBROUTINE POLDER(VFI,A,EICE,EPSI,EPSEFF,NUM)
!
! -------------------------------------------------------------------------
!  WRITTEN BY MIKE, 1 APRIL 05
!  SOLVES (1) THROUGH (5) IN MATZLER, 1996 IN IEEE
!  IMPLEMENTS NEWTON-RAPHSON ITERATION TECHNIQUE IN ORDER TO SOLVE THE RESULT
!  OF SUBSTITUTING EQUATIONS (4) AND (5) INTO (3), THEN (3) INTO (1) AND SOLVING.
!  FOR DOCUMENTATION, SEE REPORT "SOLVING FOR EEFF.SXW" UNDER REPORTS/MEMLS
!  FOLDER.
!
!  INPUTS: V - VOLUME FRACTION OF ICE
!          A - DEPOLARIZATION FACTOR
!          EICE - ICE PERMITTIVITY
!          EPSI - DRY SNOW PERMITTIVITY
!  OUTPUT: EPSEFF - EFFECITVE ICE PERMITTIVITY

      INTEGER, INTENT(IN) :: NUM
      REAL, INTENT(IN) :: VFI(NUM),A(NUM),EICE,EPSI(NUM)
      REAL, INTENT(OUT) :: EPSEFF(NUM)
      REAL EPS,X,F,U1,V1,U2,V2,B,T,DBDX,DTDX,DFDX,DELTAX
      INTEGER I,K

      EPS=0.001
      DO I=1,NUM
        X=1-EPSI(I)    !X0, INITIAL GUESS
        F=EPS*10       !DUMMY VALUE FOR FIRST GUESS
        K=1            !ITERATION COUNTER
        DO
          K=K+1
          U1=2*(1+(1-A(I))*X)
          V1=1+(1-A(I))*X+A(I)*(EICE-1)
          U2=1+2*A(I)*X
          V2=1+2*A(I)*X+(1-2*A(I))*(EICE-1)
          B=3-VFI(I)*(EICE-1)*(2*A(I)/V1+(1-2*A(I))/V2)
          T=VFI(I)*(EICE-1)*(U1/V1+U2/V2)
          DBDX=2*A(I)*VFI(I)*(EICE-1)*((1-A(I))/V1**2+(1-2*A(I))/V2**2)
          DTDX=DBDX*(EICE-1)
          DFDX=1-(B*DTDX-T*DBDX)/B**2
          DELTAX=-1*F/DFDX
          X=X+DELTAX
          F=X-T/B
          IF (ABS(F)<EPS) EXIT    ! TEST WHETHER WE ARE CLOSE ENOUGH TO ZERO
        END DO
        EPSEFF(I)=X+1
      END DO
        
      END SUBROUTINE POLDER

! -------------------------------------------------------------------------
!
      SUBROUTINE POLMIX(TSCAT,SIH,SIV,NUM)
!
! -------------------------------------------------------------------------
!
!     CODE ORIGINALLY OBTAINED IN MATLAB FROM MATZLER
!
!   CALCULATES THE POLARIZATION MIXING OF THE INTERFACE REFLECTIVITIES
!       OF EACH LAYER (TAKING INTO ACCOUNT THE FIRST ORDER SCATTERING)
!
!   [SIH,SIV] = POLMIX(TSCAT,SIH,SIV)
!       SIH:   INTERFACE REFLECTIVITY AT H-POL
!       SIV:   INTERFACE REFLECTIVITY AT V-POL
!       TSCAT: TAU SCAT
!
!   VERSION HISTORY:
!      1.0    WI 14.10.97
!      1.1    WI  4.11.97  BUG FIX (LAYER NUMBERING PROBLEM)
!      2.0    MD 1 APR 05 TRANSLATED TO FORTRAN FROM MATLAB
!
!   USES - NONE
!
!   COPYRIGHT (C) 1997 BY THE INSTITUTE OF APPLIED PHYSICS, 
!   UNIVERSITY OF BERN, SWITZERLAND
      INTEGER,INTENT(IN) :: NUM
      REAL,INTENT(IN) :: TSCAT(NUM)
      REAL,INTENT(INOUT) :: SIH(NUM+1),SIV(NUM+1)
      REAL TSCATLONG(NUM+1),SMEAN(NUM+1),DELTAS(NUM+1)

      TSCATLONG(1:NUM)=TSCAT(1:NUM)
      TSCATLONG(NUM+1)=1.

      SMEAN=0.5*(SIH+SIV)
      DELTAS=0.5*TSCATLONG*(SIH-SIV)

      SIH=SMEAN+DELTAS
      SIV=SMEAN-DELTAS

      END SUBROUTINE POLMIX

! -------------------------------------------------------------------------
!
      SUBROUTINE PRES(P0,Z,P)
!
! -------------------------------------------------------------------------
!     FUNCTION FOR CALCULATING VERTICAL PRESSURE PROFILES
!     ASSUME EXPONETIAL PRESSURE PROFILE
!     P0 = SEA LEVEL PRESSURE
!     Z = HEIGHT [KM]
!
!     HISTORY
!       1.0   KT ? ??? ??
!       2.0   MD 6 JUN 05  TRANSLATED TO FORTRAN
!
!     CODE ORIGINALLY OBTAINED IN MATLAB FROM PULLIAINEN



      REAL,INTENT(IN)::P0,Z
      REAL,INTENT(OUT)::P
      REAL ZP
   
      ZP=7.7 ! PRESSURE SCALE HEIGHT 7.7 KM
      P=P0*EXP(-Z/ZP)

      END SUBROUTINE PRES

! -------------------------------------------------------------------------
!
      SUBROUTINE RO2EPSD(ROI,TI,FREQ,EPSI,EPSII,NUM)
!
! -------------------------------------------------------------------------
!   
!     CODE ORIGINALLY OBTAINED IN MATLAB FROM MATZLER
!
!   CALCULATES THE DIELECTRIC PERMITTIVITY FROM 
!   DENSITY FOR DRY SNOW.
!
!   [EPSI,EPSII] = RO2EPSD(ROI,TI,FREQ)
!       EPSI:  REAL PART OF DIELECTRIC PERMITTIVITY
!       EPSII: IMAGINARY PART OF DIELECTRIC PERMITTIVITY
!       ROI:   DENSITY
!       TI:    SNOW TEMPERATURE IN KELVIN
!       FREQ:  FREQUENCY
!
!   VERSION HISTORY:
!      1.0    WI 15.7.95
!      2.0    WI 12.11.97  ENHANCED WITH POLDER AND VAN SANTEN EQUATIONS (SEE POLDER.M)
!      3.0    MD 1 APR 05 TRANSLATED TO FORTRAN FROM MATLAB
!
!   USES:
!       EPSICE, EPSR, POLDER
!
!   COPYRIGHT (C) 1997 BY THE INSTITUTE OF APPLIED PHYSICS, 
!   UNIVERSITY OF BERN, SWITZERLAND

      REAL, INTENT(IN) :: FREQ
      INTEGER NUM, I
      REAL, INTENT(IN) :: ROI(NUM),TI(NUM)
      REAL, INTENT(OUT) :: EPSI(NUM), EPSII(NUM)
      REAL EICE(NUM),F(NUM),EI,A(NUM),EPSP(NUM),A3(NUM),EA(NUM),EA3(NUM), & 
           K1(NUM),K3(NUM),KSQ(NUM)

      CALL EPSICE(TI,FREQ,EICE,NUM)
      CALL EPSR(ROI,NUM,EPSI)

!     IMAGINARY PART AFTER POLDER AND VAN SANTEN 1946 (EFFECTIVE-MEDIUM APPROX)

      F=ROI/0.917
      EI=3.185
      
      DO I=1,NUM
        A(I)=0.3
        IF (F(I)<0.55) THEN
          A(I)=0.476-0.64*F(I)
        END IF
        IF (F(I)<0.333) THEN
          A(I)=0.1+0.5*F(I)
        END IF
      END DO

      CALL POLDER(F,A,EI,EPSI,EPSP,NUM)

      A3=1-2*A
      EA=(EPSP*(1-A))+A
      EA3=(EPSP*(1-A3))+A3
      K1=(EA/(EA+A*(EI-1)))**2
      K3=(EA3/(EA3+A3*(EI-1)))**2
      KSQ=(2*K1+K3)/3
      EPSII=EPSI**0.5*EICE*KSQ*F

      END SUBROUTINE RO2EPSD

! -------------------------------------------------------------------------
!
      SUBROUTINE RT(GAI,GBI,DEI,RI,TI,NUM)
!
! -------------------------------------------------------------------------
!
!     CODE ORIGINALLY OBTAINED IN MATLAB FROM MATZLER
!
!   CALCULATES THE LAYER REFLECTIVITY AND TRANSMISSIVITY   
!
!
!   [RI,TI] = RT(GAI,GBI,DEI)
!       RI:   LAYER REFLECTIVITY
!       TI:   LAYER TRANSMISSIVITY
!       GAI:  ABSORPTION COEFFICIENT
!       GBI:  SCATTERING COEFFICIENT
!       DEI:  PATH LENGTH
!
!   VERSION HISTORY:
!      1.0    WI 15.7.95
!      2.0    MD 1 APR 05 TRANSLATED TO FORTRAN FROM MATLAB
!   
!   USES: NONE
!
!   COPYRIGHT (C) 1997 BY THE INSTITUTE OF APPLIED PHYSICS, 
!   UNIVERSITY OF BERN, SWITZERLAND

      INTEGER,INTENT(IN) :: NUM
      REAL,INTENT(IN) :: GAI(NUM),GBI(NUM),DEI(NUM)
      REAL,INTENT(OUT) :: RI(NUM),TI(NUM)
      REAL GAMMA(NUM),T0I(NUM),R0I(NUM),T02(NUM),R02(NUM)
      INTEGER I

      GAMMA=(GAI*(GAI+2*GBI))**0.5
      T0I=EXP(-1*GAMMA*DEI)
      
      DO I=1,NUM
        IF(GBI(I)>0.00001)THEN
          R0I(I)=GBI(I)/(GAI(I)+GBI(I)+GAMMA(I))
        ELSE
          R0I(I)=0
        END IF
      END DO

      T02=T0I**2
      R02=R0I**2
      RI=R0I*(1-T02)/(1-T02*R02)
      TI=T0I*(1-R02)/(1-T02*R02)

      END SUBROUTINE RT

! -------------------------------------------------------------------------
!
      SUBROUTINE RUFFSOIL(F,MV,T,KSIGMA,THETA,EPS_TOP,&
                   R_H_MOD,R_V_MOD)
!
! -------------------------------------------------------------------------
!
!     CODE ORIGINALLY OBTAINED IN MATLAB FROM PULLIAINEN
!
!     FUNCTION FOR CALCULATING REFLECTIVITIES OF ROUGH, BARE SOILS
!     ACCORDING TO THEORY BY WEGMÜLLER & MÄTZLER
!     F = FREQUENCY [HZ]
!     MV = VOLUMETRIC MOISTURE [0..1]
!     T = TEMP [K]
!     KSIGMA = NORMALIZED SURFACE SDEV
!     THETA = NADIR ANGLE [DEG]
!     EPS_TOP = EPSILON OF OVERLYING MEDIUM
!     EPS_SOIL = DEFINE EPSILON EXPLICITLY
!
!    VERSION HISTORY:
!      1.0    ?? ?.?.?
!      2.0    MD 1 APR 05 TRANSLATED TO FORTRAN FROM MATLAB
      
      REAL,INTENT(IN) :: F,MV,T,KSIGMA,THETA
      COMPLEX, INTENT(IN) :: EPS_TOP
      REAL,INTENT(OUT) :: R_H_MOD,R_V_MOD
      REAL GND_TEMP,GND_EPS,PI,FRESNEL_H,FRESNEL_V, THETA_R
      COMPLEX EPS_SOIL,EPS_EFF
      
      PI=3.14159
      GND_TEMP=T-273.15 ! K TO C

      CALL EPSS(MV,GND_TEMP,F,EPS_SOIL)

      EPS_EFF=EPS_SOIL/EPS_TOP

      CALL GAMMAH(EPS_EFF,THETA,FRESNEL_H)
      CALL GAMMAV(EPS_EFF,THETA,FRESNEL_V)

      THETA_R=THETA/180*PI

      R_H_MOD=FRESNEL_H*EXP(-KSIGMA**((0.1*COS(THETA_R))**0.5))

      IF (THETA<=60) THEN
        R_V_MOD=R_H_MOD*COS(THETA_R)**0.65
      ELSEIF(THETA==70)THEN
        R_V_MOD=R_H_MOD*0.621
      ELSE
        PRINT*,("OOPS!  USE R_V_MOD=R_H_MOD, SINCE THETA=") ! ADDED BY MIKE
        PRINT *, THETA
        R_V_MOD=R_H_MOD     
      END IF

      END SUBROUTINE RUFFSOIL

! -------------------------------------------------------------------------
!
      SUBROUTINE SCCOEFF(ROI,TI,PCI,FREQ,WIFR,GAI,SCCHO,GBIH,GBIV,GS6,&
                           GA2I,NUM,EPSI,EPSII)
!
! -------------------------------------------------------------------------
!
!     CODE ORIGINALLY OBTAINED IN MATLAB FROM MATZLER, MODIFIED BY MIKE (SEE VERSION HISTORY)
!
!   CALCULATES THE SCATTERING COEFFICIENT FROM STRUCTURAL PARAMETERS
!     DIFFERENT ALGORITHMS CAN BE CHOSEN, BY CHANGING "SCCHO"
!
!   [GBIH,GBIV,GS6,GA2I] = SCCOEFF(ROI,TI,PCI,FREQ,WI,GAI,SCCHO)
!       GBIH:  2-FLUX SCATTERING COEFFICIENT AT H POL
!       GBIV:  2-FLUX SCATTERING COEFFICIENT AT V POL
!       GS6:   6-FLUX SCATTERING COEFFICIENT
!       GA2I:  2-FLUX ABSORPTION COEFFICIENT
!       ROI:   DENSITY
!       TI:    PHYSICAL TEMPERATURE
!       PCI:   CORRELATION LENGTH
!       FREQ:  FREQUENCY
!       WI:    WETNESS
!       GAI:   ABSORPTION COEFFICIENT
!       SCCHO: SCATTERING COEFFICIENT ALGORITHM CHOSEN
!
!   VERSION HISTORY:
!      1.0B    WI 15.7.95
!      1.0     WI 23.9.97 BUG FIXED
!      1.1     WI 26.9.97 LATEST FIT ON EXPERIMENTAL DATA WAS ADDED (OPTION 7)
!      1.2     WI 13.10.97 OPTION 8 ADDED, ADAPTED SCATTERING OF A SHELL/SPHERE TO NOTE 9/VER2 
!      1.3     WI  4.11.97 OPTION 9, 10 AND 11 ADDED 
!      1.4     WI 27.05.98 BORN APPROXIMATION ADDED (BORNA.M)
!      2.0     MD 1 APR 05 CALL TO BORNA CHANGED TO CALL TO BORN (BY MIKE).  ALL OPTIONS FOR 
!                            OTHER SHAPES REMOVED BUT BORN APPROX AND THE APPROX FOR FINE GRAIN 
!                            SNOW IN WIESMANN AND MATZLER 1999
!
!   USES: BORN
!
!
!   COPYRIGHT (C) 1997 BY THE INSTITUTE OF APPLIED PHYSICS, 
!   UNIVERSITY OF BERN, SWITZERLAND

      INTEGER, INTENT(IN) :: NUM,SCCHO
      REAL, INTENT(IN) :: ROI(NUM),TI(NUM),PCI(NUM),FREQ,WIFR(NUM),&
                            GAI(NUM),EPSI(NUM),EPSII(NUM)
      REAL, INTENT(OUT) :: GBIH(NUM),GBIV(NUM),GS6(NUM),GA2I(NUM)
      REAL C,ROAIR,ROICE,DGB0H,DGB0V,K,EICE,VFI(NUM),PI,KP(NUM),GB6(NUM),&
             GC6(NUM),GF6(NUM),GTR(NUM),OMEGA(NUM)

      ! CONSTANTS
      PI=3.14159
      C=2.99
      ROAIR=0.001293
      ROICE=0.917

      ! SPECULAR COMPONENT OF SCATTERING COEFFICIENT
      !   USUALLY 0 CAN BE IMPORTANT IN NEW SNOW!
      DGB0H=0.
      DGB0V=0.
      K=FREQ*2*PI/0.299793
      EICE=3.18
      VFI=ROI/ROICE
            
      IF (SCCHO==1) THEN
        !FIT VOM 4.11.97 (WITH DENSITY, USES CORR. LENGTH FROM EXP. FIT!)
        GS6=(9.2*PCI-1.23*ROI+0.54)**2.5*(FREQ/50)**2.5
        OMEGA=((EPSI-1)/EPSI)**0.5
        GB6=0.5*GS6*(1-OMEGA)
        GC6=0.25*GS6*OMEGA
      ELSEIF (SCCHO==2) THEN
         ! BORN APPROXIMATION
         CALL BORN(K,VFI,PCI,EPSI,EICE,GB6,GC6,GF6,GS6,NUM)
      END IF

      ! COMPUTE OTHER SCATTERING COEFFICIENTS

      GTR=(4*GC6)/(GAI+2*GC6)
      GA2I=GAI*(1+GTR)
      GBIH=(GB6+DGB0H)+GTR*GC6
      GBIV=(GB6+DGB0V)+GTR*GC6

      END SUBROUTINE SCCOEFF

! -------------------------------------------------------------------------
!
      SUBROUTINE SKYTEMP(N_F,FREQ,THETAD,STEP,P0,T0,MONTH,MOIST0,TSKY,TRAN)
!
! -------------------------------------------------------------------------

!     CODE ORIGINALLY OBTAINED IN MATLAB FROM PULLIAINEN

!
!     FUNCTION FOR CALCULATING THE ATMOSPHERIC BRIGHTNESS TEMPERATURE
!      AND TRANSMISSIVITY
!     
!     BY K. TIGERSTEDT 1997
!
!     [TSKY,TRAN] = SKYTEMP(FREQ,THETAD,STEP,P0,T0,MONTH,MOIST0) 
!
!       FREQUENCY RANGE; TYP. FREQ = [1 5 10 15 19:24 30 40 50 55:65 70 80 90 100]  [GHZ]
!       STEP SIZE; TYP.  STEP = 0.05 [KM]
!       GROUND PRESSURE; TYP. P0 = 1013 [MBAR]    	
!       GROUND TEMP.; TYP. T0 = 293.15 [K]
!       SEASON (MONTH) [1..12];
!       GROUND-LEVEL WATER-VAPOUR; TYP. MOIST0 = 7.5 [G/M^3]
!       CLOUD DATA: CLOUD_DATA = [CLOUD_ANAL CL_LOWER CL_UPPER MV RC ALFA GAMMA]
!
!       NOTE: THIS NEXT BIT ABOUT CLOUDS IRRELEVANT, SINCE CLOUDS NOT INCLUDED HERE.
!
!       WHERE 
!             CLOUD_ANAL  = 0/1   INCLUSION OF CLOUD ANALYSIS
!             CL_LOWER    = LOWER BOUNDARY OF CLOUD [KM]
!             CL_UPPER    = UPPER BOUNDARY OF CLOUD [KM]
!             MV          = LIQUID WATER CONTENT OF CLOUD [G/M^3]
!             RC          = MEAN DROP RADIUS 
!             ALFA, GAMMA = SHAPE PARAMETERS
!
!       1.0   KT ? ??? 97
!       2.0   MD 2 JUN 05  TRANSLATED TO FORTRAN
!   
!   USES:
!


      INTEGER,INTENT(IN) :: MONTH,N_F
      !REAL,INTENT(IN) :: FREQ(N_F),THETAD(N_F),STEP,P0,T0,MOIST0
      REAL,INTENT(IN) :: FREQ,THETAD,STEP,P0,T0,MOIST0
      !REAL, INTENT(OUT) :: TSKY(N_F),TRAN(N_F)
      REAL, INTENT(OUT) :: TSKY,TRAN
      INTEGER I,J,N_STEPS
      REAL CEILING,TCOSMIC,T0K,PI,THETA(N_F),ATTCO,TAU_Z,TATM,KAPPA_DZ_OLD,&
             H,P,T,WV,CLOUD_SCA,CLOUD_EXT,CLOUD_ABS,K_O2,K_WV,KAPPA_DZ,&
             TOTAL_TAU_Z,TOTAL_ATTCO
      
      CEILING=20
      TCOSMIC=2.7
      T0K=273.15
      PI=3.14159
      THETA=THETAD/180*PI

      N_STEPS=CEILING/STEP+2

      DO I=1,N_F
        ATTCO=0.0
        TAU_Z=0.0
        TATM=0.0
        KAPPA_DZ_OLD=0.0

        DO J=1,N_STEPS
          H=CEILING-STEP*(J-1)
          CALL PRES(P0,H,P)
          CALL TEMP(T0,H,MONTH,T)
          CALL WVPROF(MOIST0,H,WV)
          
          ! FOR NOW, ASSUME THAT THERE ARE NO CLOUDS
          CLOUD_SCA=0.0
          CLOUD_EXT=0.0
          CLOUD_ABS=0.0

          ! NOTE THAT WE APPROXIMATE T_UP AS T_DOWN... SEE TEXT ON P.283
          CALL OXABSORP(FREQ,T,P,K_O2)
          CALL WVABSORB(FREQ,T,P,WV,K_WV)  
          ! PART OF THE INTEGRAND IN 5.44
          KAPPA_DZ=(K_O2+K_WV)*STEP/(10*LOG10(EXP(1.0)))+CLOUD_ABS*STEP*1000
          ! PART OF THE INTEGRAND IN 5.44
          TAU_Z=TAU_Z+KAPPA_DZ_OLD/COS(THETA(I))
          ! THIS IS 5.47, L_THETA
          ATTCO=EXP(-TAU_Z)
          ! THIS MAY BE 5.49
          TATM=TATM+(1-EXP(-KAPPA_DZ/COS(THETA(I))))*T*ATTCO
          KAPPA_DZ_OLD=KAPPA_DZ+CLOUD_SCA*STEP*1000
        END DO
        TOTAL_TAU_Z=TAU_Z+KAPPA_DZ_OLD/COS(THETA(I))
        TOTAL_ATTCO=EXP(-TOTAL_TAU_Z)
   
        TSKY = TATM
        TRAN = TOTAL_ATTCO       
      END DO
      
      END SUBROUTINE SKYTEMP
! -------------------------------------------------------------------------
!
      SUBROUTINE SLRED(NUM,ROI,EPSI,EPSII,TEI,SIH,SIV,DI,DEI,TI,PCI,WI,GAI,&
        FREQ,RNUM,XROI,XEPSI,XEPSII,XTEI,XSIH,XSIV,XDI,XDEI,XTI,XPCI,XWI,XGAI)
!
! -------------------------------------------------------------------------
!
!     NOTE!! I DID NOT IMPLEMENT THE FULL SLRED SUBROUTINE FROM MEMLS
!       BECUASE I USUALLY DON'T WORK WITH SNOWPACKS WITH ANY THIN LAYERS.  
!       THIS CODE WILL NOT FUNCTION WITH SNOWPACKS WITH SUCCEEDING COHERENT 
!       LAYERS; IF LAYER I AND I+1 ARE BOTH COHERENT, THE PROGRAM WILL STOP
!       ALTOGETHER, AND PRINT AN ERROR MESSAGE. THIS CODE WILL CHECK WHETHER 
!       THERE ARE COHERENT SCATTERING LAYERS AND INCORPORATE THESE INTO 
!       THE INTERFACE REFLECTIVITIES.  IF THERE ARE SUCCEEDING COHERENT
!       LAYERS IT WILL STOP EXECUTION.  IF THERE ARE NO COHERENT LAYERS,
!       IT ASSIGNS THE INPUT ARRAYS TO THE OUTPUT ARRAYS.
!
!     CODE ORIGINALLY OBTAINED IN MATLAB FROM MATZLER
!
!   LOCATES AND TREATS COHERENT LAYERS IN A SNOWPACK
!     SEE TECHNOTE 11
!
!   [RNUM,RROI,REPSI,REPSII,RTEI,RSIH,RSIV,RDI,RDEI,RTI,RPCI,RWI,RGAI]=SLRED(NUM,&
!                                ROI,EPSI,EPSII,TEI,SIH,SIV,DI,DEI,TI,PCI,FREQ,WI,GAI) 
!       NUM:  INDEX OF THE LAYER IN THE ORIGINAL SNOWPACK
!       ROI:  DENSITY [G/CM^3]
!       EPSI:
!       EPSII:
!       TEI:  LOCAL INCIDENCE ANGLE
!       SIH:  LAYER REFLECTIVITY AT H POL
!       SIV:  LAYER REFLECTIVITY AT V POL
!       DI:   LAYER THICKNESS
!       DEI:  LOCAL PATH LENGTH [M]
!       TI:   PHYSICAL SNOW TEMPERATURE [K]
!       PCI:  CORRELATION LENGTH [MM]
!       WI:   WETNESS  
!       GAI:  ABSORPTION COEFFICIENT
!       FREQ: FREQUENCY
!
!      1.0    WI 21.8.95
!      2.0    WI 13.8.98  COMPLETELY REWRITTEN
!      3.0    MD 1  APR 05 STRIPPED DOWN TO ONLY CHECK FOR COHERENT LAYERS -MD
!      3.1    MD 18 APR 05 FUNCTIONALITY ADDED TO DEAL WITH COHERENT LAYERS, 
!                            SO LONG AS THERE ARE NOT SUCCEEDING LAYERS
!   
!   USES:
!       FRESNELRC
!
!   COPYRIGHT (C) 1997 BY THE INSTITUTE OF APPLIED PHYSICS, 
!   UNIVERSITY OF BERN, SWITZERLAND
      INTEGER,INTENT(IN) :: NUM
      REAL,INTENT(IN) :: ROI(NUM),EPSI(NUM),EPSII(NUM),TEI(NUM+1),SIH(NUM),&
        SIV(NUM),DI(NUM),DEI(NUM),TI(NUM),PCI(NUM),WI(NUM),GAI(NUM),FREQ
      REAL,INTENT(OUT) :: XROI(NUM),XEPSI(NUM),XEPSII(NUM),XTEI(NUM+1),XSIH(NUM),&
        XSIV(NUM),XDI(NUM),XDEI(NUM),XTI(NUM),XPCI(NUM),XWI(NUM),XGAI(NUM)
      INTEGER, INTENT(OUT) :: RNUM
      INTEGER, DIMENSION(:), ALLOCATABLE :: I
      REAL CC,PI,FIC,FC,THETA,NS(NUM),FI(NUM),FH(NUM),FV(NUM),EPSI_AUG(NUM+1),&
             X(NUM)
      INTEGER J,NTHIN,A(NUM),PL,SC,SCMAX,ML,MLO,M,K,NAEQ0,NAEQ1

      ! CONSTANTS
      CC=0.299793
      PI=3.14159
      FIC=4*PI*FREQ/CC
      FC=4.712

      ! COMPUTE FI IN ORDER TO CHECK ON COHERENT LAYERS
      THETA=TEI(NUM+1)
      NS=EPSI**0.5
      FI=FIC*DI*NS*COS(TEI(1:NUM))

      ! COUNT THE THIN LAYERS
      NTHIN=0
      DO J=1,NUM
        IF (FI(J)<FC) THEN
          NTHIN=NTHIN+1
        END IF
      END DO

      ! ALLOCATE THE I ARRAY, WHICH CONTAINS THE INDECES OF THE THIN LAYERS
      ALLOCATE(I(1:NTHIN))

      ! DEFINE THE I AND A ARRAYS.  THE A ARRAY HAS A VALUE OF 1 FOR THIN 
      !   LAYERS AND 0 OTHERWISE
      K=0
      DO J=1,NUM
        IF (FI(J)<FC) THEN
          K=K+1
          I(K)=J
          A(J)=1
        ELSE
          A(J)=0
        END IF
      END DO
      ! THE BOTTOM LAYER IS ALWAYS ASSUMED NONCOHERENT
      A(1)=0

      ! CHECK TO SEE IF WE HAVE ANY COHERENT LAYERS TO TREAT.  IF NOT, ALLOCATE
      !   THE REPLACEMENT ARRAYS (WITH THE 'R' PREFIX) WITH A SIZE OF THE ORIGINAL
      !   NUMBER OF LAYERS, THEN DEFINE THOSE ARRAYS BASED ON THE ORIGINAL VALUES 

      IF (NTHIN>0) THEN

        PRINT *, NTHIN, 'COHERENT LAYER(S) FOUND; FREQ = ',FREQ,' GHZ'

        ! TREAT COHERENT LAYERS IN THE SNOWPACK
        ! 1. IDENTIFY SUCCEEDING COHERENT LAYERS AND MARK THE PACKS FROM 2,3...SCMAX
        PL=0
        SC=1
        SCMAX=0
        ML=0
        MLO=0

        DO M=2,NUM
          IF (A(M)==1 .AND. PL==1) THEN
            IF(ML==0)THEN
              SC=SC+1
              ML=1
              A(M-1)=SC
            END IF

            A(M)=SC
            SCMAX=SC
          ELSE
            IF (PL==1) THEN
              PL=0
            ELSE
              IF(A(M)==1)THEN
                PL=1
                ML=0
              END IF
            END IF
          END IF
        END DO
 
      ! I AM NOT IMPLEMENTING THE COMBINATION OF SUCCESSIVE COHERENT LAYERS BECAUSE
      !   I HAVE NO DATA TO VERIFY THE EXECUTION OF THE CODE AGAINST.  IF THIS FEATURE
      !   BECOMES NECESSARY, THE NECESSARY SNOW DATA COULD BE DERIVED FROM SNTHERM
      !   OUTPUT.

        IF (SCMAX>0) THEN
          PRINT *,"THERE ARE SUCCESSIVE COHERENT LAYERS IN THE SNOWPACK... ABORTING"
          WRITE(2,*) 999,999,999,999,999,999,999,999
          STOP
        END IF
        
      ! I AM OMITTING THE NEXT SECTION OF CODE, SINCE (UNDER THE CONDITION DESCRIBED ABOVE
      !   OF NO SUCCEEDING COHERENT LAYERS IN THE PACK) THE I VECTOR AS DEFINED BY VALUES
      !   OF THE A VECTOR THAT ARE LESS THAN TWO WILL ALWAYS CONSIST OF ALL OF THE SNOWPACK
      !   LAYERS.  THEREFORE, I DO NOT NEED TO REDEFINE I AND A AS THEY ARE BEFORE THE 
      !   INITIALIZATION OF THE SIH, SIV AND X ARRAYS.  NOR DO I NEED TO INITIALIZE SIH,
      !   SIV OR X.

      ! CALCULATE INTERFACE REFLECTION COEFFICIENTS

        EPSI_AUG(1:NUM)=EPSI
        EPSI_AUG(NUM+1)=1.0

        CALL FRESNELRC(TEI,EPSI_AUG,FH,FV,NUM)

     !  REDUCTION ON LAYERS OF TYPE 0 (COHERENT LAYER EFFECTS ARE 
     !    TAKEN INTO ACCOUNT IN THE LAYER REFLECTIVITIES)
     !    FOR LAYERS OF TYPE 0 SHI = FH^2

     !  FIND THE VALUES OF A EQUAL TO ZERO
        DEALLOCATE(I)
        DO J=1,NUM
          IF (A(J)==0) THEN
            NAEQ0=NAEQ0+1
          END IF
        END DO
        ALLOCATE(I(1:NAEQ0))

        K=0
        DO J=1,NUM
          IF (A(J)==0) THEN
            K=K+1
            I(K)=J
          END IF
        END DO

     !  INITIALIZE VARIABLES
        XSIH=0
        XSIV=0
        DO J=1,NAEQ0
          XSIH(I(J))=FH(I(J))**2
          XSIV(I(J))=FV(I(J))**2
        END DO


     !  FIND THE VALUES OF A EQUAL TO ONE
        DEALLOCATE(I)
        DO J=1,NUM
          IF (A(J)==1) THEN
            NAEQ1=NAEQ1+1
          END IF
        END DO
        ALLOCATE(I(1:NAEQ1))

        K=0
        DO J=1,NUM
          IF (A(J)==1) THEN
            K=K+1
            I(K)=J
          END IF
        END DO
        
        X=0 !INITIALIZE VARIABLES
        DO J=1,NAEQ1
          X(I(J))=2*FH(I(J))*FH(I(J)-1)*COS(FI(I(J)))
          XSIH(I(J)-1)=(FH(I(J))**2+FH(I(J)-1)**2+X(I(J)))/&
            (1+FH(I(J))**2*FH(I(J)-1)**2+X(I(J)))
          X(I(J))=2*FV(I(J))*FV(I(J)-1)*COS(FI(I(J)))
          XSIV(I(J)-1)=(FV(I(J))**2+FV(I(J)-1)**2+X(I(J)))/&
            (1+FV(I(J))**2*FV(I(J)-1)**2+X(I(J)))
        END DO

     !  FIND THE VALUES OF A EQUAL TO ZERO
        DEALLOCATE(I)
        ALLOCATE(I(1:NAEQ0))
        K=0
        DO J=1,NUM
          IF (A(J)==0) THEN
            K=K+1
            I(K)=J
          END IF
        END DO

     !  DEFINE OUTPUT VARIABLES
        DO J=1,NAEQ0
          XROI(J)=ROI(I(J))
          XTEI(J)=TEI(I(J))
          XDI(J)=DI(I(J))
          XTI(J)=TI(I(J))
          XPCI(J)=PCI(I(J))
          XWI(J)=WI(I(J))
          XGAI(J)=GAI(I(J))
          
          XSIH(J)=XSIH(I(J))
          XSIV(J)=XSIV(I(J))

          XEPSI(J)=EPSI(I(J))
          XEPSII(J)=EPSII(I(J))
          XDEI(J)=DEI(I(J))
        END DO

        RNUM=NUM-NTHIN
        XTEI(RNUM+1)=THETA               
      ELSE
        ! THERE ARE NO COHERENT LAYERS, SO SET THE OUTPUT ARRAYS EQUAL TO THE INPUT ARRAYS
        RNUM=NUM    
        XROI=ROI
        XEPSI=EPSI
        XEPSII=EPSII
        XTEI=TEI
        XSIH=SIH
        XSIV=SIV
        XDI=DI
        XDEI=DEI
        XTI=TI
        XPCI=PCI
        XWI=WI
        XGAI=GAI
      END IF
             

      END SUBROUTINE SLRED

! -------------------------------------------------------------------------
!
      SUBROUTINE SNOWAO(V,A,NUM)
!
! -------------------------------------------------------------------------
!
!     CODE ORIGINALLY OBTAINED IN MATLAB FROM MATZLER
!
!   COMPUTES THE DEPOLARIZATION FACTOR OF OBLATE SNOW GRAINS
!   NOTE 10, MÄTZLER 1997
!
!   A = SNOWAO(V)
!       A:    DEPOLARIZATION FACTOR OF OBLATE SNOW GRAINS
!       V:    VOLUME FRACTION OF ICE
!
!   VERSION HISTORY:
!      1.0    WI 29.5.98
!      2.0    MD 1 APR 05 TRANSLATED TO FORTRAN FROM MATLAB
!
!   USES: NONE
!       
!   COPYRIGHT (C) 1997 BY THE INSTITUTE OF APPLIED PHYSICS, 
!   UNIVERSITY OF BERN, SWITZERLAND

      INTEGER, INTENT(IN) :: NUM
      REAL, INTENT(IN) :: V(NUM)
      REAL, INTENT(OUT) :: A(NUM)
      INTEGER I

      DO I=1,NUM
        A(I)=0.3
        IF (V(I)<0.55) THEN
          A(I)=0.476-0.64*V(I)
        END IF
        IF (V(I)<=0.333) THEN
          A(I)=0.1+0.5*V(I)
        END IF
      END DO

      END SUBROUTINE SNOWAO

! -------------------------------------------------------------------------
!
      SUBROUTINE TEMP(T0,Z,MONTH,T)
!
! -------------------------------------------------------------------------
!     FUNCTION FOR CALCULATING VERTICAL TEMPERATURE PROFILE
!     T0 = GROUND TEMPERATURE [K]
!     Z = HEIGHT [KM]
!     MONTH = [1..12]
!
!     HISTORY
!       1.0   KT ? MAR 97  PROGRAMMED
!       1.1   KT ? DEC 97  UPDATED
!       2.0   MD 6 JUN 05  TRANSLATED TO FORTRAN
!
!     CODE ORIGINALLY OBTAINED IN MATLAB FROM PULLIAINEN


      INTEGER,INTENT(IN)::MONTH
      REAL,INTENT(IN)::T0,Z
      REAL,INTENT(OUT)::T
      REAL H1,H2,G2,K1,K2,K3,T2,T1      

      H1=8

      IF (MONTH.EQ.1)THEN
              K1 = 2.958E-3
              K2 = -5.832E-3
              K3 = 3.771E-4
              T2 = 217
              H2 = 8.5
      ELSEIF (MONTH.EQ.2)THEN
              K1 = -2.196E-3
              K2 = -4.419E-3
              K3 = 2.673E-4
              T2 = 218.33
              H2 = 8.75
      ELSEIF (MONTH.EQ.3)THEN
              K1 = -1.717E-2
              K2 = -4.056E-4
              K3 = -4.252E-5
              T2 = 219.67
              H2 = 9
      ELSEIF (MONTH.EQ.4)THEN
              K1 = -2.702E-2
              K2 = 2.327E-3
              K3 = -2.521E-4
              T2 = 221.00
              H2 = 9.25
      ELSEIF (MONTH.EQ.5)THEN
              K1 = -3.33E-2
              K2 = 3.915E-3
              K3 = -3.616E-4
              T2 = 222.33
              H2 = 9.5
      ELSEIF (MONTH.EQ.6)THEN
              K1 = -3.461E-2
              K2 = 4.154E-3
              K3 = -3.632E-4
              T2 = 223.67
              H2 = 9.75
      ELSEIF (MONTH.EQ.7)THEN
              K1 = -3.213E-2
              K2 = 3.69E-3
              K3 = -3.317E-4
              T2 = 225
              H2 = 10.0
      ELSEIF (MONTH.EQ.8)THEN
              K1 = -3.05E-2
              K2 = 3.423E-3
              K3 = -3.182E-4
              T2 = 223.67
              H2 = 9.75
      ELSEIF (MONTH.EQ.9)THEN
              K1 = -2.928E-2
              K2 = 3.543E-3
              K3 = -3.472E-4
              T2 = 222.33
              H2 = 9.5
      ELSEIF (MONTH.EQ.10)THEN
              K1 = -1.997E-2
              K2 = 1.777E-3
              K3 = -2.621E-4
              T2 = 221
              H2 = 9.25
      ELSEIF (MONTH.EQ.11)THEN
              K1 = -1.533E-2
              K2 = 8.062E-4
              K3 = -2.24E-4
              T2 = 219.67
              H2 = 9.0
      ELSEIF (MONTH.EQ.12)THEN
              K1 = -5.856E-3
              K2 = -2.773E-3
              K3 = 1.086E-4
              T2 = 218.33
              H2 = 8.75
      END IF

      T1 = T0*(1 + K1*H1 + K2*H1**2 + K3*H1**3)

      IF (Z.LT.8) THEN
              T = T0*(1 + K1*Z + K2*Z**2 + K3*Z**3)
      ELSEIF (Z.GE.8.AND.Z.LT.H2)THEN
              T = (T1-T2)*(Z-H2) / (H1 - H2) + T2
      ELSEIF (Z.GE.H2.AND.Z.LE.20) THEN
              T = T2
      END IF      
              

      END SUBROUTINE TEMP


! -------------------------------------------------------------------------
!
      SUBROUTINE WVABSORB(F,T,P,PV,K_WV)
!
! -------------------------------------------------------------------------
!     FUNCTION FOR CALCULATING WATER-VAPOR ABSORPTION [DB/KM]

!     F IS FREQUENCY IN GHZ
!     T IS TEMPERATURE IN KELVINS
!     P IS PRESSURE IN MILLIBARS
!     PV = WATER-VAPOR DENSITY IN G/M^3
!
!     HISTORY
!       1.0   KT ? NOV 96
!       2.0   MD 6 JUN 05  TRANSLATED TO FORTRAN
!
!     CODE ORIGINALLY OBTAINED IN MATLAB FROM PULLIAINEN

      REAL,INTENT(IN)::F,T,P,PV
      REAL,INTENT(OUT)::K_WV
      INTEGER I
      REAL WVLINE(10,6),FI(10),EI(10),AI(10),GI0(10),AI_LC(10),XI(10),&
             GI,SIGMA,KH2O,DKAPPA
      
!     TABLE 5.3 IN ULABLY (1981)      
      WVLINE=RESHAPE((/&
      22.23515,  644.0,  1.0,   2.85, 1.75, 0.626,&
      183.31012, 196.0,  41.9,  2.68, 2.03, 0.649,&
      323.00000, 1850.0, 334.4, 2.30, 1.95, 0.420,&
      325.15380, 454.0,  115.7, 3.03, 1.85, 0.619,&
      380.19680, 306.0,  651.8, 3.19, 1.82, 0.630,&
      390.00000, 2199.0, 127.0, 2.11, 2.03, 0.330,&
      436.00000, 1507.0, 191.4, 1.50, 1.97, 0.290,&
      438.00000, 1070.0, 697.6, 1.94, 2.01, 0.360,&
      442.00000, 1507.0, 590.2, 1.51, 2.02, 0.332,&
      448.00080, 412.0,  973.1, 2.47, 2.19, 0.510/),&
       (/10,6/),ORDER=(/2,1/))

      FI = WVLINE(:,1)
      EI = WVLINE(:,2)
      AI = WVLINE(:,3)
      GI0 = WVLINE(:,4)
      AI_LC = WVLINE(:,5)
      XI = WVLINE(:,6)

      SIGMA = 0.

      DO I=1,10
        !THIS CORRESPONDS TO 5.29
        GI=GI0(I)*(P/1013.)*(300./T)**XI(I)*(1.+10.**(-2.)*AI_LC(I)*PV*T/P)

        !THIS CORRESPONDS TO SUMMATION TERM IN 5.28
        SIGMA=SIGMA+AI(I)*EXP(-EI(I)/T)*GI/((FI(I)**2-F**2)**2+4*F**2*GI**2)
      END DO

      !THIS CORRESPONDS TO 5.28
      KH2O = 2*F**2*PV*(300/T)**2.5*SIGMA

      !THIS CORRESPONDS TO 5.31
      DKAPPA = 4.69E-6*PV*(300/T)**2.1*(P/1000)*F**2

      !THIS CORRESPONDS TO 5.30
      K_WV = KH2O+DKAPPA

      END SUBROUTINE WVABSORB


! -------------------------------------------------------------------------
!
      SUBROUTINE WVPROF(M0,Z,M)
!
! -------------------------------------------------------------------------
!     FUNCTION FOR CALCULATING VERTICAL WATER VAPOUR PROFILES
!     ASSUME EXPONETIAL PRESSURE PROFILE
!     M0 = SEA LEVEL PRESSURE
!     Z = HEIGHT [KM]
!
!     HISTORY
!       1.0   KT ? ??? ??
!       2.0   MD 6 JUN 05  TRANSLATED TO FORTRAN
!
!     CODE ORIGINALLY OBTAINED IN MATLAB FROM PULLIAINEN



      REAL,INTENT(IN)::M0,Z
      REAL,INTENT(OUT)::M
      REAL ZM
   
      ZM=2.35 ! WATER VAPOUR SCALE HEIGHT 2.35 KM
      M=M0*EXP(-Z/ZM)

      END SUBROUTINE WVPROF


subroutine TEST_SSVA_RTM()

use utilities_mod, only : logfileunit
use     types_mod, only : r4

! test THE forward observation operator

integer, parameter :: N_FREQ = 1  ! observations come in one frequency at a time
integer, parameter :: N_POL  = 2  ! code automatically computes both polarizations
integer   :: nlayers              ! number of snow levels - 5 in this case
character :: pol                  ! observation polarization [H,V]

integer, parameter ::   VEG_SWITCH1 = 1
integer, parameter ::   VEG_SWITCH2 = 0
integer, parameter ::   VEG_SWITCH3 = 0
integer, parameter ::   ATM_SWITCH  = 1
REAL VEGDATA(7),ATMOSDATA(4)

! variables required by ss_snow() routine
real(r4), allocatable, dimension(:,:) :: y ! 2D array
real(r4) :: aux_ins(5) ! properties: [nlyrs, ground_T, soilsat, poros, proportionality]
integer  :: ctrl(8)        ! N_LYRS, N_AUX_INS, N_SNOW_INS, N_FREQ
!real(r4) :: FREQ( N_FREQ)  ! frequencies at which calculations are to be done
real(r4) :: FREQ  ! frequencies at which calculations are to be done
real(r4) :: TETAD(N_FREQ)  ! incidence angle of satellite
real(r4) :: tb_ubc(N_POL,N_FREQ) ! UPPER BOUNDARY CONDITION BRIGHTNESS TEMPERATURE
real(r4) :: tb_out(N_POL,N_FREQ) ! brightness temperature
REAL LAI
REAL,DIMENSION(4) :: CAN_TRAN3_IN


TETAD(:) = 55.0   ! AMSR-E incidence angle
!FREQ(:)  = 89.0   ! test frequency (GHz)
FREQ  = 89.0   ! test frequency (GHz)
pol      = 'H'    ! test polarization
nlayers  = 5      ! 5 snow layers in test

allocate( y(nlayers,5) ) ! snow layers -x- 5 properties

tb_ubc(:,N_FREQ) = (/ 2.7, 2.7 /)  ! two polarizations

ctrl(1) = nlayers
ctrl(2) = 0         ! not used as far as I can tell
ctrl(3) = 5
ctrl(4) = N_FREQ
ctrl(5) = VEG_SWITCH1 
ctrl(6) = VEG_SWITCH2
ctrl(7) = VEG_SWITCH3
ctrl(8) = ATM_SWITCH


aux_ins(1) = real(nlayers,r4)
aux_ins(2) = 271.1123
aux_ins(3) = 0.3
aux_ins(4) = 0.4
aux_ins(5) = 0.5_r4


y(:,1) = (/   0.6213,   0.2071,   0.1033,   0.0497,   0.0200 /) ! snow thickness (meters)
y(:,2) = (/ 270.5943, 150.7856,  96.1940,  66.4903,  58.0377 /) ! density (kg/m3)
y(:,3) = (/  93.1651,  84.0811,  67.6715,  66.8529,  65.6391 /) / 1000000.0_r4  ! grain diameter (m)
y(:,4) = (/   0.0000,   0.0000,   0.0000,   0.0000,   0.0000 /) ! liquid water fraction
y(:,5) = (/ 266.1220, 256.7763, 247.9525, 240.4609, 235.8929 /) ! temperature (K)

!============ATOURE ======================
!define canopy parameters
ATMOSDATA(1) = 270   !ground level atmospheric temperature in K
ATMOSDATA(2) =1013.25!ground level atmospheric pressure in mbar
ATMOSDATA(3) =7.5    !ground level water vapor in atmosphere in g/m3
ATMOSDATA(4) =11     !month of year

!define canopy parameters
VEGDATA(1) =  5.1   ! canopy height [m]
VEGDATA(2) = -5     ! vegetation temperatue [deg C]
VEGDATA(3) = 0.5    ! gravimetric water content [frac]
VEGDATA(4) = 8      ! salinity, promilles        
VEGDATA(5) = 0.1E-2 ! needle thickness / diameter [m]
VEGDATA(6) = 0.8E-2 ! needle length [m]
VEGDATA(7) =12456   ! needle number density [#/m^-3]
LAI       = 0.5     ! Leaf Area Index [m2 / m2]

CAN_TRAN3_IN(1) = 0.62 ! b1_can(1) = 0.62 !H 0.62 used in Huang et al. (2008) for both pol
CAN_TRAN3_IN(1) = 0.62 !b1_can(2) = 0.62  !V

CAN_TRAN3_IN(1) = -0.4 !x_can(1) = -0.4 !H -1.08 for wheat (stem-dominated)
                            ! and -1.38 for soybean (leaf-dominated)
CAN_TRAN3_IN(1) = -0.4!x_can(2) = -0.4 !V from Jackson and Schmugge (1991)



! =======================================



! the tb_out array contains the calculated brightness temperature outputs
! at each polarization (rows) and frequency (columns).

!call ss_model(ctrl, FREQ, TETAD, y, tb_ubc, aux_ins, tb_out)
call ssva_rtm(ctrl,FREQ,TETAD,Y,LAI,tb_ubc,aux_ins,VEGDATA,CAN_TRAN3_IN,ATMOSDATA,tb_out)

write(     *     ,*)'SSVA_RTM() TEST: tb_out is ',tb_out,' should be  205.9256 206.9057'
write(logfileunit,*)'SSVA_RTM() TEST: tb_out is ',tb_out,' should be  205.9256 206.9057'

deallocate( y )

end subroutine TEST_SSVA_RTM


end module  rtm_memls_ssva_mod

! <next few lines under version control, do not edit>
! $URL$
! $Id$
! $Revision$
! $Date$

